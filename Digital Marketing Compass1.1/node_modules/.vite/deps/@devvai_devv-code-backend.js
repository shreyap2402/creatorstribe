import {
  __commonJS
} from "./chunk-G3PMV62Z.js";

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:buffer
var require_buffer = __commonJS({
  "browser-external:buffer"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "buffer" has been externalized for browser compatibility. Cannot access "buffer.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/js-sha256/src/sha256.js
var require_sha256 = __commonJS({
  "node_modules/js-sha256/src/sha256.js"(exports, module) {
    (function() {
      "use strict";
      var ERROR = "input is invalid type";
      var WINDOW = typeof window === "object";
      var root = WINDOW ? window : {};
      if (root.JS_SHA256_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === "object";
      var NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node && process.type != "renderer";
      if (NODE_JS) {
        root = global;
      } else if (WEB_WORKER) {
        root = self;
      }
      var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && typeof module === "object" && module.exports;
      var AMD = typeof define === "function" && define.amd;
      var ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var EXTRA = [-2147483648, 8388608, 32768, 128];
      var SHIFT = [24, 16, 8, 0];
      var K = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ];
      var OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"];
      var blocks = [];
      if (root.JS_SHA256_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      if (ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var createOutputMethod = function(outputType, is224) {
        return function(message) {
          return new Sha256(is224, true).update(message)[outputType]();
        };
      };
      var createMethod = function(is224) {
        var method = createOutputMethod("hex", is224);
        if (NODE_JS) {
          method = nodeWrap(method, is224);
        }
        method.create = function() {
          return new Sha256(is224);
        };
        method.update = function(message) {
          return method.create().update(message);
        };
        for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
          var type = OUTPUT_TYPES[i];
          method[type] = createOutputMethod(type, is224);
        }
        return method;
      };
      var nodeWrap = function(method, is224) {
        var crypto2 = require_crypto();
        var Buffer2 = require_buffer().Buffer;
        var algorithm = is224 ? "sha224" : "sha256";
        var bufferFrom;
        if (Buffer2.from && !root.JS_SHA256_NO_BUFFER_FROM) {
          bufferFrom = Buffer2.from;
        } else {
          bufferFrom = function(message) {
            return new Buffer2(message);
          };
        }
        var nodeMethod = function(message) {
          if (typeof message === "string") {
            return crypto2.createHash(algorithm).update(message, "utf8").digest("hex");
          } else {
            if (message === null || message === void 0) {
              throw new Error(ERROR);
            } else if (message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            }
          }
          if (Array.isArray(message) || ArrayBuffer.isView(message) || message.constructor === Buffer2) {
            return crypto2.createHash(algorithm).update(bufferFrom(message)).digest("hex");
          } else {
            return method(message);
          }
        };
        return nodeMethod;
      };
      var createHmacOutputMethod = function(outputType, is224) {
        return function(key, message) {
          return new HmacSha256(key, is224, true).update(message)[outputType]();
        };
      };
      var createHmacMethod = function(is224) {
        var method = createHmacOutputMethod("hex", is224);
        method.create = function(key) {
          return new HmacSha256(key, is224);
        };
        method.update = function(key, message) {
          return method.create(key).update(message);
        };
        for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
          var type = OUTPUT_TYPES[i];
          method[type] = createHmacOutputMethod(type, is224);
        }
        return method;
      };
      function Sha256(is224, sharedMemory) {
        if (sharedMemory) {
          blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
          this.blocks = blocks;
        } else {
          this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        }
        if (is224) {
          this.h0 = 3238371032;
          this.h1 = 914150663;
          this.h2 = 812702999;
          this.h3 = 4144912697;
          this.h4 = 4290775857;
          this.h5 = 1750603025;
          this.h6 = 1694076839;
          this.h7 = 3204075428;
        } else {
          this.h0 = 1779033703;
          this.h1 = 3144134277;
          this.h2 = 1013904242;
          this.h3 = 2773480762;
          this.h4 = 1359893119;
          this.h5 = 2600822924;
          this.h6 = 528734635;
          this.h7 = 1541459225;
        }
        this.block = this.start = this.bytes = this.hBytes = 0;
        this.finalized = this.hashed = false;
        this.first = true;
        this.is224 = is224;
      }
      Sha256.prototype.update = function(message) {
        if (this.finalized) {
          return;
        }
        var notString, type = typeof message;
        if (type !== "string") {
          if (type === "object") {
            if (message === null) {
              throw new Error(ERROR);
            } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            } else if (!Array.isArray(message)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                throw new Error(ERROR);
              }
            }
          } else {
            throw new Error(ERROR);
          }
          notString = true;
        }
        var code, index = 0, i, length = message.length, blocks2 = this.blocks;
        while (index < length) {
          if (this.hashed) {
            this.hashed = false;
            blocks2[0] = this.block;
            this.block = blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
          }
          if (notString) {
            for (i = this.start; index < length && i < 64; ++index) {
              blocks2[i >>> 2] |= message[index] << SHIFT[i++ & 3];
            }
          } else {
            for (i = this.start; index < length && i < 64; ++index) {
              code = message.charCodeAt(index);
              if (code < 128) {
                blocks2[i >>> 2] |= code << SHIFT[i++ & 3];
              } else if (code < 2048) {
                blocks2[i >>> 2] |= (192 | code >>> 6) << SHIFT[i++ & 3];
                blocks2[i >>> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
              } else if (code < 55296 || code >= 57344) {
                blocks2[i >>> 2] |= (224 | code >>> 12) << SHIFT[i++ & 3];
                blocks2[i >>> 2] |= (128 | code >>> 6 & 63) << SHIFT[i++ & 3];
                blocks2[i >>> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
              } else {
                code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                blocks2[i >>> 2] |= (240 | code >>> 18) << SHIFT[i++ & 3];
                blocks2[i >>> 2] |= (128 | code >>> 12 & 63) << SHIFT[i++ & 3];
                blocks2[i >>> 2] |= (128 | code >>> 6 & 63) << SHIFT[i++ & 3];
                blocks2[i >>> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
              }
            }
          }
          this.lastByteIndex = i;
          this.bytes += i - this.start;
          if (i >= 64) {
            this.block = blocks2[16];
            this.start = i - 64;
            this.hash();
            this.hashed = true;
          } else {
            this.start = i;
          }
        }
        if (this.bytes > 4294967295) {
          this.hBytes += this.bytes / 4294967296 << 0;
          this.bytes = this.bytes % 4294967296;
        }
        return this;
      };
      Sha256.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks2 = this.blocks, i = this.lastByteIndex;
        blocks2[16] = this.block;
        blocks2[i >>> 2] |= EXTRA[i & 3];
        this.block = blocks2[16];
        if (i >= 56) {
          if (!this.hashed) {
            this.hash();
          }
          blocks2[0] = this.block;
          blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
        }
        blocks2[14] = this.hBytes << 3 | this.bytes >>> 29;
        blocks2[15] = this.bytes << 3;
        this.hash();
      };
      Sha256.prototype.hash = function() {
        var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4, f = this.h5, g = this.h6, h = this.h7, blocks2 = this.blocks, j, s0, s1, maj, t1, t2, ch, ab, da, cd, bc;
        for (j = 16; j < 64; ++j) {
          t1 = blocks2[j - 15];
          s0 = (t1 >>> 7 | t1 << 25) ^ (t1 >>> 18 | t1 << 14) ^ t1 >>> 3;
          t1 = blocks2[j - 2];
          s1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
          blocks2[j] = blocks2[j - 16] + s0 + blocks2[j - 7] + s1 << 0;
        }
        bc = b & c;
        for (j = 0; j < 64; j += 4) {
          if (this.first) {
            if (this.is224) {
              ab = 300032;
              t1 = blocks2[0] - 1413257819;
              h = t1 - 150054599 << 0;
              d = t1 + 24177077 << 0;
            } else {
              ab = 704751109;
              t1 = blocks2[0] - 210244248;
              h = t1 - 1521486534 << 0;
              d = t1 + 143694565 << 0;
            }
            this.first = false;
          } else {
            s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
            s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
            ab = a & b;
            maj = ab ^ a & c ^ bc;
            ch = e & f ^ ~e & g;
            t1 = h + s1 + ch + K[j] + blocks2[j];
            t2 = s0 + maj;
            h = d + t1 << 0;
            d = t1 + t2 << 0;
          }
          s0 = (d >>> 2 | d << 30) ^ (d >>> 13 | d << 19) ^ (d >>> 22 | d << 10);
          s1 = (h >>> 6 | h << 26) ^ (h >>> 11 | h << 21) ^ (h >>> 25 | h << 7);
          da = d & a;
          maj = da ^ d & b ^ ab;
          ch = h & e ^ ~h & f;
          t1 = g + s1 + ch + K[j + 1] + blocks2[j + 1];
          t2 = s0 + maj;
          g = c + t1 << 0;
          c = t1 + t2 << 0;
          s0 = (c >>> 2 | c << 30) ^ (c >>> 13 | c << 19) ^ (c >>> 22 | c << 10);
          s1 = (g >>> 6 | g << 26) ^ (g >>> 11 | g << 21) ^ (g >>> 25 | g << 7);
          cd = c & d;
          maj = cd ^ c & a ^ da;
          ch = g & h ^ ~g & e;
          t1 = f + s1 + ch + K[j + 2] + blocks2[j + 2];
          t2 = s0 + maj;
          f = b + t1 << 0;
          b = t1 + t2 << 0;
          s0 = (b >>> 2 | b << 30) ^ (b >>> 13 | b << 19) ^ (b >>> 22 | b << 10);
          s1 = (f >>> 6 | f << 26) ^ (f >>> 11 | f << 21) ^ (f >>> 25 | f << 7);
          bc = b & c;
          maj = bc ^ b & d ^ cd;
          ch = f & g ^ ~f & h;
          t1 = e + s1 + ch + K[j + 3] + blocks2[j + 3];
          t2 = s0 + maj;
          e = a + t1 << 0;
          a = t1 + t2 << 0;
          this.chromeBugWorkAround = true;
        }
        this.h0 = this.h0 + a << 0;
        this.h1 = this.h1 + b << 0;
        this.h2 = this.h2 + c << 0;
        this.h3 = this.h3 + d << 0;
        this.h4 = this.h4 + e << 0;
        this.h5 = this.h5 + f << 0;
        this.h6 = this.h6 + g << 0;
        this.h7 = this.h7 + h << 0;
      };
      Sha256.prototype.hex = function() {
        this.finalize();
        var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
        var hex = HEX_CHARS[h0 >>> 28 & 15] + HEX_CHARS[h0 >>> 24 & 15] + HEX_CHARS[h0 >>> 20 & 15] + HEX_CHARS[h0 >>> 16 & 15] + HEX_CHARS[h0 >>> 12 & 15] + HEX_CHARS[h0 >>> 8 & 15] + HEX_CHARS[h0 >>> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h1 >>> 28 & 15] + HEX_CHARS[h1 >>> 24 & 15] + HEX_CHARS[h1 >>> 20 & 15] + HEX_CHARS[h1 >>> 16 & 15] + HEX_CHARS[h1 >>> 12 & 15] + HEX_CHARS[h1 >>> 8 & 15] + HEX_CHARS[h1 >>> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h2 >>> 28 & 15] + HEX_CHARS[h2 >>> 24 & 15] + HEX_CHARS[h2 >>> 20 & 15] + HEX_CHARS[h2 >>> 16 & 15] + HEX_CHARS[h2 >>> 12 & 15] + HEX_CHARS[h2 >>> 8 & 15] + HEX_CHARS[h2 >>> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h3 >>> 28 & 15] + HEX_CHARS[h3 >>> 24 & 15] + HEX_CHARS[h3 >>> 20 & 15] + HEX_CHARS[h3 >>> 16 & 15] + HEX_CHARS[h3 >>> 12 & 15] + HEX_CHARS[h3 >>> 8 & 15] + HEX_CHARS[h3 >>> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h4 >>> 28 & 15] + HEX_CHARS[h4 >>> 24 & 15] + HEX_CHARS[h4 >>> 20 & 15] + HEX_CHARS[h4 >>> 16 & 15] + HEX_CHARS[h4 >>> 12 & 15] + HEX_CHARS[h4 >>> 8 & 15] + HEX_CHARS[h4 >>> 4 & 15] + HEX_CHARS[h4 & 15] + HEX_CHARS[h5 >>> 28 & 15] + HEX_CHARS[h5 >>> 24 & 15] + HEX_CHARS[h5 >>> 20 & 15] + HEX_CHARS[h5 >>> 16 & 15] + HEX_CHARS[h5 >>> 12 & 15] + HEX_CHARS[h5 >>> 8 & 15] + HEX_CHARS[h5 >>> 4 & 15] + HEX_CHARS[h5 & 15] + HEX_CHARS[h6 >>> 28 & 15] + HEX_CHARS[h6 >>> 24 & 15] + HEX_CHARS[h6 >>> 20 & 15] + HEX_CHARS[h6 >>> 16 & 15] + HEX_CHARS[h6 >>> 12 & 15] + HEX_CHARS[h6 >>> 8 & 15] + HEX_CHARS[h6 >>> 4 & 15] + HEX_CHARS[h6 & 15];
        if (!this.is224) {
          hex += HEX_CHARS[h7 >>> 28 & 15] + HEX_CHARS[h7 >>> 24 & 15] + HEX_CHARS[h7 >>> 20 & 15] + HEX_CHARS[h7 >>> 16 & 15] + HEX_CHARS[h7 >>> 12 & 15] + HEX_CHARS[h7 >>> 8 & 15] + HEX_CHARS[h7 >>> 4 & 15] + HEX_CHARS[h7 & 15];
        }
        return hex;
      };
      Sha256.prototype.toString = Sha256.prototype.hex;
      Sha256.prototype.digest = function() {
        this.finalize();
        var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
        var arr = [
          h0 >>> 24 & 255,
          h0 >>> 16 & 255,
          h0 >>> 8 & 255,
          h0 & 255,
          h1 >>> 24 & 255,
          h1 >>> 16 & 255,
          h1 >>> 8 & 255,
          h1 & 255,
          h2 >>> 24 & 255,
          h2 >>> 16 & 255,
          h2 >>> 8 & 255,
          h2 & 255,
          h3 >>> 24 & 255,
          h3 >>> 16 & 255,
          h3 >>> 8 & 255,
          h3 & 255,
          h4 >>> 24 & 255,
          h4 >>> 16 & 255,
          h4 >>> 8 & 255,
          h4 & 255,
          h5 >>> 24 & 255,
          h5 >>> 16 & 255,
          h5 >>> 8 & 255,
          h5 & 255,
          h6 >>> 24 & 255,
          h6 >>> 16 & 255,
          h6 >>> 8 & 255,
          h6 & 255
        ];
        if (!this.is224) {
          arr.push(h7 >>> 24 & 255, h7 >>> 16 & 255, h7 >>> 8 & 255, h7 & 255);
        }
        return arr;
      };
      Sha256.prototype.array = Sha256.prototype.digest;
      Sha256.prototype.arrayBuffer = function() {
        this.finalize();
        var buffer = new ArrayBuffer(this.is224 ? 28 : 32);
        var dataView = new DataView(buffer);
        dataView.setUint32(0, this.h0);
        dataView.setUint32(4, this.h1);
        dataView.setUint32(8, this.h2);
        dataView.setUint32(12, this.h3);
        dataView.setUint32(16, this.h4);
        dataView.setUint32(20, this.h5);
        dataView.setUint32(24, this.h6);
        if (!this.is224) {
          dataView.setUint32(28, this.h7);
        }
        return buffer;
      };
      function HmacSha256(key, is224, sharedMemory) {
        var i, type = typeof key;
        if (type === "string") {
          var bytes = [], length = key.length, index = 0, code;
          for (i = 0; i < length; ++i) {
            code = key.charCodeAt(i);
            if (code < 128) {
              bytes[index++] = code;
            } else if (code < 2048) {
              bytes[index++] = 192 | code >>> 6;
              bytes[index++] = 128 | code & 63;
            } else if (code < 55296 || code >= 57344) {
              bytes[index++] = 224 | code >>> 12;
              bytes[index++] = 128 | code >>> 6 & 63;
              bytes[index++] = 128 | code & 63;
            } else {
              code = 65536 + ((code & 1023) << 10 | key.charCodeAt(++i) & 1023);
              bytes[index++] = 240 | code >>> 18;
              bytes[index++] = 128 | code >>> 12 & 63;
              bytes[index++] = 128 | code >>> 6 & 63;
              bytes[index++] = 128 | code & 63;
            }
          }
          key = bytes;
        } else {
          if (type === "object") {
            if (key === null) {
              throw new Error(ERROR);
            } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {
              key = new Uint8Array(key);
            } else if (!Array.isArray(key)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {
                throw new Error(ERROR);
              }
            }
          } else {
            throw new Error(ERROR);
          }
        }
        if (key.length > 64) {
          key = new Sha256(is224, true).update(key).array();
        }
        var oKeyPad = [], iKeyPad = [];
        for (i = 0; i < 64; ++i) {
          var b = key[i] || 0;
          oKeyPad[i] = 92 ^ b;
          iKeyPad[i] = 54 ^ b;
        }
        Sha256.call(this, is224, sharedMemory);
        this.update(iKeyPad);
        this.oKeyPad = oKeyPad;
        this.inner = true;
        this.sharedMemory = sharedMemory;
      }
      HmacSha256.prototype = new Sha256();
      HmacSha256.prototype.finalize = function() {
        Sha256.prototype.finalize.call(this);
        if (this.inner) {
          this.inner = false;
          var innerHash = this.array();
          Sha256.call(this, this.is224, this.sharedMemory);
          this.update(this.oKeyPad);
          this.update(innerHash);
          Sha256.prototype.finalize.call(this);
        }
      };
      var exports2 = createMethod();
      exports2.sha256 = exports2;
      exports2.sha224 = createMethod(true);
      exports2.sha256.hmac = createHmacMethod();
      exports2.sha224.hmac = createHmacMethod(true);
      if (COMMON_JS) {
        module.exports = exports2;
      } else {
        root.sha256 = exports2.sha256;
        root.sha224 = exports2.sha224;
        if (AMD) {
          define(function() {
            return exports2;
          });
        }
      }
    })();
  }
});

// node_modules/@devvai/devv-code-backend/dist/device.js
var require_device = __commonJS({
  "node_modules/@devvai/devv-code-backend/dist/device.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEncryptedDeviceId = getEncryptedDeviceId;
    exports.initializeDeviceId = initializeDeviceId;
    var js_sha256_1 = require_sha256();
    var DEVICE_ID_KEY = "DEVV_CODE_DEVICE_ID";
    function generateUUID() {
      if (typeof crypto !== "undefined" && crypto.randomUUID) {
        return crypto.randomUUID();
      }
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
        const r = Math.random() * 16 | 0;
        const v = c === "x" ? r : r & 3 | 8;
        return v.toString(16);
      });
    }
    function generateEncryptedDeviceId() {
      const uuid = generateUUID();
      const firstHash = (0, js_sha256_1.sha256)(uuid).slice(0, 32);
      const finalId = (0, js_sha256_1.sha256)(firstHash).slice(0, 8) + firstHash;
      return finalId;
    }
    function getEncryptedDeviceId() {
      if (typeof globalThis === "undefined" || typeof globalThis.localStorage === "undefined") {
        console.warn("localStorage not available, generating temporary device ID");
        return generateEncryptedDeviceId();
      }
      let deviceId = localStorage.getItem(DEVICE_ID_KEY);
      if (!deviceId) {
        deviceId = generateEncryptedDeviceId();
        localStorage.setItem(DEVICE_ID_KEY, deviceId);
      }
      return deviceId;
    }
    function initializeDeviceId() {
      getEncryptedDeviceId();
    }
  }
});

// node_modules/@devvai/devv-code-backend/dist/session.js
var require_session = __commonJS({
  "node_modules/@devvai/devv-code-backend/dist/session.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setSid = setSid;
    exports.getSid = getSid;
    exports.clearSid = clearSid;
    var DEVV_CODE_SID = "DEVV_CODE_SID";
    function setSid(sid) {
      if (typeof globalThis !== "undefined" && typeof globalThis.localStorage !== "undefined") {
        localStorage.setItem(DEVV_CODE_SID, sid);
      }
    }
    function getSid() {
      if (typeof globalThis !== "undefined" && typeof globalThis.localStorage !== "undefined") {
        return localStorage.getItem(DEVV_CODE_SID);
      }
      return null;
    }
    function clearSid() {
      if (typeof globalThis !== "undefined" && typeof globalThis.localStorage !== "undefined") {
        localStorage.removeItem(DEVV_CODE_SID);
      }
    }
  }
});

// node_modules/@devvai/devv-code-backend/package.json
var require_package = __commonJS({
  "node_modules/@devvai/devv-code-backend/package.json"(exports, module) {
    module.exports = {
      name: "@devvai/devv-code-backend",
      version: "1.22.0",
      description: "Backend SDK for Devv Code - Provides authentication, data management, email and AI capabilities",
      main: "dist/index.js",
      types: "dist/index.d.ts",
      files: [
        "dist"
      ],
      scripts: {
        build: "tsc",
        prepublishOnly: "npm run build"
      },
      keywords: [
        "devv",
        "devv-code",
        "backend",
        "sdk",
        "auth",
        "database",
        "email",
        "ai"
      ],
      repository: {
        type: "git",
        url: "https://github.com/index-labs/devv-code-backend-sdk.git"
      },
      author: "Devv",
      license: "MIT",
      devDependencies: {
        "@types/node": "^24.0.12",
        typescript: "^5.3.2"
      },
      dependencies: {
        "js-sha256": "^0.11.1",
        openai: "^5.10.2"
      }
    };
  }
});

// node_modules/@devvai/devv-code-backend/dist/constants.js
var require_constants = __commonJS({
  "node_modules/@devvai/devv-code-backend/dist/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BASE_URL = void 0;
    var package_json_1 = require_package();
    exports.BASE_URL = package_json_1.version.includes("dev") ? "https://api-dev.copilothub.ai/" : "https://api.devv.ai/";
  }
});

// node_modules/@devvai/devv-code-backend/dist/auth.js
var require_auth = __commonJS({
  "node_modules/@devvai/devv-code-backend/dist/auth.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DevvAuth = void 0;
    var device_1 = require_device();
    var session_1 = require_session();
    var constants_1 = require_constants();
    var DevvAuth = class {
      async sendOTP(email) {
        const deviceId = (0, device_1.getEncryptedDeviceId)();
        const response = await fetch(`${constants_1.BASE_URL}api/v1/project-auth/send-verification-email`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Device-Id": deviceId
          },
          body: JSON.stringify({ email })
        });
        if (!response.ok) {
          const error = await response.json().catch(() => ({ error: "Send OTP failed" }));
          throw new Error(error.error || `Failed to send OTP (Status: ${response.status})`);
        }
      }
      async verifyOTP(email, verificationCode) {
        const deviceId = (0, device_1.getEncryptedDeviceId)();
        const response = await fetch(`${constants_1.BASE_URL}api/v1/project-auth/login`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Device-Id": deviceId
          },
          body: JSON.stringify({
            authType: 8,
            email,
            verificationCode
          })
        });
        if (!response.ok) {
          const error = await response.json().catch(() => ({ error: "Login failed" }));
          throw new Error(error.error || `Invalid verification code (Status: ${response.status})`);
        }
        const data = await response.json();
        if (data.sid) {
          (0, session_1.setSid)(data.sid);
        }
        return data;
      }
      async logout() {
        const deviceId = (0, device_1.getEncryptedDeviceId)();
        const sid = (0, session_1.getSid)();
        const headers = {
          "Content-Type": "application/json",
          "Device-Id": deviceId
        };
        if (sid) {
          headers["sid"] = sid;
        }
        const response = await fetch(`${constants_1.BASE_URL}api/v1/project-auth/logout`, {
          method: "POST",
          headers
        });
        if (!response.ok) {
          const error = await response.json().catch(() => ({ error: "Logout failed" }));
          throw new Error(error.error || `Logout failed (Status: ${response.status})`);
        }
        (0, session_1.clearSid)();
      }
    };
    exports.DevvAuth = DevvAuth;
  }
});

// node_modules/@devvai/devv-code-backend/dist/table.js
var require_table = __commonJS({
  "node_modules/@devvai/devv-code-backend/dist/table.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProjectTable = void 0;
    var device_1 = require_device();
    var session_1 = require_session();
    var constants_1 = require_constants();
    var ProjectTable = class {
      async addItem(tableId, data) {
        const deviceId = (0, device_1.getEncryptedDeviceId)();
        const sid = (0, session_1.getSid)();
        const headers = {
          "Content-Type": "application/json",
          "Device-Id": deviceId
        };
        if (sid) {
          headers["sid"] = sid;
        }
        const response = await fetch(`${constants_1.BASE_URL}api/v1/project-tables/${tableId}/items`, {
          method: "POST",
          headers,
          body: JSON.stringify(data)
        });
        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || "Failed to add item");
        }
      }
      async getItems(tableId, options) {
        const queryParams = new URLSearchParams();
        if (options == null ? void 0 : options.limit) {
          queryParams.append("_limit", Math.min(options.limit, 100).toString());
        }
        if (options == null ? void 0 : options.cursor) {
          queryParams.append("_cursor", options.cursor);
        }
        if (options == null ? void 0 : options.sort) {
          queryParams.append("_sort", options.sort);
        }
        if (options == null ? void 0 : options.order) {
          queryParams.append("_order", options.order);
        }
        if (options == null ? void 0 : options.query) {
          Object.entries(options.query).forEach(([field, condition]) => {
            if (typeof condition === "object" && "operator" in condition) {
              const { operator, value } = condition;
              if (operator === "BETWEEN" && Array.isArray(value)) {
                queryParams.append(field, `BETWEEN:${value[0]},${value[1]}`);
              } else {
                queryParams.append(field, `${operator}:${value}`);
              }
            } else {
              queryParams.append(field, String(condition));
            }
          });
        }
        const url = `${constants_1.BASE_URL}api/v1/project-tables/${tableId}/items${queryParams.toString() ? "?" + queryParams.toString() : ""}`;
        const deviceId = (0, device_1.getEncryptedDeviceId)();
        const sid = (0, session_1.getSid)();
        const headers = {
          "Content-Type": "application/json",
          "Device-Id": deviceId
        };
        if (sid) {
          headers["sid"] = sid;
        }
        const response = await fetch(url, {
          method: "GET",
          headers
        });
        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || "Failed to get items");
        }
        return await response.json();
      }
      async updateItem(tableId, data) {
        const deviceId = (0, device_1.getEncryptedDeviceId)();
        const sid = (0, session_1.getSid)();
        const headers = {
          "Content-Type": "application/json",
          "Device-Id": deviceId
        };
        if (sid) {
          headers["sid"] = sid;
        }
        const response = await fetch(`${constants_1.BASE_URL}api/v1/project-tables/${tableId}/items`, {
          method: "PUT",
          headers,
          body: JSON.stringify(data)
        });
        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || "Failed to update item");
        }
      }
      async deleteItem(tableId, keys) {
        const deviceId = (0, device_1.getEncryptedDeviceId)();
        const sid = (0, session_1.getSid)();
        const headers = {
          "Content-Type": "application/json",
          "Device-Id": deviceId
        };
        if (sid) {
          headers["sid"] = sid;
        }
        const response = await fetch(`${constants_1.BASE_URL}api/v1/project-tables/${tableId}/items`, {
          method: "DELETE",
          headers,
          body: JSON.stringify(keys)
        });
        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || "Failed to delete item");
        }
      }
    };
    exports.ProjectTable = ProjectTable;
  }
});

// node_modules/@devvai/devv-code-backend/dist/upload.js
var require_upload = __commonJS({
  "node_modules/@devvai/devv-code-backend/dist/upload.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FileUpload = void 0;
    var device_1 = require_device();
    var session_1 = require_session();
    var constants_1 = require_constants();
    var FileUpload = class {
      async uploadFile(file) {
        const endpoint = `${constants_1.BASE_URL}api/v1/upload-file`;
        const deviceId = (0, device_1.getEncryptedDeviceId)();
        const sid = (0, session_1.getSid)();
        const formData = new FormData();
        formData.append("file", file);
        const headers = {
          "Device-Id": deviceId
        };
        if (sid) {
          headers["sid"] = sid;
        }
        try {
          const response = await fetch(endpoint, {
            method: "POST",
            headers,
            body: formData,
            credentials: "include"
          });
          const data = await response.json();
          if (!response.ok) {
            const errorData = data;
            if (errorData && typeof errorData === "object" && "errCode" in errorData && "errMsg" in errorData) {
              throw new Error(errorData.errMsg);
            }
            throw new Error(`Upload failed with status ${response.status}`);
          }
          return data;
        } catch (error) {
          if (error instanceof Error) {
            throw error;
          }
          throw new Error("Failed to upload file");
        }
      }
      isErrorResponse(response) {
        return "errCode" in response && "errMsg" in response;
      }
    };
    exports.FileUpload = FileUpload;
  }
});

// node_modules/@devvai/devv-code-backend/dist/email.js
var require_email = __commonJS({
  "node_modules/@devvai/devv-code-backend/dist/email.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DevvEmail = void 0;
    var device_1 = require_device();
    var session_1 = require_session();
    var constants_1 = require_constants();
    var DevvEmail = class {
      async sendEmail(options) {
        var _a;
        if (!options.from || !options.to || options.to.length === 0 || !options.subject) {
          throw new Error("Missing required fields: from, to, and subject are required");
        }
        if (!options.html && !options.text) {
          throw new Error("Either html or text content must be provided");
        }
        const deviceId = (0, device_1.getEncryptedDeviceId)();
        const sid = (0, session_1.getSid)();
        const headers = {
          "Content-Type": "application/json",
          "Device-Id": deviceId
        };
        if (sid) {
          headers["sid"] = sid;
        }
        const response = await fetch(`${constants_1.BASE_URL}api/v1/email/send`, {
          method: "POST",
          headers,
          body: JSON.stringify(options)
        });
        if (!response.ok) {
          const error = await response.json().catch(() => ({ error: { message: "Failed to send email" } }));
          throw new Error(((_a = error.error) == null ? void 0 : _a.message) || `Failed to send email (Status: ${response.status})`);
        }
        return await response.json();
      }
    };
    exports.DevvEmail = DevvEmail;
  }
});

// node_modules/openai/internal/tslib.js
var require_tslib = __commonJS({
  "node_modules/openai/internal/tslib.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.__setModuleDefault = exports.__createBinding = void 0;
    exports.__classPrivateFieldSet = __classPrivateFieldSet;
    exports.__classPrivateFieldGet = __classPrivateFieldGet;
    exports.__exportStar = __exportStar;
    exports.__importStar = __importStar;
    function __classPrivateFieldSet(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    }
    function __classPrivateFieldGet(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }
    var __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
          enumerable: true,
          get: function() {
            return m[k];
          }
        };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    };
    exports.__createBinding = __createBinding;
    function __exportStar(m, o) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
          __createBinding(o, m, p);
    }
    var __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    };
    exports.__setModuleDefault = __setModuleDefault;
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    function __importStar(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0; i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      __setModuleDefault(result, mod);
      return result;
    }
  }
});

// node_modules/openai/internal/utils/uuid.js
var require_uuid = __commonJS({
  "node_modules/openai/internal/utils/uuid.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uuid4 = void 0;
    var uuid4 = function() {
      const { crypto: crypto2 } = globalThis;
      if (crypto2 == null ? void 0 : crypto2.randomUUID) {
        exports.uuid4 = crypto2.randomUUID.bind(crypto2);
        return crypto2.randomUUID();
      }
      const u8 = new Uint8Array(1);
      const randomByte = crypto2 ? () => crypto2.getRandomValues(u8)[0] : () => Math.random() * 255 & 255;
      return "10000000-1000-4000-8000-100000000000".replace(/[018]/g, (c) => (+c ^ randomByte() & 15 >> +c / 4).toString(16));
    };
    exports.uuid4 = uuid4;
  }
});

// node_modules/openai/internal/errors.js
var require_errors = __commonJS({
  "node_modules/openai/internal/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.castToError = void 0;
    exports.isAbortError = isAbortError;
    function isAbortError(err) {
      return typeof err === "object" && err !== null && // Spec-compliant fetch implementations
      ("name" in err && err.name === "AbortError" || // Expo fetch
      "message" in err && String(err.message).includes("FetchRequestCanceledException"));
    }
    var castToError = (err) => {
      if (err instanceof Error)
        return err;
      if (typeof err === "object" && err !== null) {
        try {
          if (Object.prototype.toString.call(err) === "[object Error]") {
            const error = new Error(err.message, err.cause ? { cause: err.cause } : {});
            if (err.stack)
              error.stack = err.stack;
            if (err.cause && !error.cause)
              error.cause = err.cause;
            if (err.name)
              error.name = err.name;
            return error;
          }
        } catch {
        }
        try {
          return new Error(JSON.stringify(err));
        } catch {
        }
      }
      return new Error(err);
    };
    exports.castToError = castToError;
  }
});

// node_modules/openai/core/error.js
var require_error = __commonJS({
  "node_modules/openai/core/error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InvalidWebhookSignatureError = exports.ContentFilterFinishReasonError = exports.LengthFinishReasonError = exports.InternalServerError = exports.RateLimitError = exports.UnprocessableEntityError = exports.ConflictError = exports.NotFoundError = exports.PermissionDeniedError = exports.AuthenticationError = exports.BadRequestError = exports.APIConnectionTimeoutError = exports.APIConnectionError = exports.APIUserAbortError = exports.APIError = exports.OpenAIError = void 0;
    var errors_1 = require_errors();
    var OpenAIError = class extends Error {
    };
    exports.OpenAIError = OpenAIError;
    var APIError = class _APIError extends OpenAIError {
      constructor(status, error, message, headers) {
        super(`${_APIError.makeMessage(status, error, message)}`);
        this.status = status;
        this.headers = headers;
        this.requestID = headers == null ? void 0 : headers.get("x-request-id");
        this.error = error;
        const data = error;
        this.code = data == null ? void 0 : data["code"];
        this.param = data == null ? void 0 : data["param"];
        this.type = data == null ? void 0 : data["type"];
      }
      static makeMessage(status, error, message) {
        const msg = (error == null ? void 0 : error.message) ? typeof error.message === "string" ? error.message : JSON.stringify(error.message) : error ? JSON.stringify(error) : message;
        if (status && msg) {
          return `${status} ${msg}`;
        }
        if (status) {
          return `${status} status code (no body)`;
        }
        if (msg) {
          return msg;
        }
        return "(no status code or body)";
      }
      static generate(status, errorResponse, message, headers) {
        if (!status || !headers) {
          return new APIConnectionError({ message, cause: (0, errors_1.castToError)(errorResponse) });
        }
        const error = errorResponse == null ? void 0 : errorResponse["error"];
        if (status === 400) {
          return new BadRequestError(status, error, message, headers);
        }
        if (status === 401) {
          return new AuthenticationError(status, error, message, headers);
        }
        if (status === 403) {
          return new PermissionDeniedError(status, error, message, headers);
        }
        if (status === 404) {
          return new NotFoundError(status, error, message, headers);
        }
        if (status === 409) {
          return new ConflictError(status, error, message, headers);
        }
        if (status === 422) {
          return new UnprocessableEntityError(status, error, message, headers);
        }
        if (status === 429) {
          return new RateLimitError(status, error, message, headers);
        }
        if (status >= 500) {
          return new InternalServerError(status, error, message, headers);
        }
        return new _APIError(status, error, message, headers);
      }
    };
    exports.APIError = APIError;
    var APIUserAbortError = class extends APIError {
      constructor({ message } = {}) {
        super(void 0, void 0, message || "Request was aborted.", void 0);
      }
    };
    exports.APIUserAbortError = APIUserAbortError;
    var APIConnectionError = class extends APIError {
      constructor({ message, cause }) {
        super(void 0, void 0, message || "Connection error.", void 0);
        if (cause)
          this.cause = cause;
      }
    };
    exports.APIConnectionError = APIConnectionError;
    var APIConnectionTimeoutError = class extends APIConnectionError {
      constructor({ message } = {}) {
        super({ message: message ?? "Request timed out." });
      }
    };
    exports.APIConnectionTimeoutError = APIConnectionTimeoutError;
    var BadRequestError = class extends APIError {
    };
    exports.BadRequestError = BadRequestError;
    var AuthenticationError = class extends APIError {
    };
    exports.AuthenticationError = AuthenticationError;
    var PermissionDeniedError = class extends APIError {
    };
    exports.PermissionDeniedError = PermissionDeniedError;
    var NotFoundError = class extends APIError {
    };
    exports.NotFoundError = NotFoundError;
    var ConflictError = class extends APIError {
    };
    exports.ConflictError = ConflictError;
    var UnprocessableEntityError = class extends APIError {
    };
    exports.UnprocessableEntityError = UnprocessableEntityError;
    var RateLimitError = class extends APIError {
    };
    exports.RateLimitError = RateLimitError;
    var InternalServerError = class extends APIError {
    };
    exports.InternalServerError = InternalServerError;
    var LengthFinishReasonError = class extends OpenAIError {
      constructor() {
        super(`Could not parse response content as the length limit was reached`);
      }
    };
    exports.LengthFinishReasonError = LengthFinishReasonError;
    var ContentFilterFinishReasonError = class extends OpenAIError {
      constructor() {
        super(`Could not parse response content as the request was rejected by the content filter`);
      }
    };
    exports.ContentFilterFinishReasonError = ContentFilterFinishReasonError;
    var InvalidWebhookSignatureError = class extends Error {
      constructor(message) {
        super(message);
      }
    };
    exports.InvalidWebhookSignatureError = InvalidWebhookSignatureError;
  }
});

// node_modules/openai/internal/utils/values.js
var require_values = __commonJS({
  "node_modules/openai/internal/utils/values.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.safeJSON = exports.maybeCoerceBoolean = exports.maybeCoerceFloat = exports.maybeCoerceInteger = exports.coerceBoolean = exports.coerceFloat = exports.coerceInteger = exports.validatePositiveInteger = exports.ensurePresent = exports.isReadonlyArray = exports.isArray = exports.isAbsoluteURL = void 0;
    exports.maybeObj = maybeObj;
    exports.isEmptyObj = isEmptyObj;
    exports.hasOwn = hasOwn;
    exports.isObj = isObj;
    var error_1 = require_error();
    var startsWithSchemeRegexp = /^[a-z][a-z0-9+.-]*:/i;
    var isAbsoluteURL = (url) => {
      return startsWithSchemeRegexp.test(url);
    };
    exports.isAbsoluteURL = isAbsoluteURL;
    var isArray = (val) => (exports.isArray = Array.isArray, (0, exports.isArray)(val));
    exports.isArray = isArray;
    exports.isReadonlyArray = exports.isArray;
    function maybeObj(x) {
      if (typeof x !== "object") {
        return {};
      }
      return x ?? {};
    }
    function isEmptyObj(obj) {
      if (!obj)
        return true;
      for (const _k in obj)
        return false;
      return true;
    }
    function hasOwn(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    function isObj(obj) {
      return obj != null && typeof obj === "object" && !Array.isArray(obj);
    }
    var ensurePresent = (value) => {
      if (value == null) {
        throw new error_1.OpenAIError(`Expected a value to be given but received ${value} instead.`);
      }
      return value;
    };
    exports.ensurePresent = ensurePresent;
    var validatePositiveInteger = (name, n) => {
      if (typeof n !== "number" || !Number.isInteger(n)) {
        throw new error_1.OpenAIError(`${name} must be an integer`);
      }
      if (n < 0) {
        throw new error_1.OpenAIError(`${name} must be a positive integer`);
      }
      return n;
    };
    exports.validatePositiveInteger = validatePositiveInteger;
    var coerceInteger = (value) => {
      if (typeof value === "number")
        return Math.round(value);
      if (typeof value === "string")
        return parseInt(value, 10);
      throw new error_1.OpenAIError(`Could not coerce ${value} (type: ${typeof value}) into a number`);
    };
    exports.coerceInteger = coerceInteger;
    var coerceFloat = (value) => {
      if (typeof value === "number")
        return value;
      if (typeof value === "string")
        return parseFloat(value);
      throw new error_1.OpenAIError(`Could not coerce ${value} (type: ${typeof value}) into a number`);
    };
    exports.coerceFloat = coerceFloat;
    var coerceBoolean = (value) => {
      if (typeof value === "boolean")
        return value;
      if (typeof value === "string")
        return value === "true";
      return Boolean(value);
    };
    exports.coerceBoolean = coerceBoolean;
    var maybeCoerceInteger = (value) => {
      if (value === void 0) {
        return void 0;
      }
      return (0, exports.coerceInteger)(value);
    };
    exports.maybeCoerceInteger = maybeCoerceInteger;
    var maybeCoerceFloat = (value) => {
      if (value === void 0) {
        return void 0;
      }
      return (0, exports.coerceFloat)(value);
    };
    exports.maybeCoerceFloat = maybeCoerceFloat;
    var maybeCoerceBoolean = (value) => {
      if (value === void 0) {
        return void 0;
      }
      return (0, exports.coerceBoolean)(value);
    };
    exports.maybeCoerceBoolean = maybeCoerceBoolean;
    var safeJSON = (text) => {
      try {
        return JSON.parse(text);
      } catch (err) {
        return void 0;
      }
    };
    exports.safeJSON = safeJSON;
  }
});

// node_modules/openai/internal/utils/sleep.js
var require_sleep = __commonJS({
  "node_modules/openai/internal/utils/sleep.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sleep = void 0;
    var sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
    exports.sleep = sleep;
  }
});

// node_modules/openai/version.js
var require_version = __commonJS({
  "node_modules/openai/version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VERSION = void 0;
    exports.VERSION = "5.19.1";
  }
});

// node_modules/openai/internal/detect-platform.js
var require_detect_platform = __commonJS({
  "node_modules/openai/internal/detect-platform.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getPlatformHeaders = exports.isRunningInBrowser = void 0;
    var version_1 = require_version();
    var isRunningInBrowser = () => {
      return (
        // @ts-ignore
        typeof window !== "undefined" && // @ts-ignore
        typeof window.document !== "undefined" && // @ts-ignore
        typeof navigator !== "undefined"
      );
    };
    exports.isRunningInBrowser = isRunningInBrowser;
    function getDetectedPlatform() {
      if (typeof Deno !== "undefined" && Deno.build != null) {
        return "deno";
      }
      if (typeof EdgeRuntime !== "undefined") {
        return "edge";
      }
      if (Object.prototype.toString.call(typeof globalThis.process !== "undefined" ? globalThis.process : 0) === "[object process]") {
        return "node";
      }
      return "unknown";
    }
    var getPlatformProperties = () => {
      var _a;
      const detectedPlatform = getDetectedPlatform();
      if (detectedPlatform === "deno") {
        return {
          "X-Stainless-Lang": "js",
          "X-Stainless-Package-Version": version_1.VERSION,
          "X-Stainless-OS": normalizePlatform(Deno.build.os),
          "X-Stainless-Arch": normalizeArch(Deno.build.arch),
          "X-Stainless-Runtime": "deno",
          "X-Stainless-Runtime-Version": typeof Deno.version === "string" ? Deno.version : ((_a = Deno.version) == null ? void 0 : _a.deno) ?? "unknown"
        };
      }
      if (typeof EdgeRuntime !== "undefined") {
        return {
          "X-Stainless-Lang": "js",
          "X-Stainless-Package-Version": version_1.VERSION,
          "X-Stainless-OS": "Unknown",
          "X-Stainless-Arch": `other:${EdgeRuntime}`,
          "X-Stainless-Runtime": "edge",
          "X-Stainless-Runtime-Version": globalThis.process.version
        };
      }
      if (detectedPlatform === "node") {
        return {
          "X-Stainless-Lang": "js",
          "X-Stainless-Package-Version": version_1.VERSION,
          "X-Stainless-OS": normalizePlatform(globalThis.process.platform ?? "unknown"),
          "X-Stainless-Arch": normalizeArch(globalThis.process.arch ?? "unknown"),
          "X-Stainless-Runtime": "node",
          "X-Stainless-Runtime-Version": globalThis.process.version ?? "unknown"
        };
      }
      const browserInfo = getBrowserInfo();
      if (browserInfo) {
        return {
          "X-Stainless-Lang": "js",
          "X-Stainless-Package-Version": version_1.VERSION,
          "X-Stainless-OS": "Unknown",
          "X-Stainless-Arch": "unknown",
          "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
          "X-Stainless-Runtime-Version": browserInfo.version
        };
      }
      return {
        "X-Stainless-Lang": "js",
        "X-Stainless-Package-Version": version_1.VERSION,
        "X-Stainless-OS": "Unknown",
        "X-Stainless-Arch": "unknown",
        "X-Stainless-Runtime": "unknown",
        "X-Stainless-Runtime-Version": "unknown"
      };
    };
    function getBrowserInfo() {
      if (typeof navigator === "undefined" || !navigator) {
        return null;
      }
      const browserPatterns = [
        { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
        { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
        { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
        { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
        { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
        { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
      ];
      for (const { key, pattern } of browserPatterns) {
        const match = pattern.exec(navigator.userAgent);
        if (match) {
          const major = match[1] || 0;
          const minor = match[2] || 0;
          const patch = match[3] || 0;
          return { browser: key, version: `${major}.${minor}.${patch}` };
        }
      }
      return null;
    }
    var normalizeArch = (arch) => {
      if (arch === "x32")
        return "x32";
      if (arch === "x86_64" || arch === "x64")
        return "x64";
      if (arch === "arm")
        return "arm";
      if (arch === "aarch64" || arch === "arm64")
        return "arm64";
      if (arch)
        return `other:${arch}`;
      return "unknown";
    };
    var normalizePlatform = (platform) => {
      platform = platform.toLowerCase();
      if (platform.includes("ios"))
        return "iOS";
      if (platform === "android")
        return "Android";
      if (platform === "darwin")
        return "MacOS";
      if (platform === "win32")
        return "Windows";
      if (platform === "freebsd")
        return "FreeBSD";
      if (platform === "openbsd")
        return "OpenBSD";
      if (platform === "linux")
        return "Linux";
      if (platform)
        return `Other:${platform}`;
      return "Unknown";
    };
    var _platformHeaders;
    var getPlatformHeaders = () => {
      return _platformHeaders ?? (_platformHeaders = getPlatformProperties());
    };
    exports.getPlatformHeaders = getPlatformHeaders;
  }
});

// node_modules/openai/internal/shims.js
var require_shims = __commonJS({
  "node_modules/openai/internal/shims.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getDefaultFetch = getDefaultFetch;
    exports.makeReadableStream = makeReadableStream;
    exports.ReadableStreamFrom = ReadableStreamFrom;
    exports.ReadableStreamToAsyncIterable = ReadableStreamToAsyncIterable;
    exports.CancelReadableStream = CancelReadableStream;
    function getDefaultFetch() {
      if (typeof fetch !== "undefined") {
        return fetch;
      }
      throw new Error("`fetch` is not defined as a global; Either pass `fetch` to the client, `new OpenAI({ fetch })` or polyfill the global, `globalThis.fetch = fetch`");
    }
    function makeReadableStream(...args) {
      const ReadableStream = globalThis.ReadableStream;
      if (typeof ReadableStream === "undefined") {
        throw new Error("`ReadableStream` is not defined as a global; You will need to polyfill it, `globalThis.ReadableStream = ReadableStream`");
      }
      return new ReadableStream(...args);
    }
    function ReadableStreamFrom(iterable) {
      let iter = Symbol.asyncIterator in iterable ? iterable[Symbol.asyncIterator]() : iterable[Symbol.iterator]();
      return makeReadableStream({
        start() {
        },
        async pull(controller) {
          const { done, value } = await iter.next();
          if (done) {
            controller.close();
          } else {
            controller.enqueue(value);
          }
        },
        async cancel() {
          var _a;
          await ((_a = iter.return) == null ? void 0 : _a.call(iter));
        }
      });
    }
    function ReadableStreamToAsyncIterable(stream) {
      if (stream[Symbol.asyncIterator])
        return stream;
      const reader = stream.getReader();
      return {
        async next() {
          try {
            const result = await reader.read();
            if (result == null ? void 0 : result.done)
              reader.releaseLock();
            return result;
          } catch (e) {
            reader.releaseLock();
            throw e;
          }
        },
        async return() {
          const cancelPromise = reader.cancel();
          reader.releaseLock();
          await cancelPromise;
          return { done: true, value: void 0 };
        },
        [Symbol.asyncIterator]() {
          return this;
        }
      };
    }
    async function CancelReadableStream(stream) {
      var _a, _b;
      if (stream === null || typeof stream !== "object")
        return;
      if (stream[Symbol.asyncIterator]) {
        await ((_b = (_a = stream[Symbol.asyncIterator]()).return) == null ? void 0 : _b.call(_a));
        return;
      }
      const reader = stream.getReader();
      const cancelPromise = reader.cancel();
      reader.releaseLock();
      await cancelPromise;
    }
  }
});

// node_modules/openai/internal/request-options.js
var require_request_options = __commonJS({
  "node_modules/openai/internal/request-options.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FallbackEncoder = void 0;
    var FallbackEncoder = ({ headers, body }) => {
      return {
        bodyHeaders: {
          "content-type": "application/json"
        },
        body: JSON.stringify(body)
      };
    };
    exports.FallbackEncoder = FallbackEncoder;
  }
});

// node_modules/openai/internal/qs/formats.js
var require_formats = __commonJS({
  "node_modules/openai/internal/qs/formats.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RFC3986 = exports.RFC1738 = exports.formatters = exports.default_formatter = exports.default_format = void 0;
    exports.default_format = "RFC3986";
    var default_formatter = (v) => String(v);
    exports.default_formatter = default_formatter;
    exports.formatters = {
      RFC1738: (v) => String(v).replace(/%20/g, "+"),
      RFC3986: exports.default_formatter
    };
    exports.RFC1738 = "RFC1738";
    exports.RFC3986 = "RFC3986";
  }
});

// node_modules/openai/internal/qs/utils.js
var require_utils = __commonJS({
  "node_modules/openai/internal/qs/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encode = exports.has = void 0;
    exports.merge = merge;
    exports.assign_single_source = assign_single_source;
    exports.decode = decode;
    exports.compact = compact;
    exports.is_regexp = is_regexp;
    exports.is_buffer = is_buffer;
    exports.combine = combine;
    exports.maybe_map = maybe_map;
    var formats_1 = require_formats();
    var values_1 = require_values();
    var has = (obj, key) => (exports.has = Object.hasOwn ?? Function.prototype.call.bind(Object.prototype.hasOwnProperty), (0, exports.has)(obj, key));
    exports.has = has;
    var hex_table = (() => {
      const array = [];
      for (let i = 0; i < 256; ++i) {
        array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
      }
      return array;
    })();
    function compact_queue(queue) {
      while (queue.length > 1) {
        const item = queue.pop();
        if (!item)
          continue;
        const obj = item.obj[item.prop];
        if ((0, values_1.isArray)(obj)) {
          const compacted = [];
          for (let j = 0; j < obj.length; ++j) {
            if (typeof obj[j] !== "undefined") {
              compacted.push(obj[j]);
            }
          }
          item.obj[item.prop] = compacted;
        }
      }
    }
    function array_to_object(source, options) {
      const obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      for (let i = 0; i < source.length; ++i) {
        if (typeof source[i] !== "undefined") {
          obj[i] = source[i];
        }
      }
      return obj;
    }
    function merge(target, source, options = {}) {
      if (!source) {
        return target;
      }
      if (typeof source !== "object") {
        if ((0, values_1.isArray)(target)) {
          target.push(source);
        } else if (target && typeof target === "object") {
          if (options && (options.plainObjects || options.allowPrototypes) || !(0, exports.has)(Object.prototype, source)) {
            target[source] = true;
          }
        } else {
          return [target, source];
        }
        return target;
      }
      if (!target || typeof target !== "object") {
        return [target].concat(source);
      }
      let mergeTarget = target;
      if ((0, values_1.isArray)(target) && !(0, values_1.isArray)(source)) {
        mergeTarget = array_to_object(target, options);
      }
      if ((0, values_1.isArray)(target) && (0, values_1.isArray)(source)) {
        source.forEach(function(item, i) {
          if ((0, exports.has)(target, i)) {
            const targetItem = target[i];
            if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
              target[i] = merge(targetItem, item, options);
            } else {
              target.push(item);
            }
          } else {
            target[i] = item;
          }
        });
        return target;
      }
      return Object.keys(source).reduce(function(acc, key) {
        const value = source[key];
        if ((0, exports.has)(acc, key)) {
          acc[key] = merge(acc[key], value, options);
        } else {
          acc[key] = value;
        }
        return acc;
      }, mergeTarget);
    }
    function assign_single_source(target, source) {
      return Object.keys(source).reduce(function(acc, key) {
        acc[key] = source[key];
        return acc;
      }, target);
    }
    function decode(str, _, charset) {
      const strWithoutPlus = str.replace(/\+/g, " ");
      if (charset === "iso-8859-1") {
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
      }
      try {
        return decodeURIComponent(strWithoutPlus);
      } catch (e) {
        return strWithoutPlus;
      }
    }
    var limit = 1024;
    var encode = (str, _defaultEncoder, charset, _kind, format) => {
      if (str.length === 0) {
        return str;
      }
      let string = str;
      if (typeof str === "symbol") {
        string = Symbol.prototype.toString.call(str);
      } else if (typeof str !== "string") {
        string = String(str);
      }
      if (charset === "iso-8859-1") {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
          return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
        });
      }
      let out = "";
      for (let j = 0; j < string.length; j += limit) {
        const segment = string.length >= limit ? string.slice(j, j + limit) : string;
        const arr = [];
        for (let i = 0; i < segment.length; ++i) {
          let c = segment.charCodeAt(i);
          if (c === 45 || // -
          c === 46 || // .
          c === 95 || // _
          c === 126 || // ~
          c >= 48 && c <= 57 || // 0-9
          c >= 65 && c <= 90 || // a-z
          c >= 97 && c <= 122 || // A-Z
          format === formats_1.RFC1738 && (c === 40 || c === 41)) {
            arr[arr.length] = segment.charAt(i);
            continue;
          }
          if (c < 128) {
            arr[arr.length] = hex_table[c];
            continue;
          }
          if (c < 2048) {
            arr[arr.length] = hex_table[192 | c >> 6] + hex_table[128 | c & 63];
            continue;
          }
          if (c < 55296 || c >= 57344) {
            arr[arr.length] = hex_table[224 | c >> 12] + hex_table[128 | c >> 6 & 63] + hex_table[128 | c & 63];
            continue;
          }
          i += 1;
          c = 65536 + ((c & 1023) << 10 | segment.charCodeAt(i) & 1023);
          arr[arr.length] = hex_table[240 | c >> 18] + hex_table[128 | c >> 12 & 63] + hex_table[128 | c >> 6 & 63] + hex_table[128 | c & 63];
        }
        out += arr.join("");
      }
      return out;
    };
    exports.encode = encode;
    function compact(value) {
      const queue = [{ obj: { o: value }, prop: "o" }];
      const refs = [];
      for (let i = 0; i < queue.length; ++i) {
        const item = queue[i];
        const obj = item.obj[item.prop];
        const keys = Object.keys(obj);
        for (let j = 0; j < keys.length; ++j) {
          const key = keys[j];
          const val = obj[key];
          if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
            queue.push({ obj, prop: key });
            refs.push(val);
          }
        }
      }
      compact_queue(queue);
      return value;
    }
    function is_regexp(obj) {
      return Object.prototype.toString.call(obj) === "[object RegExp]";
    }
    function is_buffer(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    }
    function combine(a, b) {
      return [].concat(a, b);
    }
    function maybe_map(val, fn) {
      if ((0, values_1.isArray)(val)) {
        const mapped = [];
        for (let i = 0; i < val.length; i += 1) {
          mapped.push(fn(val[i]));
        }
        return mapped;
      }
      return fn(val);
    }
  }
});

// node_modules/openai/internal/qs/stringify.js
var require_stringify = __commonJS({
  "node_modules/openai/internal/qs/stringify.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringify = stringify;
    var utils_1 = require_utils();
    var formats_1 = require_formats();
    var values_1 = require_values();
    var array_prefix_generators = {
      brackets(prefix) {
        return String(prefix) + "[]";
      },
      comma: "comma",
      indices(prefix, key) {
        return String(prefix) + "[" + key + "]";
      },
      repeat(prefix) {
        return String(prefix);
      }
    };
    var push_to_array = function(arr, value_or_array) {
      Array.prototype.push.apply(arr, (0, values_1.isArray)(value_or_array) ? value_or_array : [value_or_array]);
    };
    var toISOString;
    var defaults = {
      addQueryPrefix: false,
      allowDots: false,
      allowEmptyArrays: false,
      arrayFormat: "indices",
      charset: "utf-8",
      charsetSentinel: false,
      delimiter: "&",
      encode: true,
      encodeDotInKeys: false,
      encoder: utils_1.encode,
      encodeValuesOnly: false,
      format: formats_1.default_format,
      formatter: formats_1.default_formatter,
      /** @deprecated */
      indices: false,
      serializeDate(date) {
        return (toISOString ?? (toISOString = Function.prototype.call.bind(Date.prototype.toISOString)))(date);
      },
      skipNulls: false,
      strictNullHandling: false
    };
    function is_non_nullish_primitive(v) {
      return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
    }
    var sentinel = {};
    function inner_stringify(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
      let obj = object;
      let tmp_sc = sideChannel;
      let step = 0;
      let find_flag = false;
      while ((tmp_sc = tmp_sc.get(sentinel)) !== void 0 && !find_flag) {
        const pos = tmp_sc.get(object);
        step += 1;
        if (typeof pos !== "undefined") {
          if (pos === step) {
            throw new RangeError("Cyclic object value");
          } else {
            find_flag = true;
          }
        }
        if (typeof tmp_sc.get(sentinel) === "undefined") {
          step = 0;
        }
      }
      if (typeof filter === "function") {
        obj = filter(prefix, obj);
      } else if (obj instanceof Date) {
        obj = serializeDate == null ? void 0 : serializeDate(obj);
      } else if (generateArrayPrefix === "comma" && (0, values_1.isArray)(obj)) {
        obj = (0, utils_1.maybe_map)(obj, function(value) {
          if (value instanceof Date) {
            return serializeDate == null ? void 0 : serializeDate(value);
          }
          return value;
        });
      }
      if (obj === null) {
        if (strictNullHandling) {
          return encoder && !encodeValuesOnly ? (
            // @ts-expect-error
            encoder(prefix, defaults.encoder, charset, "key", format)
          ) : prefix;
        }
        obj = "";
      }
      if (is_non_nullish_primitive(obj) || (0, utils_1.is_buffer)(obj)) {
        if (encoder) {
          const key_value = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format);
          return [
            (formatter == null ? void 0 : formatter(key_value)) + "=" + // @ts-expect-error
            (formatter == null ? void 0 : formatter(encoder(obj, defaults.encoder, charset, "value", format)))
          ];
        }
        return [(formatter == null ? void 0 : formatter(prefix)) + "=" + (formatter == null ? void 0 : formatter(String(obj)))];
      }
      const values = [];
      if (typeof obj === "undefined") {
        return values;
      }
      let obj_keys;
      if (generateArrayPrefix === "comma" && (0, values_1.isArray)(obj)) {
        if (encodeValuesOnly && encoder) {
          obj = (0, utils_1.maybe_map)(obj, encoder);
        }
        obj_keys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
      } else if ((0, values_1.isArray)(filter)) {
        obj_keys = filter;
      } else {
        const keys = Object.keys(obj);
        obj_keys = sort ? keys.sort(sort) : keys;
      }
      const encoded_prefix = encodeDotInKeys ? String(prefix).replace(/\./g, "%2E") : String(prefix);
      const adjusted_prefix = commaRoundTrip && (0, values_1.isArray)(obj) && obj.length === 1 ? encoded_prefix + "[]" : encoded_prefix;
      if (allowEmptyArrays && (0, values_1.isArray)(obj) && obj.length === 0) {
        return adjusted_prefix + "[]";
      }
      for (let j = 0; j < obj_keys.length; ++j) {
        const key = obj_keys[j];
        const value = (
          // @ts-ignore
          typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key]
        );
        if (skipNulls && value === null) {
          continue;
        }
        const encoded_key = allowDots && encodeDotInKeys ? key.replace(/\./g, "%2E") : key;
        const key_prefix = (0, values_1.isArray)(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjusted_prefix, encoded_key) : adjusted_prefix : adjusted_prefix + (allowDots ? "." + encoded_key : "[" + encoded_key + "]");
        sideChannel.set(object, step);
        const valueSideChannel = /* @__PURE__ */ new WeakMap();
        valueSideChannel.set(sentinel, sideChannel);
        push_to_array(values, inner_stringify(
          value,
          key_prefix,
          generateArrayPrefix,
          commaRoundTrip,
          allowEmptyArrays,
          strictNullHandling,
          skipNulls,
          encodeDotInKeys,
          // @ts-ignore
          generateArrayPrefix === "comma" && encodeValuesOnly && (0, values_1.isArray)(obj) ? null : encoder,
          filter,
          sort,
          allowDots,
          serializeDate,
          format,
          formatter,
          encodeValuesOnly,
          charset,
          valueSideChannel
        ));
      }
      return values;
    }
    function normalize_stringify_options(opts = defaults) {
      if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
        throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
      }
      if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
        throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
      }
      if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
        throw new TypeError("Encoder has to be a function.");
      }
      const charset = opts.charset || defaults.charset;
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      let format = formats_1.default_format;
      if (typeof opts.format !== "undefined") {
        if (!(0, utils_1.has)(formats_1.formatters, opts.format)) {
          throw new TypeError("Unknown format option provided.");
        }
        format = opts.format;
      }
      const formatter = formats_1.formatters[format];
      let filter = defaults.filter;
      if (typeof opts.filter === "function" || (0, values_1.isArray)(opts.filter)) {
        filter = opts.filter;
      }
      let arrayFormat;
      if (opts.arrayFormat && opts.arrayFormat in array_prefix_generators) {
        arrayFormat = opts.arrayFormat;
      } else if ("indices" in opts) {
        arrayFormat = opts.indices ? "indices" : "repeat";
      } else {
        arrayFormat = defaults.arrayFormat;
      }
      if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
        throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
      }
      const allowDots = typeof opts.allowDots === "undefined" ? !!opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
      return {
        addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
        // @ts-ignore
        allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        arrayFormat,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        commaRoundTrip: !!opts.commaRoundTrip,
        delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
        encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
        encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter,
        format,
        formatter,
        serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
        // @ts-ignore
        sort: typeof opts.sort === "function" ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    }
    function stringify(object, opts = {}) {
      let obj = object;
      const options = normalize_stringify_options(opts);
      let obj_keys;
      let filter;
      if (typeof options.filter === "function") {
        filter = options.filter;
        obj = filter("", obj);
      } else if ((0, values_1.isArray)(options.filter)) {
        filter = options.filter;
        obj_keys = filter;
      }
      const keys = [];
      if (typeof obj !== "object" || obj === null) {
        return "";
      }
      const generateArrayPrefix = array_prefix_generators[options.arrayFormat];
      const commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
      if (!obj_keys) {
        obj_keys = Object.keys(obj);
      }
      if (options.sort) {
        obj_keys.sort(options.sort);
      }
      const sideChannel = /* @__PURE__ */ new WeakMap();
      for (let i = 0; i < obj_keys.length; ++i) {
        const key = obj_keys[i];
        if (options.skipNulls && obj[key] === null) {
          continue;
        }
        push_to_array(keys, inner_stringify(
          obj[key],
          key,
          // @ts-expect-error
          generateArrayPrefix,
          commaRoundTrip,
          options.allowEmptyArrays,
          options.strictNullHandling,
          options.skipNulls,
          options.encodeDotInKeys,
          options.encode ? options.encoder : null,
          options.filter,
          options.sort,
          options.allowDots,
          options.serializeDate,
          options.format,
          options.formatter,
          options.encodeValuesOnly,
          options.charset,
          sideChannel
        ));
      }
      const joined = keys.join(options.delimiter);
      let prefix = options.addQueryPrefix === true ? "?" : "";
      if (options.charsetSentinel) {
        if (options.charset === "iso-8859-1") {
          prefix += "utf8=%26%2310003%3B&";
        } else {
          prefix += "utf8=%E2%9C%93&";
        }
      }
      return joined.length > 0 ? prefix + joined : "";
    }
  }
});

// node_modules/openai/internal/qs/index.js
var require_qs = __commonJS({
  "node_modules/openai/internal/qs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formats = exports.stringify = void 0;
    var formats_1 = require_formats();
    var formats = {
      formatters: formats_1.formatters,
      RFC1738: formats_1.RFC1738,
      RFC3986: formats_1.RFC3986,
      default: formats_1.default_format
    };
    exports.formats = formats;
    var stringify_1 = require_stringify();
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return stringify_1.stringify;
    } });
  }
});

// node_modules/openai/internal/utils/bytes.js
var require_bytes = __commonJS({
  "node_modules/openai/internal/utils/bytes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.concatBytes = concatBytes;
    exports.encodeUTF8 = encodeUTF8;
    exports.decodeUTF8 = decodeUTF8;
    function concatBytes(buffers) {
      let length = 0;
      for (const buffer of buffers) {
        length += buffer.length;
      }
      const output = new Uint8Array(length);
      let index = 0;
      for (const buffer of buffers) {
        output.set(buffer, index);
        index += buffer.length;
      }
      return output;
    }
    var encodeUTF8_;
    function encodeUTF8(str) {
      let encoder;
      return (encodeUTF8_ ?? (encoder = new globalThis.TextEncoder(), encodeUTF8_ = encoder.encode.bind(encoder)))(str);
    }
    var decodeUTF8_;
    function decodeUTF8(bytes) {
      let decoder;
      return (decodeUTF8_ ?? (decoder = new globalThis.TextDecoder(), decodeUTF8_ = decoder.decode.bind(decoder)))(bytes);
    }
  }
});

// node_modules/openai/internal/decoders/line.js
var require_line = __commonJS({
  "node_modules/openai/internal/decoders/line.js"(exports) {
    "use strict";
    var _LineDecoder_buffer;
    var _LineDecoder_carriageReturnIndex;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LineDecoder = void 0;
    exports.findDoubleNewlineIndex = findDoubleNewlineIndex;
    var tslib_1 = require_tslib();
    var bytes_1 = require_bytes();
    var LineDecoder = class {
      constructor() {
        _LineDecoder_buffer.set(this, void 0);
        _LineDecoder_carriageReturnIndex.set(this, void 0);
        tslib_1.__classPrivateFieldSet(this, _LineDecoder_buffer, new Uint8Array(), "f");
        tslib_1.__classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, "f");
      }
      decode(chunk) {
        if (chunk == null) {
          return [];
        }
        const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? (0, bytes_1.encodeUTF8)(chunk) : chunk;
        tslib_1.__classPrivateFieldSet(this, _LineDecoder_buffer, (0, bytes_1.concatBytes)([tslib_1.__classPrivateFieldGet(this, _LineDecoder_buffer, "f"), binaryChunk]), "f");
        const lines = [];
        let patternIndex;
        while ((patternIndex = findNewlineIndex(tslib_1.__classPrivateFieldGet(this, _LineDecoder_buffer, "f"), tslib_1.__classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f"))) != null) {
          if (patternIndex.carriage && tslib_1.__classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") == null) {
            tslib_1.__classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, patternIndex.index, "f");
            continue;
          }
          if (tslib_1.__classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") != null && (patternIndex.index !== tslib_1.__classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") + 1 || patternIndex.carriage)) {
            lines.push((0, bytes_1.decodeUTF8)(tslib_1.__classPrivateFieldGet(this, _LineDecoder_buffer, "f").subarray(0, tslib_1.__classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") - 1)));
            tslib_1.__classPrivateFieldSet(this, _LineDecoder_buffer, tslib_1.__classPrivateFieldGet(this, _LineDecoder_buffer, "f").subarray(tslib_1.__classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f")), "f");
            tslib_1.__classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, "f");
            continue;
          }
          const endIndex = tslib_1.__classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") !== null ? patternIndex.preceding - 1 : patternIndex.preceding;
          const line = (0, bytes_1.decodeUTF8)(tslib_1.__classPrivateFieldGet(this, _LineDecoder_buffer, "f").subarray(0, endIndex));
          lines.push(line);
          tslib_1.__classPrivateFieldSet(this, _LineDecoder_buffer, tslib_1.__classPrivateFieldGet(this, _LineDecoder_buffer, "f").subarray(patternIndex.index), "f");
          tslib_1.__classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, "f");
        }
        return lines;
      }
      flush() {
        if (!tslib_1.__classPrivateFieldGet(this, _LineDecoder_buffer, "f").length) {
          return [];
        }
        return this.decode("\n");
      }
    };
    exports.LineDecoder = LineDecoder;
    _LineDecoder_buffer = /* @__PURE__ */ new WeakMap(), _LineDecoder_carriageReturnIndex = /* @__PURE__ */ new WeakMap();
    LineDecoder.NEWLINE_CHARS = /* @__PURE__ */ new Set(["\n", "\r"]);
    LineDecoder.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
    function findNewlineIndex(buffer, startIndex) {
      const newline = 10;
      const carriage = 13;
      for (let i = startIndex ?? 0; i < buffer.length; i++) {
        if (buffer[i] === newline) {
          return { preceding: i, index: i + 1, carriage: false };
        }
        if (buffer[i] === carriage) {
          return { preceding: i, index: i + 1, carriage: true };
        }
      }
      return null;
    }
    function findDoubleNewlineIndex(buffer) {
      const newline = 10;
      const carriage = 13;
      for (let i = 0; i < buffer.length - 1; i++) {
        if (buffer[i] === newline && buffer[i + 1] === newline) {
          return i + 2;
        }
        if (buffer[i] === carriage && buffer[i + 1] === carriage) {
          return i + 2;
        }
        if (buffer[i] === carriage && buffer[i + 1] === newline && i + 3 < buffer.length && buffer[i + 2] === carriage && buffer[i + 3] === newline) {
          return i + 4;
        }
      }
      return -1;
    }
  }
});

// node_modules/openai/internal/utils/log.js
var require_log = __commonJS({
  "node_modules/openai/internal/utils/log.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatRequestDetails = exports.parseLogLevel = void 0;
    exports.loggerFor = loggerFor;
    var values_1 = require_values();
    var levelNumbers = {
      off: 0,
      error: 200,
      warn: 300,
      info: 400,
      debug: 500
    };
    var parseLogLevel = (maybeLevel, sourceName, client) => {
      if (!maybeLevel) {
        return void 0;
      }
      if ((0, values_1.hasOwn)(levelNumbers, maybeLevel)) {
        return maybeLevel;
      }
      loggerFor(client).warn(`${sourceName} was set to ${JSON.stringify(maybeLevel)}, expected one of ${JSON.stringify(Object.keys(levelNumbers))}`);
      return void 0;
    };
    exports.parseLogLevel = parseLogLevel;
    function noop() {
    }
    function makeLogFn(fnLevel, logger, logLevel) {
      if (!logger || levelNumbers[fnLevel] > levelNumbers[logLevel]) {
        return noop;
      } else {
        return logger[fnLevel].bind(logger);
      }
    }
    var noopLogger = {
      error: noop,
      warn: noop,
      info: noop,
      debug: noop
    };
    var cachedLoggers = /* @__PURE__ */ new WeakMap();
    function loggerFor(client) {
      const logger = client.logger;
      const logLevel = client.logLevel ?? "off";
      if (!logger) {
        return noopLogger;
      }
      const cachedLogger = cachedLoggers.get(logger);
      if (cachedLogger && cachedLogger[0] === logLevel) {
        return cachedLogger[1];
      }
      const levelLogger = {
        error: makeLogFn("error", logger, logLevel),
        warn: makeLogFn("warn", logger, logLevel),
        info: makeLogFn("info", logger, logLevel),
        debug: makeLogFn("debug", logger, logLevel)
      };
      cachedLoggers.set(logger, [logLevel, levelLogger]);
      return levelLogger;
    }
    var formatRequestDetails = (details) => {
      if (details.options) {
        details.options = { ...details.options };
        delete details.options["headers"];
      }
      if (details.headers) {
        details.headers = Object.fromEntries((details.headers instanceof Headers ? [...details.headers] : Object.entries(details.headers)).map(([name, value]) => [
          name,
          name.toLowerCase() === "authorization" || name.toLowerCase() === "cookie" || name.toLowerCase() === "set-cookie" ? "***" : value
        ]));
      }
      if ("retryOfRequestLogID" in details) {
        if (details.retryOfRequestLogID) {
          details.retryOf = details.retryOfRequestLogID;
        }
        delete details.retryOfRequestLogID;
      }
      return details;
    };
    exports.formatRequestDetails = formatRequestDetails;
  }
});

// node_modules/openai/core/streaming.js
var require_streaming = __commonJS({
  "node_modules/openai/core/streaming.js"(exports) {
    "use strict";
    var _Stream_client;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Stream = void 0;
    exports._iterSSEMessages = _iterSSEMessages;
    var tslib_1 = require_tslib();
    var error_1 = require_error();
    var shims_1 = require_shims();
    var line_1 = require_line();
    var shims_2 = require_shims();
    var errors_1 = require_errors();
    var bytes_1 = require_bytes();
    var log_1 = require_log();
    var error_2 = require_error();
    var Stream = class _Stream {
      constructor(iterator, controller, client) {
        this.iterator = iterator;
        _Stream_client.set(this, void 0);
        this.controller = controller;
        tslib_1.__classPrivateFieldSet(this, _Stream_client, client, "f");
      }
      static fromSSEResponse(response, controller, client) {
        let consumed = false;
        const logger = client ? (0, log_1.loggerFor)(client) : console;
        async function* iterator() {
          if (consumed) {
            throw new error_1.OpenAIError("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
          }
          consumed = true;
          let done = false;
          try {
            for await (const sse of _iterSSEMessages(response, controller)) {
              if (done)
                continue;
              if (sse.data.startsWith("[DONE]")) {
                done = true;
                continue;
              }
              if (sse.event === null || !sse.event.startsWith("thread.")) {
                let data;
                try {
                  data = JSON.parse(sse.data);
                } catch (e) {
                  logger.error(`Could not parse message into JSON:`, sse.data);
                  logger.error(`From chunk:`, sse.raw);
                  throw e;
                }
                if (data && data.error) {
                  throw new error_2.APIError(void 0, data.error, void 0, response.headers);
                }
                yield data;
              } else {
                let data;
                try {
                  data = JSON.parse(sse.data);
                } catch (e) {
                  console.error(`Could not parse message into JSON:`, sse.data);
                  console.error(`From chunk:`, sse.raw);
                  throw e;
                }
                if (sse.event == "error") {
                  throw new error_2.APIError(void 0, data.error, data.message, void 0);
                }
                yield { event: sse.event, data };
              }
            }
            done = true;
          } catch (e) {
            if ((0, errors_1.isAbortError)(e))
              return;
            throw e;
          } finally {
            if (!done)
              controller.abort();
          }
        }
        return new _Stream(iterator, controller, client);
      }
      /**
       * Generates a Stream from a newline-separated ReadableStream
       * where each item is a JSON value.
       */
      static fromReadableStream(readableStream, controller, client) {
        let consumed = false;
        async function* iterLines() {
          const lineDecoder = new line_1.LineDecoder();
          const iter = (0, shims_2.ReadableStreamToAsyncIterable)(readableStream);
          for await (const chunk of iter) {
            for (const line of lineDecoder.decode(chunk)) {
              yield line;
            }
          }
          for (const line of lineDecoder.flush()) {
            yield line;
          }
        }
        async function* iterator() {
          if (consumed) {
            throw new error_1.OpenAIError("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
          }
          consumed = true;
          let done = false;
          try {
            for await (const line of iterLines()) {
              if (done)
                continue;
              if (line)
                yield JSON.parse(line);
            }
            done = true;
          } catch (e) {
            if ((0, errors_1.isAbortError)(e))
              return;
            throw e;
          } finally {
            if (!done)
              controller.abort();
          }
        }
        return new _Stream(iterator, controller, client);
      }
      [(_Stream_client = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
        return this.iterator();
      }
      /**
       * Splits the stream into two streams which can be
       * independently read from at different speeds.
       */
      tee() {
        const left = [];
        const right = [];
        const iterator = this.iterator();
        const teeIterator = (queue) => {
          return {
            next: () => {
              if (queue.length === 0) {
                const result = iterator.next();
                left.push(result);
                right.push(result);
              }
              return queue.shift();
            }
          };
        };
        return [
          new _Stream(() => teeIterator(left), this.controller, tslib_1.__classPrivateFieldGet(this, _Stream_client, "f")),
          new _Stream(() => teeIterator(right), this.controller, tslib_1.__classPrivateFieldGet(this, _Stream_client, "f"))
        ];
      }
      /**
       * Converts this stream to a newline-separated ReadableStream of
       * JSON stringified values in the stream
       * which can be turned back into a Stream with `Stream.fromReadableStream()`.
       */
      toReadableStream() {
        const self2 = this;
        let iter;
        return (0, shims_1.makeReadableStream)({
          async start() {
            iter = self2[Symbol.asyncIterator]();
          },
          async pull(ctrl) {
            try {
              const { value, done } = await iter.next();
              if (done)
                return ctrl.close();
              const bytes = (0, bytes_1.encodeUTF8)(JSON.stringify(value) + "\n");
              ctrl.enqueue(bytes);
            } catch (err) {
              ctrl.error(err);
            }
          },
          async cancel() {
            var _a;
            await ((_a = iter.return) == null ? void 0 : _a.call(iter));
          }
        });
      }
    };
    exports.Stream = Stream;
    async function* _iterSSEMessages(response, controller) {
      if (!response.body) {
        controller.abort();
        if (typeof globalThis.navigator !== "undefined" && globalThis.navigator.product === "ReactNative") {
          throw new error_1.OpenAIError(`The default react-native fetch implementation does not support streaming. Please use expo/fetch: https://docs.expo.dev/versions/latest/sdk/expo/#expofetch-api`);
        }
        throw new error_1.OpenAIError(`Attempted to iterate over a response with no body`);
      }
      const sseDecoder = new SSEDecoder();
      const lineDecoder = new line_1.LineDecoder();
      const iter = (0, shims_2.ReadableStreamToAsyncIterable)(response.body);
      for await (const sseChunk of iterSSEChunks(iter)) {
        for (const line of lineDecoder.decode(sseChunk)) {
          const sse = sseDecoder.decode(line);
          if (sse)
            yield sse;
        }
      }
      for (const line of lineDecoder.flush()) {
        const sse = sseDecoder.decode(line);
        if (sse)
          yield sse;
      }
    }
    async function* iterSSEChunks(iterator) {
      let data = new Uint8Array();
      for await (const chunk of iterator) {
        if (chunk == null) {
          continue;
        }
        const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? (0, bytes_1.encodeUTF8)(chunk) : chunk;
        let newData = new Uint8Array(data.length + binaryChunk.length);
        newData.set(data);
        newData.set(binaryChunk, data.length);
        data = newData;
        let patternIndex;
        while ((patternIndex = (0, line_1.findDoubleNewlineIndex)(data)) !== -1) {
          yield data.slice(0, patternIndex);
          data = data.slice(patternIndex);
        }
      }
      if (data.length > 0) {
        yield data;
      }
    }
    var SSEDecoder = class {
      constructor() {
        this.event = null;
        this.data = [];
        this.chunks = [];
      }
      decode(line) {
        if (line.endsWith("\r")) {
          line = line.substring(0, line.length - 1);
        }
        if (!line) {
          if (!this.event && !this.data.length)
            return null;
          const sse = {
            event: this.event,
            data: this.data.join("\n"),
            raw: this.chunks
          };
          this.event = null;
          this.data = [];
          this.chunks = [];
          return sse;
        }
        this.chunks.push(line);
        if (line.startsWith(":")) {
          return null;
        }
        let [fieldname, _, value] = partition(line, ":");
        if (value.startsWith(" ")) {
          value = value.substring(1);
        }
        if (fieldname === "event") {
          this.event = value;
        } else if (fieldname === "data") {
          this.data.push(value);
        }
        return null;
      }
    };
    function partition(str, delimiter) {
      const index = str.indexOf(delimiter);
      if (index !== -1) {
        return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];
      }
      return [str, "", ""];
    }
  }
});

// node_modules/openai/internal/parse.js
var require_parse = __commonJS({
  "node_modules/openai/internal/parse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultParseResponse = defaultParseResponse;
    exports.addRequestID = addRequestID;
    var streaming_1 = require_streaming();
    var log_1 = require_log();
    async function defaultParseResponse(client, props) {
      const { response, requestLogID, retryOfRequestLogID, startTime } = props;
      const body = await (async () => {
        var _a;
        if (props.options.stream) {
          (0, log_1.loggerFor)(client).debug("response", response.status, response.url, response.headers, response.body);
          if (props.options.__streamClass) {
            return props.options.__streamClass.fromSSEResponse(response, props.controller, client);
          }
          return streaming_1.Stream.fromSSEResponse(response, props.controller, client);
        }
        if (response.status === 204) {
          return null;
        }
        if (props.options.__binaryResponse) {
          return response;
        }
        const contentType = response.headers.get("content-type");
        const mediaType = (_a = contentType == null ? void 0 : contentType.split(";")[0]) == null ? void 0 : _a.trim();
        const isJSON = (mediaType == null ? void 0 : mediaType.includes("application/json")) || (mediaType == null ? void 0 : mediaType.endsWith("+json"));
        if (isJSON) {
          const json = await response.json();
          return addRequestID(json, response);
        }
        const text = await response.text();
        return text;
      })();
      (0, log_1.loggerFor)(client).debug(`[${requestLogID}] response parsed`, (0, log_1.formatRequestDetails)({
        retryOfRequestLogID,
        url: response.url,
        status: response.status,
        body,
        durationMs: Date.now() - startTime
      }));
      return body;
    }
    function addRequestID(value, response) {
      if (!value || typeof value !== "object" || Array.isArray(value)) {
        return value;
      }
      return Object.defineProperty(value, "_request_id", {
        value: response.headers.get("x-request-id"),
        enumerable: false
      });
    }
  }
});

// node_modules/openai/core/api-promise.js
var require_api_promise = __commonJS({
  "node_modules/openai/core/api-promise.js"(exports) {
    "use strict";
    var _APIPromise_client;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.APIPromise = void 0;
    var tslib_1 = require_tslib();
    var parse_1 = require_parse();
    var APIPromise = class _APIPromise extends Promise {
      constructor(client, responsePromise, parseResponse = parse_1.defaultParseResponse) {
        super((resolve) => {
          resolve(null);
        });
        this.responsePromise = responsePromise;
        this.parseResponse = parseResponse;
        _APIPromise_client.set(this, void 0);
        tslib_1.__classPrivateFieldSet(this, _APIPromise_client, client, "f");
      }
      _thenUnwrap(transform) {
        return new _APIPromise(tslib_1.__classPrivateFieldGet(this, _APIPromise_client, "f"), this.responsePromise, async (client, props) => (0, parse_1.addRequestID)(transform(await this.parseResponse(client, props), props), props.response));
      }
      /**
       * Gets the raw `Response` instance instead of parsing the response
       * data.
       *
       * If you want to parse the response body but still get the `Response`
       * instance, you can use {@link withResponse()}.
       *
       *  Getting the wrong TypeScript type for `Response`?
       * Try setting `"moduleResolution": "NodeNext"` or add `"lib": ["DOM"]`
       * to your `tsconfig.json`.
       */
      asResponse() {
        return this.responsePromise.then((p) => p.response);
      }
      /**
       * Gets the parsed response data, the raw `Response` instance and the ID of the request,
       * returned via the X-Request-ID header which is useful for debugging requests and reporting
       * issues to OpenAI.
       *
       * If you just want to get the raw `Response` instance without parsing it,
       * you can use {@link asResponse()}.
       *
       *  Getting the wrong TypeScript type for `Response`?
       * Try setting `"moduleResolution": "NodeNext"` or add `"lib": ["DOM"]`
       * to your `tsconfig.json`.
       */
      async withResponse() {
        const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
        return { data, response, request_id: response.headers.get("x-request-id") };
      }
      parse() {
        if (!this.parsedPromise) {
          this.parsedPromise = this.responsePromise.then((data) => this.parseResponse(tslib_1.__classPrivateFieldGet(this, _APIPromise_client, "f"), data));
        }
        return this.parsedPromise;
      }
      then(onfulfilled, onrejected) {
        return this.parse().then(onfulfilled, onrejected);
      }
      catch(onrejected) {
        return this.parse().catch(onrejected);
      }
      finally(onfinally) {
        return this.parse().finally(onfinally);
      }
    };
    exports.APIPromise = APIPromise;
    _APIPromise_client = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/openai/core/pagination.js
var require_pagination = __commonJS({
  "node_modules/openai/core/pagination.js"(exports) {
    "use strict";
    var _AbstractPage_client;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConversationCursorPage = exports.CursorPage = exports.Page = exports.PagePromise = exports.AbstractPage = void 0;
    var tslib_1 = require_tslib();
    var error_1 = require_error();
    var parse_1 = require_parse();
    var api_promise_1 = require_api_promise();
    var values_1 = require_values();
    var AbstractPage = class {
      constructor(client, response, body, options) {
        _AbstractPage_client.set(this, void 0);
        tslib_1.__classPrivateFieldSet(this, _AbstractPage_client, client, "f");
        this.options = options;
        this.response = response;
        this.body = body;
      }
      hasNextPage() {
        const items = this.getPaginatedItems();
        if (!items.length)
          return false;
        return this.nextPageRequestOptions() != null;
      }
      async getNextPage() {
        const nextOptions = this.nextPageRequestOptions();
        if (!nextOptions) {
          throw new error_1.OpenAIError("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
        }
        return await tslib_1.__classPrivateFieldGet(this, _AbstractPage_client, "f").requestAPIList(this.constructor, nextOptions);
      }
      async *iterPages() {
        let page = this;
        yield page;
        while (page.hasNextPage()) {
          page = await page.getNextPage();
          yield page;
        }
      }
      async *[(_AbstractPage_client = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
        for await (const page of this.iterPages()) {
          for (const item of page.getPaginatedItems()) {
            yield item;
          }
        }
      }
    };
    exports.AbstractPage = AbstractPage;
    var PagePromise = class extends api_promise_1.APIPromise {
      constructor(client, request, Page2) {
        super(client, request, async (client2, props) => new Page2(client2, props.response, await (0, parse_1.defaultParseResponse)(client2, props), props.options));
      }
      /**
       * Allow auto-paginating iteration on an unawaited list call, eg:
       *
       *    for await (const item of client.items.list()) {
       *      console.log(item)
       *    }
       */
      async *[Symbol.asyncIterator]() {
        const page = await this;
        for await (const item of page) {
          yield item;
        }
      }
    };
    exports.PagePromise = PagePromise;
    var Page = class extends AbstractPage {
      constructor(client, response, body, options) {
        super(client, response, body, options);
        this.data = body.data || [];
        this.object = body.object;
      }
      getPaginatedItems() {
        return this.data ?? [];
      }
      nextPageRequestOptions() {
        return null;
      }
    };
    exports.Page = Page;
    var CursorPage = class extends AbstractPage {
      constructor(client, response, body, options) {
        super(client, response, body, options);
        this.data = body.data || [];
        this.has_more = body.has_more || false;
      }
      getPaginatedItems() {
        return this.data ?? [];
      }
      hasNextPage() {
        if (this.has_more === false) {
          return false;
        }
        return super.hasNextPage();
      }
      nextPageRequestOptions() {
        var _a;
        const data = this.getPaginatedItems();
        const id = (_a = data[data.length - 1]) == null ? void 0 : _a.id;
        if (!id) {
          return null;
        }
        return {
          ...this.options,
          query: {
            ...(0, values_1.maybeObj)(this.options.query),
            after: id
          }
        };
      }
    };
    exports.CursorPage = CursorPage;
    var ConversationCursorPage = class extends AbstractPage {
      constructor(client, response, body, options) {
        super(client, response, body, options);
        this.data = body.data || [];
        this.has_more = body.has_more || false;
        this.last_id = body.last_id || "";
      }
      getPaginatedItems() {
        return this.data ?? [];
      }
      hasNextPage() {
        if (this.has_more === false) {
          return false;
        }
        return super.hasNextPage();
      }
      nextPageRequestOptions() {
        const cursor = this.last_id;
        if (!cursor) {
          return null;
        }
        return {
          ...this.options,
          query: {
            ...(0, values_1.maybeObj)(this.options.query),
            after: cursor
          }
        };
      }
    };
    exports.ConversationCursorPage = ConversationCursorPage;
  }
});

// node_modules/openai/internal/uploads.js
var require_uploads = __commonJS({
  "node_modules/openai/internal/uploads.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createForm = exports.multipartFormRequestOptions = exports.maybeMultipartFormRequestOptions = exports.isAsyncIterable = exports.checkFileSupport = void 0;
    exports.makeFile = makeFile;
    exports.getName = getName;
    var shims_1 = require_shims();
    var checkFileSupport = () => {
      var _a;
      if (typeof File === "undefined") {
        const { process: process2 } = globalThis;
        const isOldNode = typeof ((_a = process2 == null ? void 0 : process2.versions) == null ? void 0 : _a.node) === "string" && parseInt(process2.versions.node.split(".")) < 20;
        throw new Error("`File` is not defined as a global, which is required for file uploads." + (isOldNode ? " Update to Node 20 LTS or newer, or set `globalThis.File` to `import('node:buffer').File`." : ""));
      }
    };
    exports.checkFileSupport = checkFileSupport;
    function makeFile(fileBits, fileName, options) {
      (0, exports.checkFileSupport)();
      return new File(fileBits, fileName ?? "unknown_file", options);
    }
    function getName(value) {
      return (typeof value === "object" && value !== null && ("name" in value && value.name && String(value.name) || "url" in value && value.url && String(value.url) || "filename" in value && value.filename && String(value.filename) || "path" in value && value.path && String(value.path)) || "").split(/[\\/]/).pop() || void 0;
    }
    var isAsyncIterable = (value) => value != null && typeof value === "object" && typeof value[Symbol.asyncIterator] === "function";
    exports.isAsyncIterable = isAsyncIterable;
    var maybeMultipartFormRequestOptions = async (opts, fetch2) => {
      if (!hasUploadableValue(opts.body))
        return opts;
      return { ...opts, body: await (0, exports.createForm)(opts.body, fetch2) };
    };
    exports.maybeMultipartFormRequestOptions = maybeMultipartFormRequestOptions;
    var multipartFormRequestOptions = async (opts, fetch2) => {
      return { ...opts, body: await (0, exports.createForm)(opts.body, fetch2) };
    };
    exports.multipartFormRequestOptions = multipartFormRequestOptions;
    var supportsFormDataMap = /* @__PURE__ */ new WeakMap();
    function supportsFormData(fetchObject) {
      const fetch2 = typeof fetchObject === "function" ? fetchObject : fetchObject.fetch;
      const cached = supportsFormDataMap.get(fetch2);
      if (cached)
        return cached;
      const promise = (async () => {
        try {
          const FetchResponse = "Response" in fetch2 ? fetch2.Response : (await fetch2("data:,")).constructor;
          const data = new FormData();
          if (data.toString() === await new FetchResponse(data).text()) {
            return false;
          }
          return true;
        } catch {
          return true;
        }
      })();
      supportsFormDataMap.set(fetch2, promise);
      return promise;
    }
    var createForm = async (body, fetch2) => {
      if (!await supportsFormData(fetch2)) {
        throw new TypeError("The provided fetch function does not support file uploads with the current global FormData class.");
      }
      const form = new FormData();
      await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));
      return form;
    };
    exports.createForm = createForm;
    var isNamedBlob = (value) => value instanceof Blob && "name" in value;
    var isUploadable = (value) => typeof value === "object" && value !== null && (value instanceof Response || (0, exports.isAsyncIterable)(value) || isNamedBlob(value));
    var hasUploadableValue = (value) => {
      if (isUploadable(value))
        return true;
      if (Array.isArray(value))
        return value.some(hasUploadableValue);
      if (value && typeof value === "object") {
        for (const k in value) {
          if (hasUploadableValue(value[k]))
            return true;
        }
      }
      return false;
    };
    var addFormValue = async (form, key, value) => {
      if (value === void 0)
        return;
      if (value == null) {
        throw new TypeError(`Received null for "${key}"; to pass null in FormData, you must use the string 'null'`);
      }
      if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
        form.append(key, String(value));
      } else if (value instanceof Response) {
        form.append(key, makeFile([await value.blob()], getName(value)));
      } else if ((0, exports.isAsyncIterable)(value)) {
        form.append(key, makeFile([await new Response((0, shims_1.ReadableStreamFrom)(value)).blob()], getName(value)));
      } else if (isNamedBlob(value)) {
        form.append(key, value, getName(value));
      } else if (Array.isArray(value)) {
        await Promise.all(value.map((entry) => addFormValue(form, key + "[]", entry)));
      } else if (typeof value === "object") {
        await Promise.all(Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)));
      } else {
        throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);
      }
    };
  }
});

// node_modules/openai/internal/to-file.js
var require_to_file = __commonJS({
  "node_modules/openai/internal/to-file.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toFile = toFile;
    var uploads_1 = require_uploads();
    var uploads_2 = require_uploads();
    var isBlobLike = (value) => value != null && typeof value === "object" && typeof value.size === "number" && typeof value.type === "string" && typeof value.text === "function" && typeof value.slice === "function" && typeof value.arrayBuffer === "function";
    var isFileLike = (value) => value != null && typeof value === "object" && typeof value.name === "string" && typeof value.lastModified === "number" && isBlobLike(value);
    var isResponseLike = (value) => value != null && typeof value === "object" && typeof value.url === "string" && typeof value.blob === "function";
    async function toFile(value, name, options) {
      (0, uploads_2.checkFileSupport)();
      value = await value;
      if (isFileLike(value)) {
        if (value instanceof File) {
          return value;
        }
        return (0, uploads_1.makeFile)([await value.arrayBuffer()], value.name);
      }
      if (isResponseLike(value)) {
        const blob = await value.blob();
        name || (name = new URL(value.url).pathname.split(/[\\/]/).pop());
        return (0, uploads_1.makeFile)(await getBytes(blob), name, options);
      }
      const parts = await getBytes(value);
      name || (name = (0, uploads_1.getName)(value));
      if (!(options == null ? void 0 : options.type)) {
        const type = parts.find((part) => typeof part === "object" && "type" in part && part.type);
        if (typeof type === "string") {
          options = { ...options, type };
        }
      }
      return (0, uploads_1.makeFile)(parts, name, options);
    }
    async function getBytes(value) {
      var _a;
      let parts = [];
      if (typeof value === "string" || ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.
      value instanceof ArrayBuffer) {
        parts.push(value);
      } else if (isBlobLike(value)) {
        parts.push(value instanceof Blob ? value : await value.arrayBuffer());
      } else if ((0, uploads_1.isAsyncIterable)(value)) {
        for await (const chunk of value) {
          parts.push(...await getBytes(chunk));
        }
      } else {
        const constructor = (_a = value == null ? void 0 : value.constructor) == null ? void 0 : _a.name;
        throw new Error(`Unexpected data type: ${typeof value}${constructor ? `; constructor: ${constructor}` : ""}${propsForError(value)}`);
      }
      return parts;
    }
    function propsForError(value) {
      if (typeof value !== "object" || value === null)
        return "";
      const props = Object.getOwnPropertyNames(value);
      return `; props: [${props.map((p) => `"${p}"`).join(", ")}]`;
    }
  }
});

// node_modules/openai/core/uploads.js
var require_uploads2 = __commonJS({
  "node_modules/openai/core/uploads.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toFile = void 0;
    var to_file_1 = require_to_file();
    Object.defineProperty(exports, "toFile", { enumerable: true, get: function() {
      return to_file_1.toFile;
    } });
  }
});

// node_modules/openai/core/resource.js
var require_resource = __commonJS({
  "node_modules/openai/core/resource.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.APIResource = void 0;
    var APIResource = class {
      constructor(client) {
        this._client = client;
      }
    };
    exports.APIResource = APIResource;
  }
});

// node_modules/openai/internal/utils/path.js
var require_path = __commonJS({
  "node_modules/openai/internal/utils/path.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.path = exports.createPathTagFunction = void 0;
    exports.encodeURIPath = encodeURIPath;
    var error_1 = require_error();
    function encodeURIPath(str) {
      return str.replace(/[^A-Za-z0-9\-._~!$&'()*+,;=:@]+/g, encodeURIComponent);
    }
    var EMPTY = Object.freeze(/* @__PURE__ */ Object.create(null));
    var createPathTagFunction = (pathEncoder = encodeURIPath) => function path(statics, ...params) {
      if (statics.length === 1)
        return statics[0];
      let postPath = false;
      const invalidSegments = [];
      const path2 = statics.reduce((previousValue, currentValue, index) => {
        var _a;
        if (/[?#]/.test(currentValue)) {
          postPath = true;
        }
        const value = params[index];
        let encoded = (postPath ? encodeURIComponent : pathEncoder)("" + value);
        if (index !== params.length && (value == null || typeof value === "object" && // handle values from other realms
        value.toString === ((_a = Object.getPrototypeOf(Object.getPrototypeOf(value.hasOwnProperty ?? EMPTY) ?? EMPTY)) == null ? void 0 : _a.toString))) {
          encoded = value + "";
          invalidSegments.push({
            start: previousValue.length + currentValue.length,
            length: encoded.length,
            error: `Value of type ${Object.prototype.toString.call(value).slice(8, -1)} is not a valid path parameter`
          });
        }
        return previousValue + currentValue + (index === params.length ? "" : encoded);
      }, "");
      const pathOnly = path2.split(/[?#]/, 1)[0];
      const invalidSegmentPattern = new RegExp("(?<=^|\\/)(?:\\.|%2e){1,2}(?=\\/|$)", "gi");
      let match;
      while ((match = invalidSegmentPattern.exec(pathOnly)) !== null) {
        invalidSegments.push({
          start: match.index,
          length: match[0].length,
          error: `Value "${match[0]}" can't be safely passed as a path parameter`
        });
      }
      invalidSegments.sort((a, b) => a.start - b.start);
      if (invalidSegments.length > 0) {
        let lastEnd = 0;
        const underline = invalidSegments.reduce((acc, segment) => {
          const spaces = " ".repeat(segment.start - lastEnd);
          const arrows = "^".repeat(segment.length);
          lastEnd = segment.start + segment.length;
          return acc + spaces + arrows;
        }, "");
        throw new error_1.OpenAIError(`Path parameters result in path with invalid segments:
${invalidSegments.map((e) => e.error).join("\n")}
${path2}
${underline}`);
      }
      return path2;
    };
    exports.createPathTagFunction = createPathTagFunction;
    exports.path = (0, exports.createPathTagFunction)(encodeURIPath);
  }
});

// node_modules/openai/resources/chat/completions/messages.js
var require_messages = __commonJS({
  "node_modules/openai/resources/chat/completions/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Messages = void 0;
    var resource_1 = require_resource();
    var pagination_1 = require_pagination();
    var path_1 = require_path();
    var Messages = class extends resource_1.APIResource {
      /**
       * Get the messages in a stored chat completion. Only Chat Completions that have
       * been created with the `store` parameter set to `true` will be returned.
       *
       * @example
       * ```ts
       * // Automatically fetches more pages as needed.
       * for await (const chatCompletionStoreMessage of client.chat.completions.messages.list(
       *   'completion_id',
       * )) {
       *   // ...
       * }
       * ```
       */
      list(completionID, query = {}, options) {
        return this._client.getAPIList((0, path_1.path)`/chat/completions/${completionID}/messages`, pagination_1.CursorPage, { query, ...options });
      }
    };
    exports.Messages = Messages;
  }
});

// node_modules/openai/error.js
var require_error2 = __commonJS({
  "node_modules/openai/error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    tslib_1.__exportStar(require_error(), exports);
  }
});

// node_modules/openai/lib/parser.js
var require_parser = __commonJS({
  "node_modules/openai/lib/parser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isChatCompletionFunctionTool = isChatCompletionFunctionTool;
    exports.makeParseableResponseFormat = makeParseableResponseFormat;
    exports.makeParseableTextFormat = makeParseableTextFormat;
    exports.isAutoParsableResponseFormat = isAutoParsableResponseFormat;
    exports.makeParseableTool = makeParseableTool;
    exports.isAutoParsableTool = isAutoParsableTool;
    exports.maybeParseChatCompletion = maybeParseChatCompletion;
    exports.parseChatCompletion = parseChatCompletion;
    exports.shouldParseToolCall = shouldParseToolCall;
    exports.hasAutoParseableInput = hasAutoParseableInput;
    exports.assertToolCallsAreChatCompletionFunctionToolCalls = assertToolCallsAreChatCompletionFunctionToolCalls;
    exports.validateInputTools = validateInputTools;
    var error_1 = require_error2();
    function isChatCompletionFunctionTool(tool) {
      return tool !== void 0 && "function" in tool && tool.function !== void 0;
    }
    function makeParseableResponseFormat(response_format, parser) {
      const obj = { ...response_format };
      Object.defineProperties(obj, {
        $brand: {
          value: "auto-parseable-response-format",
          enumerable: false
        },
        $parseRaw: {
          value: parser,
          enumerable: false
        }
      });
      return obj;
    }
    function makeParseableTextFormat(response_format, parser) {
      const obj = { ...response_format };
      Object.defineProperties(obj, {
        $brand: {
          value: "auto-parseable-response-format",
          enumerable: false
        },
        $parseRaw: {
          value: parser,
          enumerable: false
        }
      });
      return obj;
    }
    function isAutoParsableResponseFormat(response_format) {
      return (response_format == null ? void 0 : response_format["$brand"]) === "auto-parseable-response-format";
    }
    function makeParseableTool(tool, { parser, callback }) {
      const obj = { ...tool };
      Object.defineProperties(obj, {
        $brand: {
          value: "auto-parseable-tool",
          enumerable: false
        },
        $parseRaw: {
          value: parser,
          enumerable: false
        },
        $callback: {
          value: callback,
          enumerable: false
        }
      });
      return obj;
    }
    function isAutoParsableTool(tool) {
      return (tool == null ? void 0 : tool["$brand"]) === "auto-parseable-tool";
    }
    function maybeParseChatCompletion(completion, params) {
      if (!params || !hasAutoParseableInput(params)) {
        return {
          ...completion,
          choices: completion.choices.map((choice) => {
            assertToolCallsAreChatCompletionFunctionToolCalls(choice.message.tool_calls);
            return {
              ...choice,
              message: {
                ...choice.message,
                parsed: null,
                ...choice.message.tool_calls ? {
                  tool_calls: choice.message.tool_calls
                } : void 0
              }
            };
          })
        };
      }
      return parseChatCompletion(completion, params);
    }
    function parseChatCompletion(completion, params) {
      const choices = completion.choices.map((choice) => {
        var _a;
        if (choice.finish_reason === "length") {
          throw new error_1.LengthFinishReasonError();
        }
        if (choice.finish_reason === "content_filter") {
          throw new error_1.ContentFilterFinishReasonError();
        }
        assertToolCallsAreChatCompletionFunctionToolCalls(choice.message.tool_calls);
        return {
          ...choice,
          message: {
            ...choice.message,
            ...choice.message.tool_calls ? {
              tool_calls: ((_a = choice.message.tool_calls) == null ? void 0 : _a.map((toolCall) => parseToolCall(params, toolCall))) ?? void 0
            } : void 0,
            parsed: choice.message.content && !choice.message.refusal ? parseResponseFormat(params, choice.message.content) : null
          }
        };
      });
      return { ...completion, choices };
    }
    function parseResponseFormat(params, content) {
      var _a, _b;
      if (((_a = params.response_format) == null ? void 0 : _a.type) !== "json_schema") {
        return null;
      }
      if (((_b = params.response_format) == null ? void 0 : _b.type) === "json_schema") {
        if ("$parseRaw" in params.response_format) {
          const response_format = params.response_format;
          return response_format.$parseRaw(content);
        }
        return JSON.parse(content);
      }
      return null;
    }
    function parseToolCall(params, toolCall) {
      var _a;
      const inputTool = (_a = params.tools) == null ? void 0 : _a.find((inputTool2) => {
        var _a2;
        return isChatCompletionFunctionTool(inputTool2) && ((_a2 = inputTool2.function) == null ? void 0 : _a2.name) === toolCall.function.name;
      });
      return {
        ...toolCall,
        function: {
          ...toolCall.function,
          parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCall.function.arguments) : (inputTool == null ? void 0 : inputTool.function.strict) ? JSON.parse(toolCall.function.arguments) : null
        }
      };
    }
    function shouldParseToolCall(params, toolCall) {
      var _a;
      if (!params || !("tools" in params) || !params.tools) {
        return false;
      }
      const inputTool = (_a = params.tools) == null ? void 0 : _a.find((inputTool2) => {
        var _a2;
        return isChatCompletionFunctionTool(inputTool2) && ((_a2 = inputTool2.function) == null ? void 0 : _a2.name) === toolCall.function.name;
      });
      return isChatCompletionFunctionTool(inputTool) && (isAutoParsableTool(inputTool) || (inputTool == null ? void 0 : inputTool.function.strict) || false);
    }
    function hasAutoParseableInput(params) {
      var _a;
      if (isAutoParsableResponseFormat(params.response_format)) {
        return true;
      }
      return ((_a = params.tools) == null ? void 0 : _a.some((t) => isAutoParsableTool(t) || t.type === "function" && t.function.strict === true)) ?? false;
    }
    function assertToolCallsAreChatCompletionFunctionToolCalls(toolCalls) {
      for (const toolCall of toolCalls || []) {
        if (toolCall.type !== "function") {
          throw new error_1.OpenAIError(`Currently only \`function\` tool calls are supported; Received \`${toolCall.type}\``);
        }
      }
    }
    function validateInputTools(tools) {
      for (const tool of tools ?? []) {
        if (tool.type !== "function") {
          throw new error_1.OpenAIError(`Currently only \`function\` tool types support auto-parsing; Received \`${tool.type}\``);
        }
        if (tool.function.strict !== true) {
          throw new error_1.OpenAIError(`The \`${tool.function.name}\` tool is not marked with \`strict: true\`. Only strict function tools can be auto-parsed`);
        }
      }
    }
  }
});

// node_modules/openai/lib/chatCompletionUtils.js
var require_chatCompletionUtils = __commonJS({
  "node_modules/openai/lib/chatCompletionUtils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isToolMessage = exports.isAssistantMessage = void 0;
    exports.isPresent = isPresent;
    var isAssistantMessage = (message) => {
      return (message == null ? void 0 : message.role) === "assistant";
    };
    exports.isAssistantMessage = isAssistantMessage;
    var isToolMessage = (message) => {
      return (message == null ? void 0 : message.role) === "tool";
    };
    exports.isToolMessage = isToolMessage;
    function isPresent(obj) {
      return obj != null;
    }
  }
});

// node_modules/openai/lib/EventStream.js
var require_EventStream = __commonJS({
  "node_modules/openai/lib/EventStream.js"(exports) {
    "use strict";
    var _EventStream_instances;
    var _EventStream_connectedPromise;
    var _EventStream_resolveConnectedPromise;
    var _EventStream_rejectConnectedPromise;
    var _EventStream_endPromise;
    var _EventStream_resolveEndPromise;
    var _EventStream_rejectEndPromise;
    var _EventStream_listeners;
    var _EventStream_ended;
    var _EventStream_errored;
    var _EventStream_aborted;
    var _EventStream_catchingPromiseCreated;
    var _EventStream_handleError;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EventStream = void 0;
    var tslib_1 = require_tslib();
    var error_1 = require_error2();
    var EventStream = class {
      constructor() {
        _EventStream_instances.add(this);
        this.controller = new AbortController();
        _EventStream_connectedPromise.set(this, void 0);
        _EventStream_resolveConnectedPromise.set(this, () => {
        });
        _EventStream_rejectConnectedPromise.set(this, () => {
        });
        _EventStream_endPromise.set(this, void 0);
        _EventStream_resolveEndPromise.set(this, () => {
        });
        _EventStream_rejectEndPromise.set(this, () => {
        });
        _EventStream_listeners.set(this, {});
        _EventStream_ended.set(this, false);
        _EventStream_errored.set(this, false);
        _EventStream_aborted.set(this, false);
        _EventStream_catchingPromiseCreated.set(this, false);
        tslib_1.__classPrivateFieldSet(this, _EventStream_connectedPromise, new Promise((resolve, reject) => {
          tslib_1.__classPrivateFieldSet(this, _EventStream_resolveConnectedPromise, resolve, "f");
          tslib_1.__classPrivateFieldSet(this, _EventStream_rejectConnectedPromise, reject, "f");
        }), "f");
        tslib_1.__classPrivateFieldSet(this, _EventStream_endPromise, new Promise((resolve, reject) => {
          tslib_1.__classPrivateFieldSet(this, _EventStream_resolveEndPromise, resolve, "f");
          tslib_1.__classPrivateFieldSet(this, _EventStream_rejectEndPromise, reject, "f");
        }), "f");
        tslib_1.__classPrivateFieldGet(this, _EventStream_connectedPromise, "f").catch(() => {
        });
        tslib_1.__classPrivateFieldGet(this, _EventStream_endPromise, "f").catch(() => {
        });
      }
      _run(executor) {
        setTimeout(() => {
          executor().then(() => {
            this._emitFinal();
            this._emit("end");
          }, tslib_1.__classPrivateFieldGet(this, _EventStream_instances, "m", _EventStream_handleError).bind(this));
        }, 0);
      }
      _connected() {
        if (this.ended)
          return;
        tslib_1.__classPrivateFieldGet(this, _EventStream_resolveConnectedPromise, "f").call(this);
        this._emit("connect");
      }
      get ended() {
        return tslib_1.__classPrivateFieldGet(this, _EventStream_ended, "f");
      }
      get errored() {
        return tslib_1.__classPrivateFieldGet(this, _EventStream_errored, "f");
      }
      get aborted() {
        return tslib_1.__classPrivateFieldGet(this, _EventStream_aborted, "f");
      }
      abort() {
        this.controller.abort();
      }
      /**
       * Adds the listener function to the end of the listeners array for the event.
       * No checks are made to see if the listener has already been added. Multiple calls passing
       * the same combination of event and listener will result in the listener being added, and
       * called, multiple times.
       * @returns this ChatCompletionStream, so that calls can be chained
       */
      on(event, listener) {
        const listeners = tslib_1.__classPrivateFieldGet(this, _EventStream_listeners, "f")[event] || (tslib_1.__classPrivateFieldGet(this, _EventStream_listeners, "f")[event] = []);
        listeners.push({ listener });
        return this;
      }
      /**
       * Removes the specified listener from the listener array for the event.
       * off() will remove, at most, one instance of a listener from the listener array. If any single
       * listener has been added multiple times to the listener array for the specified event, then
       * off() must be called multiple times to remove each instance.
       * @returns this ChatCompletionStream, so that calls can be chained
       */
      off(event, listener) {
        const listeners = tslib_1.__classPrivateFieldGet(this, _EventStream_listeners, "f")[event];
        if (!listeners)
          return this;
        const index = listeners.findIndex((l) => l.listener === listener);
        if (index >= 0)
          listeners.splice(index, 1);
        return this;
      }
      /**
       * Adds a one-time listener function for the event. The next time the event is triggered,
       * this listener is removed and then invoked.
       * @returns this ChatCompletionStream, so that calls can be chained
       */
      once(event, listener) {
        const listeners = tslib_1.__classPrivateFieldGet(this, _EventStream_listeners, "f")[event] || (tslib_1.__classPrivateFieldGet(this, _EventStream_listeners, "f")[event] = []);
        listeners.push({ listener, once: true });
        return this;
      }
      /**
       * This is similar to `.once()`, but returns a Promise that resolves the next time
       * the event is triggered, instead of calling a listener callback.
       * @returns a Promise that resolves the next time given event is triggered,
       * or rejects if an error is emitted.  (If you request the 'error' event,
       * returns a promise that resolves with the error).
       *
       * Example:
       *
       *   const message = await stream.emitted('message') // rejects if the stream errors
       */
      emitted(event) {
        return new Promise((resolve, reject) => {
          tslib_1.__classPrivateFieldSet(this, _EventStream_catchingPromiseCreated, true, "f");
          if (event !== "error")
            this.once("error", reject);
          this.once(event, resolve);
        });
      }
      async done() {
        tslib_1.__classPrivateFieldSet(this, _EventStream_catchingPromiseCreated, true, "f");
        await tslib_1.__classPrivateFieldGet(this, _EventStream_endPromise, "f");
      }
      _emit(event, ...args) {
        if (tslib_1.__classPrivateFieldGet(this, _EventStream_ended, "f")) {
          return;
        }
        if (event === "end") {
          tslib_1.__classPrivateFieldSet(this, _EventStream_ended, true, "f");
          tslib_1.__classPrivateFieldGet(this, _EventStream_resolveEndPromise, "f").call(this);
        }
        const listeners = tslib_1.__classPrivateFieldGet(this, _EventStream_listeners, "f")[event];
        if (listeners) {
          tslib_1.__classPrivateFieldGet(this, _EventStream_listeners, "f")[event] = listeners.filter((l) => !l.once);
          listeners.forEach(({ listener }) => listener(...args));
        }
        if (event === "abort") {
          const error = args[0];
          if (!tslib_1.__classPrivateFieldGet(this, _EventStream_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
            Promise.reject(error);
          }
          tslib_1.__classPrivateFieldGet(this, _EventStream_rejectConnectedPromise, "f").call(this, error);
          tslib_1.__classPrivateFieldGet(this, _EventStream_rejectEndPromise, "f").call(this, error);
          this._emit("end");
          return;
        }
        if (event === "error") {
          const error = args[0];
          if (!tslib_1.__classPrivateFieldGet(this, _EventStream_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
            Promise.reject(error);
          }
          tslib_1.__classPrivateFieldGet(this, _EventStream_rejectConnectedPromise, "f").call(this, error);
          tslib_1.__classPrivateFieldGet(this, _EventStream_rejectEndPromise, "f").call(this, error);
          this._emit("end");
        }
      }
      _emitFinal() {
      }
    };
    exports.EventStream = EventStream;
    _EventStream_connectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_resolveConnectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_rejectConnectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_endPromise = /* @__PURE__ */ new WeakMap(), _EventStream_resolveEndPromise = /* @__PURE__ */ new WeakMap(), _EventStream_rejectEndPromise = /* @__PURE__ */ new WeakMap(), _EventStream_listeners = /* @__PURE__ */ new WeakMap(), _EventStream_ended = /* @__PURE__ */ new WeakMap(), _EventStream_errored = /* @__PURE__ */ new WeakMap(), _EventStream_aborted = /* @__PURE__ */ new WeakMap(), _EventStream_catchingPromiseCreated = /* @__PURE__ */ new WeakMap(), _EventStream_instances = /* @__PURE__ */ new WeakSet(), _EventStream_handleError = function _EventStream_handleError2(error) {
      tslib_1.__classPrivateFieldSet(this, _EventStream_errored, true, "f");
      if (error instanceof Error && error.name === "AbortError") {
        error = new error_1.APIUserAbortError();
      }
      if (error instanceof error_1.APIUserAbortError) {
        tslib_1.__classPrivateFieldSet(this, _EventStream_aborted, true, "f");
        return this._emit("abort", error);
      }
      if (error instanceof error_1.OpenAIError) {
        return this._emit("error", error);
      }
      if (error instanceof Error) {
        const openAIError = new error_1.OpenAIError(error.message);
        openAIError.cause = error;
        return this._emit("error", openAIError);
      }
      return this._emit("error", new error_1.OpenAIError(String(error)));
    };
  }
});

// node_modules/openai/lib/RunnableFunction.js
var require_RunnableFunction = __commonJS({
  "node_modules/openai/lib/RunnableFunction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParsingToolFunction = void 0;
    exports.isRunnableFunctionWithParse = isRunnableFunctionWithParse;
    function isRunnableFunctionWithParse(fn) {
      return typeof fn.parse === "function";
    }
    var ParsingToolFunction = class {
      constructor(input) {
        this.type = "function";
        this.function = input;
      }
    };
    exports.ParsingToolFunction = ParsingToolFunction;
  }
});

// node_modules/openai/lib/AbstractChatCompletionRunner.js
var require_AbstractChatCompletionRunner = __commonJS({
  "node_modules/openai/lib/AbstractChatCompletionRunner.js"(exports) {
    "use strict";
    var _AbstractChatCompletionRunner_instances;
    var _AbstractChatCompletionRunner_getFinalContent;
    var _AbstractChatCompletionRunner_getFinalMessage;
    var _AbstractChatCompletionRunner_getFinalFunctionToolCall;
    var _AbstractChatCompletionRunner_getFinalFunctionToolCallResult;
    var _AbstractChatCompletionRunner_calculateTotalUsage;
    var _AbstractChatCompletionRunner_validateParams;
    var _AbstractChatCompletionRunner_stringifyFunctionCallResult;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AbstractChatCompletionRunner = void 0;
    var tslib_1 = require_tslib();
    var error_1 = require_error2();
    var parser_1 = require_parser();
    var chatCompletionUtils_1 = require_chatCompletionUtils();
    var EventStream_1 = require_EventStream();
    var RunnableFunction_1 = require_RunnableFunction();
    var DEFAULT_MAX_CHAT_COMPLETIONS = 10;
    var AbstractChatCompletionRunner = class extends EventStream_1.EventStream {
      constructor() {
        super(...arguments);
        _AbstractChatCompletionRunner_instances.add(this);
        this._chatCompletions = [];
        this.messages = [];
      }
      _addChatCompletion(chatCompletion) {
        var _a;
        this._chatCompletions.push(chatCompletion);
        this._emit("chatCompletion", chatCompletion);
        const message = (_a = chatCompletion.choices[0]) == null ? void 0 : _a.message;
        if (message)
          this._addMessage(message);
        return chatCompletion;
      }
      _addMessage(message, emit = true) {
        if (!("content" in message))
          message.content = null;
        this.messages.push(message);
        if (emit) {
          this._emit("message", message);
          if ((0, chatCompletionUtils_1.isToolMessage)(message) && message.content) {
            this._emit("functionToolCallResult", message.content);
          } else if ((0, chatCompletionUtils_1.isAssistantMessage)(message) && message.tool_calls) {
            for (const tool_call of message.tool_calls) {
              if (tool_call.type === "function") {
                this._emit("functionToolCall", tool_call.function);
              }
            }
          }
        }
      }
      /**
       * @returns a promise that resolves with the final ChatCompletion, or rejects
       * if an error occurred or the stream ended prematurely without producing a ChatCompletion.
       */
      async finalChatCompletion() {
        await this.done();
        const completion = this._chatCompletions[this._chatCompletions.length - 1];
        if (!completion)
          throw new error_1.OpenAIError("stream ended without producing a ChatCompletion");
        return completion;
      }
      /**
       * @returns a promise that resolves with the content of the final ChatCompletionMessage, or rejects
       * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
       */
      async finalContent() {
        await this.done();
        return tslib_1.__classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
      }
      /**
       * @returns a promise that resolves with the the final assistant ChatCompletionMessage response,
       * or rejects if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
       */
      async finalMessage() {
        await this.done();
        return tslib_1.__classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
      }
      /**
       * @returns a promise that resolves with the content of the final FunctionCall, or rejects
       * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
       */
      async finalFunctionToolCall() {
        await this.done();
        return tslib_1.__classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionToolCall).call(this);
      }
      async finalFunctionToolCallResult() {
        await this.done();
        return tslib_1.__classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionToolCallResult).call(this);
      }
      async totalUsage() {
        await this.done();
        return tslib_1.__classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this);
      }
      allChatCompletions() {
        return [...this._chatCompletions];
      }
      _emitFinal() {
        const completion = this._chatCompletions[this._chatCompletions.length - 1];
        if (completion)
          this._emit("finalChatCompletion", completion);
        const finalMessage = tslib_1.__classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
        if (finalMessage)
          this._emit("finalMessage", finalMessage);
        const finalContent = tslib_1.__classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
        if (finalContent)
          this._emit("finalContent", finalContent);
        const finalFunctionCall = tslib_1.__classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionToolCall).call(this);
        if (finalFunctionCall)
          this._emit("finalFunctionToolCall", finalFunctionCall);
        const finalFunctionCallResult = tslib_1.__classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionToolCallResult).call(this);
        if (finalFunctionCallResult != null)
          this._emit("finalFunctionToolCallResult", finalFunctionCallResult);
        if (this._chatCompletions.some((c) => c.usage)) {
          this._emit("totalUsage", tslib_1.__classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this));
        }
      }
      async _createChatCompletion(client, params, options) {
        const signal = options == null ? void 0 : options.signal;
        if (signal) {
          if (signal.aborted)
            this.controller.abort();
          signal.addEventListener("abort", () => this.controller.abort());
        }
        tslib_1.__classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_validateParams).call(this, params);
        const chatCompletion = await client.chat.completions.create({ ...params, stream: false }, { ...options, signal: this.controller.signal });
        this._connected();
        return this._addChatCompletion((0, parser_1.parseChatCompletion)(chatCompletion, params));
      }
      async _runChatCompletion(client, params, options) {
        for (const message of params.messages) {
          this._addMessage(message, false);
        }
        return await this._createChatCompletion(client, params, options);
      }
      async _runTools(client, params, options) {
        var _a, _b, _c;
        const role = "tool";
        const { tool_choice = "auto", stream, ...restParams } = params;
        const singleFunctionToCall = typeof tool_choice !== "string" && tool_choice.type === "function" && ((_a = tool_choice == null ? void 0 : tool_choice.function) == null ? void 0 : _a.name);
        const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};
        const inputTools = params.tools.map((tool) => {
          if ((0, parser_1.isAutoParsableTool)(tool)) {
            if (!tool.$callback) {
              throw new error_1.OpenAIError("Tool given to `.runTools()` that does not have an associated function");
            }
            return {
              type: "function",
              function: {
                function: tool.$callback,
                name: tool.function.name,
                description: tool.function.description || "",
                parameters: tool.function.parameters,
                parse: tool.$parseRaw,
                strict: true
              }
            };
          }
          return tool;
        });
        const functionsByName = {};
        for (const f of inputTools) {
          if (f.type === "function") {
            functionsByName[f.function.name || f.function.function.name] = f.function;
          }
        }
        const tools = "tools" in params ? inputTools.map((t) => t.type === "function" ? {
          type: "function",
          function: {
            name: t.function.name || t.function.function.name,
            parameters: t.function.parameters,
            description: t.function.description,
            strict: t.function.strict
          }
        } : t) : void 0;
        for (const message of params.messages) {
          this._addMessage(message, false);
        }
        for (let i = 0; i < maxChatCompletions; ++i) {
          const chatCompletion = await this._createChatCompletion(client, {
            ...restParams,
            tool_choice,
            tools,
            messages: [...this.messages]
          }, options);
          const message = (_b = chatCompletion.choices[0]) == null ? void 0 : _b.message;
          if (!message) {
            throw new error_1.OpenAIError(`missing message in ChatCompletion response`);
          }
          if (!((_c = message.tool_calls) == null ? void 0 : _c.length)) {
            return;
          }
          for (const tool_call of message.tool_calls) {
            if (tool_call.type !== "function")
              continue;
            const tool_call_id = tool_call.id;
            const { name, arguments: args } = tool_call.function;
            const fn = functionsByName[name];
            if (!fn) {
              const content2 = `Invalid tool_call: ${JSON.stringify(name)}. Available options are: ${Object.keys(functionsByName).map((name2) => JSON.stringify(name2)).join(", ")}. Please try again`;
              this._addMessage({ role, tool_call_id, content: content2 });
              continue;
            } else if (singleFunctionToCall && singleFunctionToCall !== name) {
              const content2 = `Invalid tool_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;
              this._addMessage({ role, tool_call_id, content: content2 });
              continue;
            }
            let parsed;
            try {
              parsed = (0, RunnableFunction_1.isRunnableFunctionWithParse)(fn) ? await fn.parse(args) : args;
            } catch (error) {
              const content2 = error instanceof Error ? error.message : String(error);
              this._addMessage({ role, tool_call_id, content: content2 });
              continue;
            }
            const rawContent = await fn.function(parsed, this);
            const content = tslib_1.__classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);
            this._addMessage({ role, tool_call_id, content });
            if (singleFunctionToCall) {
              return;
            }
          }
        }
        return;
      }
    };
    exports.AbstractChatCompletionRunner = AbstractChatCompletionRunner;
    _AbstractChatCompletionRunner_instances = /* @__PURE__ */ new WeakSet(), _AbstractChatCompletionRunner_getFinalContent = function _AbstractChatCompletionRunner_getFinalContent2() {
      return tslib_1.__classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this).content ?? null;
    }, _AbstractChatCompletionRunner_getFinalMessage = function _AbstractChatCompletionRunner_getFinalMessage2() {
      let i = this.messages.length;
      while (i-- > 0) {
        const message = this.messages[i];
        if ((0, chatCompletionUtils_1.isAssistantMessage)(message)) {
          const ret = {
            ...message,
            content: message.content ?? null,
            refusal: message.refusal ?? null
          };
          return ret;
        }
      }
      throw new error_1.OpenAIError("stream ended without producing a ChatCompletionMessage with role=assistant");
    }, _AbstractChatCompletionRunner_getFinalFunctionToolCall = function _AbstractChatCompletionRunner_getFinalFunctionToolCall2() {
      var _a, _b;
      for (let i = this.messages.length - 1; i >= 0; i--) {
        const message = this.messages[i];
        if ((0, chatCompletionUtils_1.isAssistantMessage)(message) && ((_a = message == null ? void 0 : message.tool_calls) == null ? void 0 : _a.length)) {
          return (_b = message.tool_calls.filter((x) => x.type === "function").at(-1)) == null ? void 0 : _b.function;
        }
      }
      return;
    }, _AbstractChatCompletionRunner_getFinalFunctionToolCallResult = function _AbstractChatCompletionRunner_getFinalFunctionToolCallResult2() {
      for (let i = this.messages.length - 1; i >= 0; i--) {
        const message = this.messages[i];
        if ((0, chatCompletionUtils_1.isToolMessage)(message) && message.content != null && typeof message.content === "string" && this.messages.some((x) => {
          var _a;
          return x.role === "assistant" && ((_a = x.tool_calls) == null ? void 0 : _a.some((y) => y.type === "function" && y.id === message.tool_call_id));
        })) {
          return message.content;
        }
      }
      return;
    }, _AbstractChatCompletionRunner_calculateTotalUsage = function _AbstractChatCompletionRunner_calculateTotalUsage2() {
      const total = {
        completion_tokens: 0,
        prompt_tokens: 0,
        total_tokens: 0
      };
      for (const { usage } of this._chatCompletions) {
        if (usage) {
          total.completion_tokens += usage.completion_tokens;
          total.prompt_tokens += usage.prompt_tokens;
          total.total_tokens += usage.total_tokens;
        }
      }
      return total;
    }, _AbstractChatCompletionRunner_validateParams = function _AbstractChatCompletionRunner_validateParams2(params) {
      if (params.n != null && params.n > 1) {
        throw new error_1.OpenAIError("ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.");
      }
    }, _AbstractChatCompletionRunner_stringifyFunctionCallResult = function _AbstractChatCompletionRunner_stringifyFunctionCallResult2(rawContent) {
      return typeof rawContent === "string" ? rawContent : rawContent === void 0 ? "undefined" : JSON.stringify(rawContent);
    };
  }
});

// node_modules/openai/lib/ChatCompletionRunner.js
var require_ChatCompletionRunner = __commonJS({
  "node_modules/openai/lib/ChatCompletionRunner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ChatCompletionRunner = void 0;
    var AbstractChatCompletionRunner_1 = require_AbstractChatCompletionRunner();
    var chatCompletionUtils_1 = require_chatCompletionUtils();
    var ChatCompletionRunner = class _ChatCompletionRunner extends AbstractChatCompletionRunner_1.AbstractChatCompletionRunner {
      static runTools(client, params, options) {
        const runner = new _ChatCompletionRunner();
        const opts = {
          ...options,
          headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "runTools" }
        };
        runner._run(() => runner._runTools(client, params, opts));
        return runner;
      }
      _addMessage(message, emit = true) {
        super._addMessage(message, emit);
        if ((0, chatCompletionUtils_1.isAssistantMessage)(message) && message.content) {
          this._emit("content", message.content);
        }
      }
    };
    exports.ChatCompletionRunner = ChatCompletionRunner;
  }
});

// node_modules/openai/_vendor/partial-json-parser/parser.js
var require_parser2 = __commonJS({
  "node_modules/openai/_vendor/partial-json-parser/parser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MalformedJSON = exports.PartialJSON = exports.partialParse = void 0;
    var STR = 1;
    var NUM = 2;
    var ARR = 4;
    var OBJ = 8;
    var NULL = 16;
    var BOOL = 32;
    var NAN = 64;
    var INFINITY = 128;
    var MINUS_INFINITY = 256;
    var INF = INFINITY | MINUS_INFINITY;
    var SPECIAL = NULL | BOOL | INF | NAN;
    var ATOM = STR | NUM | SPECIAL;
    var COLLECTION = ARR | OBJ;
    var ALL = ATOM | COLLECTION;
    var Allow = {
      STR,
      NUM,
      ARR,
      OBJ,
      NULL,
      BOOL,
      NAN,
      INFINITY,
      MINUS_INFINITY,
      INF,
      SPECIAL,
      ATOM,
      COLLECTION,
      ALL
    };
    var PartialJSON = class extends Error {
    };
    exports.PartialJSON = PartialJSON;
    var MalformedJSON = class extends Error {
    };
    exports.MalformedJSON = MalformedJSON;
    function parseJSON(jsonString, allowPartial = Allow.ALL) {
      if (typeof jsonString !== "string") {
        throw new TypeError(`expecting str, got ${typeof jsonString}`);
      }
      if (!jsonString.trim()) {
        throw new Error(`${jsonString} is empty`);
      }
      return _parseJSON(jsonString.trim(), allowPartial);
    }
    var _parseJSON = (jsonString, allow) => {
      const length = jsonString.length;
      let index = 0;
      const markPartialJSON = (msg) => {
        throw new PartialJSON(`${msg} at position ${index}`);
      };
      const throwMalformedError = (msg) => {
        throw new MalformedJSON(`${msg} at position ${index}`);
      };
      const parseAny = () => {
        skipBlank();
        if (index >= length)
          markPartialJSON("Unexpected end of input");
        if (jsonString[index] === '"')
          return parseStr();
        if (jsonString[index] === "{")
          return parseObj();
        if (jsonString[index] === "[")
          return parseArr();
        if (jsonString.substring(index, index + 4) === "null" || Allow.NULL & allow && length - index < 4 && "null".startsWith(jsonString.substring(index))) {
          index += 4;
          return null;
        }
        if (jsonString.substring(index, index + 4) === "true" || Allow.BOOL & allow && length - index < 4 && "true".startsWith(jsonString.substring(index))) {
          index += 4;
          return true;
        }
        if (jsonString.substring(index, index + 5) === "false" || Allow.BOOL & allow && length - index < 5 && "false".startsWith(jsonString.substring(index))) {
          index += 5;
          return false;
        }
        if (jsonString.substring(index, index + 8) === "Infinity" || Allow.INFINITY & allow && length - index < 8 && "Infinity".startsWith(jsonString.substring(index))) {
          index += 8;
          return Infinity;
        }
        if (jsonString.substring(index, index + 9) === "-Infinity" || Allow.MINUS_INFINITY & allow && 1 < length - index && length - index < 9 && "-Infinity".startsWith(jsonString.substring(index))) {
          index += 9;
          return -Infinity;
        }
        if (jsonString.substring(index, index + 3) === "NaN" || Allow.NAN & allow && length - index < 3 && "NaN".startsWith(jsonString.substring(index))) {
          index += 3;
          return NaN;
        }
        return parseNum();
      };
      const parseStr = () => {
        const start = index;
        let escape2 = false;
        index++;
        while (index < length && (jsonString[index] !== '"' || escape2 && jsonString[index - 1] === "\\")) {
          escape2 = jsonString[index] === "\\" ? !escape2 : false;
          index++;
        }
        if (jsonString.charAt(index) == '"') {
          try {
            return JSON.parse(jsonString.substring(start, ++index - Number(escape2)));
          } catch (e) {
            throwMalformedError(String(e));
          }
        } else if (Allow.STR & allow) {
          try {
            return JSON.parse(jsonString.substring(start, index - Number(escape2)) + '"');
          } catch (e) {
            return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf("\\")) + '"');
          }
        }
        markPartialJSON("Unterminated string literal");
      };
      const parseObj = () => {
        index++;
        skipBlank();
        const obj = {};
        try {
          while (jsonString[index] !== "}") {
            skipBlank();
            if (index >= length && Allow.OBJ & allow)
              return obj;
            const key = parseStr();
            skipBlank();
            index++;
            try {
              const value = parseAny();
              Object.defineProperty(obj, key, { value, writable: true, enumerable: true, configurable: true });
            } catch (e) {
              if (Allow.OBJ & allow)
                return obj;
              else
                throw e;
            }
            skipBlank();
            if (jsonString[index] === ",")
              index++;
          }
        } catch (e) {
          if (Allow.OBJ & allow)
            return obj;
          else
            markPartialJSON("Expected '}' at end of object");
        }
        index++;
        return obj;
      };
      const parseArr = () => {
        index++;
        const arr = [];
        try {
          while (jsonString[index] !== "]") {
            arr.push(parseAny());
            skipBlank();
            if (jsonString[index] === ",") {
              index++;
            }
          }
        } catch (e) {
          if (Allow.ARR & allow) {
            return arr;
          }
          markPartialJSON("Expected ']' at end of array");
        }
        index++;
        return arr;
      };
      const parseNum = () => {
        if (index === 0) {
          if (jsonString === "-" && Allow.NUM & allow)
            markPartialJSON("Not sure what '-' is");
          try {
            return JSON.parse(jsonString);
          } catch (e) {
            if (Allow.NUM & allow) {
              try {
                if ("." === jsonString[jsonString.length - 1])
                  return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf(".")));
                return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf("e")));
              } catch (e2) {
              }
            }
            throwMalformedError(String(e));
          }
        }
        const start = index;
        if (jsonString[index] === "-")
          index++;
        while (jsonString[index] && !",]}".includes(jsonString[index]))
          index++;
        if (index == length && !(Allow.NUM & allow))
          markPartialJSON("Unterminated number literal");
        try {
          return JSON.parse(jsonString.substring(start, index));
        } catch (e) {
          if (jsonString.substring(start, index) === "-" && Allow.NUM & allow)
            markPartialJSON("Not sure what '-' is");
          try {
            return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf("e")));
          } catch (e2) {
            throwMalformedError(String(e2));
          }
        }
      };
      const skipBlank = () => {
        while (index < length && " \n\r	".includes(jsonString[index])) {
          index++;
        }
      };
      return parseAny();
    };
    var partialParse = (input) => parseJSON(input, Allow.ALL ^ Allow.NUM);
    exports.partialParse = partialParse;
  }
});

// node_modules/openai/streaming.js
var require_streaming2 = __commonJS({
  "node_modules/openai/streaming.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    tslib_1.__exportStar(require_streaming(), exports);
  }
});

// node_modules/openai/lib/ChatCompletionStream.js
var require_ChatCompletionStream = __commonJS({
  "node_modules/openai/lib/ChatCompletionStream.js"(exports) {
    "use strict";
    var _ChatCompletionStream_instances;
    var _ChatCompletionStream_params;
    var _ChatCompletionStream_choiceEventStates;
    var _ChatCompletionStream_currentChatCompletionSnapshot;
    var _ChatCompletionStream_beginRequest;
    var _ChatCompletionStream_getChoiceEventState;
    var _ChatCompletionStream_addChunk;
    var _ChatCompletionStream_emitToolCallDoneEvent;
    var _ChatCompletionStream_emitContentDoneEvents;
    var _ChatCompletionStream_endRequest;
    var _ChatCompletionStream_getAutoParseableResponseFormat;
    var _ChatCompletionStream_accumulateChatCompletion;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ChatCompletionStream = void 0;
    var tslib_1 = require_tslib();
    var parser_1 = require_parser2();
    var error_1 = require_error2();
    var parser_2 = require_parser();
    var streaming_1 = require_streaming2();
    var AbstractChatCompletionRunner_1 = require_AbstractChatCompletionRunner();
    var ChatCompletionStream = class _ChatCompletionStream extends AbstractChatCompletionRunner_1.AbstractChatCompletionRunner {
      constructor(params) {
        super();
        _ChatCompletionStream_instances.add(this);
        _ChatCompletionStream_params.set(this, void 0);
        _ChatCompletionStream_choiceEventStates.set(this, void 0);
        _ChatCompletionStream_currentChatCompletionSnapshot.set(this, void 0);
        tslib_1.__classPrivateFieldSet(this, _ChatCompletionStream_params, params, "f");
        tslib_1.__classPrivateFieldSet(this, _ChatCompletionStream_choiceEventStates, [], "f");
      }
      get currentChatCompletionSnapshot() {
        return tslib_1.__classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
      }
      /**
       * Intended for use on the frontend, consuming a stream produced with
       * `.toReadableStream()` on the backend.
       *
       * Note that messages sent to the model do not appear in `.on('message')`
       * in this context.
       */
      static fromReadableStream(stream) {
        const runner = new _ChatCompletionStream(null);
        runner._run(() => runner._fromReadableStream(stream));
        return runner;
      }
      static createChatCompletion(client, params, options) {
        const runner = new _ChatCompletionStream(params);
        runner._run(() => runner._runChatCompletion(client, { ...params, stream: true }, { ...options, headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" } }));
        return runner;
      }
      async _createChatCompletion(client, params, options) {
        var _a;
        super._createChatCompletion;
        const signal = options == null ? void 0 : options.signal;
        if (signal) {
          if (signal.aborted)
            this.controller.abort();
          signal.addEventListener("abort", () => this.controller.abort());
        }
        tslib_1.__classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
        const stream = await client.chat.completions.create({ ...params, stream: true }, { ...options, signal: this.controller.signal });
        this._connected();
        for await (const chunk of stream) {
          tslib_1.__classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
        }
        if ((_a = stream.controller.signal) == null ? void 0 : _a.aborted) {
          throw new error_1.APIUserAbortError();
        }
        return this._addChatCompletion(tslib_1.__classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
      }
      async _fromReadableStream(readableStream, options) {
        var _a;
        const signal = options == null ? void 0 : options.signal;
        if (signal) {
          if (signal.aborted)
            this.controller.abort();
          signal.addEventListener("abort", () => this.controller.abort());
        }
        tslib_1.__classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
        this._connected();
        const stream = streaming_1.Stream.fromReadableStream(readableStream, this.controller);
        let chatId;
        for await (const chunk of stream) {
          if (chatId && chatId !== chunk.id) {
            this._addChatCompletion(tslib_1.__classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
          }
          tslib_1.__classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
          chatId = chunk.id;
        }
        if ((_a = stream.controller.signal) == null ? void 0 : _a.aborted) {
          throw new error_1.APIUserAbortError();
        }
        return this._addChatCompletion(tslib_1.__classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
      }
      [(_ChatCompletionStream_params = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_choiceEventStates = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_currentChatCompletionSnapshot = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_instances = /* @__PURE__ */ new WeakSet(), _ChatCompletionStream_beginRequest = function _ChatCompletionStream_beginRequest2() {
        if (this.ended)
          return;
        tslib_1.__classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, void 0, "f");
      }, _ChatCompletionStream_getChoiceEventState = function _ChatCompletionStream_getChoiceEventState2(choice) {
        let state = tslib_1.__classPrivateFieldGet(this, _ChatCompletionStream_choiceEventStates, "f")[choice.index];
        if (state) {
          return state;
        }
        state = {
          content_done: false,
          refusal_done: false,
          logprobs_content_done: false,
          logprobs_refusal_done: false,
          done_tool_calls: /* @__PURE__ */ new Set(),
          current_tool_call_index: null
        };
        tslib_1.__classPrivateFieldGet(this, _ChatCompletionStream_choiceEventStates, "f")[choice.index] = state;
        return state;
      }, _ChatCompletionStream_addChunk = function _ChatCompletionStream_addChunk2(chunk) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
        if (this.ended)
          return;
        const completion = tslib_1.__classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_accumulateChatCompletion).call(this, chunk);
        this._emit("chunk", chunk, completion);
        for (const choice of chunk.choices) {
          const choiceSnapshot = completion.choices[choice.index];
          if (choice.delta.content != null && ((_a = choiceSnapshot.message) == null ? void 0 : _a.role) === "assistant" && ((_b = choiceSnapshot.message) == null ? void 0 : _b.content)) {
            this._emit("content", choice.delta.content, choiceSnapshot.message.content);
            this._emit("content.delta", {
              delta: choice.delta.content,
              snapshot: choiceSnapshot.message.content,
              parsed: choiceSnapshot.message.parsed
            });
          }
          if (choice.delta.refusal != null && ((_c = choiceSnapshot.message) == null ? void 0 : _c.role) === "assistant" && ((_d = choiceSnapshot.message) == null ? void 0 : _d.refusal)) {
            this._emit("refusal.delta", {
              delta: choice.delta.refusal,
              snapshot: choiceSnapshot.message.refusal
            });
          }
          if (((_e = choice.logprobs) == null ? void 0 : _e.content) != null && ((_f = choiceSnapshot.message) == null ? void 0 : _f.role) === "assistant") {
            this._emit("logprobs.content.delta", {
              content: (_g = choice.logprobs) == null ? void 0 : _g.content,
              snapshot: ((_h = choiceSnapshot.logprobs) == null ? void 0 : _h.content) ?? []
            });
          }
          if (((_i = choice.logprobs) == null ? void 0 : _i.refusal) != null && ((_j = choiceSnapshot.message) == null ? void 0 : _j.role) === "assistant") {
            this._emit("logprobs.refusal.delta", {
              refusal: (_k = choice.logprobs) == null ? void 0 : _k.refusal,
              snapshot: ((_l = choiceSnapshot.logprobs) == null ? void 0 : _l.refusal) ?? []
            });
          }
          const state = tslib_1.__classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
          if (choiceSnapshot.finish_reason) {
            tslib_1.__classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);
            if (state.current_tool_call_index != null) {
              tslib_1.__classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);
            }
          }
          for (const toolCall of choice.delta.tool_calls ?? []) {
            if (state.current_tool_call_index !== toolCall.index) {
              tslib_1.__classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);
              if (state.current_tool_call_index != null) {
                tslib_1.__classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);
              }
            }
            state.current_tool_call_index = toolCall.index;
          }
          for (const toolCallDelta of choice.delta.tool_calls ?? []) {
            const toolCallSnapshot = (_m = choiceSnapshot.message.tool_calls) == null ? void 0 : _m[toolCallDelta.index];
            if (!(toolCallSnapshot == null ? void 0 : toolCallSnapshot.type)) {
              continue;
            }
            if ((toolCallSnapshot == null ? void 0 : toolCallSnapshot.type) === "function") {
              this._emit("tool_calls.function.arguments.delta", {
                name: (_n = toolCallSnapshot.function) == null ? void 0 : _n.name,
                index: toolCallDelta.index,
                arguments: toolCallSnapshot.function.arguments,
                parsed_arguments: toolCallSnapshot.function.parsed_arguments,
                arguments_delta: ((_o = toolCallDelta.function) == null ? void 0 : _o.arguments) ?? ""
              });
            } else {
              assertNever(toolCallSnapshot == null ? void 0 : toolCallSnapshot.type);
            }
          }
        }
      }, _ChatCompletionStream_emitToolCallDoneEvent = function _ChatCompletionStream_emitToolCallDoneEvent2(choiceSnapshot, toolCallIndex) {
        var _a, _b, _c;
        const state = tslib_1.__classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
        if (state.done_tool_calls.has(toolCallIndex)) {
          return;
        }
        const toolCallSnapshot = (_a = choiceSnapshot.message.tool_calls) == null ? void 0 : _a[toolCallIndex];
        if (!toolCallSnapshot) {
          throw new Error("no tool call snapshot");
        }
        if (!toolCallSnapshot.type) {
          throw new Error("tool call snapshot missing `type`");
        }
        if (toolCallSnapshot.type === "function") {
          const inputTool = (_c = (_b = tslib_1.__classPrivateFieldGet(this, _ChatCompletionStream_params, "f")) == null ? void 0 : _b.tools) == null ? void 0 : _c.find((tool) => (0, parser_2.isChatCompletionFunctionTool)(tool) && tool.function.name === toolCallSnapshot.function.name);
          this._emit("tool_calls.function.arguments.done", {
            name: toolCallSnapshot.function.name,
            index: toolCallIndex,
            arguments: toolCallSnapshot.function.arguments,
            parsed_arguments: (0, parser_2.isAutoParsableTool)(inputTool) ? inputTool.$parseRaw(toolCallSnapshot.function.arguments) : (inputTool == null ? void 0 : inputTool.function.strict) ? JSON.parse(toolCallSnapshot.function.arguments) : null
          });
        } else {
          assertNever(toolCallSnapshot.type);
        }
      }, _ChatCompletionStream_emitContentDoneEvents = function _ChatCompletionStream_emitContentDoneEvents2(choiceSnapshot) {
        var _a, _b;
        const state = tslib_1.__classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
        if (choiceSnapshot.message.content && !state.content_done) {
          state.content_done = true;
          const responseFormat = tslib_1.__classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getAutoParseableResponseFormat).call(this);
          this._emit("content.done", {
            content: choiceSnapshot.message.content,
            parsed: responseFormat ? responseFormat.$parseRaw(choiceSnapshot.message.content) : null
          });
        }
        if (choiceSnapshot.message.refusal && !state.refusal_done) {
          state.refusal_done = true;
          this._emit("refusal.done", { refusal: choiceSnapshot.message.refusal });
        }
        if (((_a = choiceSnapshot.logprobs) == null ? void 0 : _a.content) && !state.logprobs_content_done) {
          state.logprobs_content_done = true;
          this._emit("logprobs.content.done", { content: choiceSnapshot.logprobs.content });
        }
        if (((_b = choiceSnapshot.logprobs) == null ? void 0 : _b.refusal) && !state.logprobs_refusal_done) {
          state.logprobs_refusal_done = true;
          this._emit("logprobs.refusal.done", { refusal: choiceSnapshot.logprobs.refusal });
        }
      }, _ChatCompletionStream_endRequest = function _ChatCompletionStream_endRequest2() {
        if (this.ended) {
          throw new error_1.OpenAIError(`stream has ended, this shouldn't happen`);
        }
        const snapshot = tslib_1.__classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
        if (!snapshot) {
          throw new error_1.OpenAIError(`request ended without sending any chunks`);
        }
        tslib_1.__classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, void 0, "f");
        tslib_1.__classPrivateFieldSet(this, _ChatCompletionStream_choiceEventStates, [], "f");
        return finalizeChatCompletion(snapshot, tslib_1.__classPrivateFieldGet(this, _ChatCompletionStream_params, "f"));
      }, _ChatCompletionStream_getAutoParseableResponseFormat = function _ChatCompletionStream_getAutoParseableResponseFormat2() {
        var _a;
        const responseFormat = (_a = tslib_1.__classPrivateFieldGet(this, _ChatCompletionStream_params, "f")) == null ? void 0 : _a.response_format;
        if ((0, parser_2.isAutoParsableResponseFormat)(responseFormat)) {
          return responseFormat;
        }
        return null;
      }, _ChatCompletionStream_accumulateChatCompletion = function _ChatCompletionStream_accumulateChatCompletion2(chunk) {
        var _a, _b, _c, _d;
        let snapshot = tslib_1.__classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
        const { choices, ...rest } = chunk;
        if (!snapshot) {
          snapshot = tslib_1.__classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, {
            ...rest,
            choices: []
          }, "f");
        } else {
          Object.assign(snapshot, rest);
        }
        for (const { delta, finish_reason, index, logprobs = null, ...other } of chunk.choices) {
          let choice = snapshot.choices[index];
          if (!choice) {
            choice = snapshot.choices[index] = { finish_reason, index, message: {}, logprobs, ...other };
          }
          if (logprobs) {
            if (!choice.logprobs) {
              choice.logprobs = Object.assign({}, logprobs);
            } else {
              const { content: content2, refusal: refusal2, ...rest3 } = logprobs;
              assertIsEmpty(rest3);
              Object.assign(choice.logprobs, rest3);
              if (content2) {
                (_a = choice.logprobs).content ?? (_a.content = []);
                choice.logprobs.content.push(...content2);
              }
              if (refusal2) {
                (_b = choice.logprobs).refusal ?? (_b.refusal = []);
                choice.logprobs.refusal.push(...refusal2);
              }
            }
          }
          if (finish_reason) {
            choice.finish_reason = finish_reason;
            if (tslib_1.__classPrivateFieldGet(this, _ChatCompletionStream_params, "f") && (0, parser_2.hasAutoParseableInput)(tslib_1.__classPrivateFieldGet(this, _ChatCompletionStream_params, "f"))) {
              if (finish_reason === "length") {
                throw new error_1.LengthFinishReasonError();
              }
              if (finish_reason === "content_filter") {
                throw new error_1.ContentFilterFinishReasonError();
              }
            }
          }
          Object.assign(choice, other);
          if (!delta)
            continue;
          const { content, refusal, function_call, role, tool_calls, ...rest2 } = delta;
          assertIsEmpty(rest2);
          Object.assign(choice.message, rest2);
          if (refusal) {
            choice.message.refusal = (choice.message.refusal || "") + refusal;
          }
          if (role)
            choice.message.role = role;
          if (function_call) {
            if (!choice.message.function_call) {
              choice.message.function_call = function_call;
            } else {
              if (function_call.name)
                choice.message.function_call.name = function_call.name;
              if (function_call.arguments) {
                (_c = choice.message.function_call).arguments ?? (_c.arguments = "");
                choice.message.function_call.arguments += function_call.arguments;
              }
            }
          }
          if (content) {
            choice.message.content = (choice.message.content || "") + content;
            if (!choice.message.refusal && tslib_1.__classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getAutoParseableResponseFormat).call(this)) {
              choice.message.parsed = (0, parser_1.partialParse)(choice.message.content);
            }
          }
          if (tool_calls) {
            if (!choice.message.tool_calls)
              choice.message.tool_calls = [];
            for (const { index: index2, id, type, function: fn, ...rest3 } of tool_calls) {
              const tool_call = (_d = choice.message.tool_calls)[index2] ?? (_d[index2] = {});
              Object.assign(tool_call, rest3);
              if (id)
                tool_call.id = id;
              if (type)
                tool_call.type = type;
              if (fn)
                tool_call.function ?? (tool_call.function = { name: fn.name ?? "", arguments: "" });
              if (fn == null ? void 0 : fn.name)
                tool_call.function.name = fn.name;
              if (fn == null ? void 0 : fn.arguments) {
                tool_call.function.arguments += fn.arguments;
                if ((0, parser_2.shouldParseToolCall)(tslib_1.__classPrivateFieldGet(this, _ChatCompletionStream_params, "f"), tool_call)) {
                  tool_call.function.parsed_arguments = (0, parser_1.partialParse)(tool_call.function.arguments);
                }
              }
            }
          }
        }
        return snapshot;
      }, Symbol.asyncIterator)]() {
        const pushQueue = [];
        const readQueue = [];
        let done = false;
        this.on("chunk", (chunk) => {
          const reader = readQueue.shift();
          if (reader) {
            reader.resolve(chunk);
          } else {
            pushQueue.push(chunk);
          }
        });
        this.on("end", () => {
          done = true;
          for (const reader of readQueue) {
            reader.resolve(void 0);
          }
          readQueue.length = 0;
        });
        this.on("abort", (err) => {
          done = true;
          for (const reader of readQueue) {
            reader.reject(err);
          }
          readQueue.length = 0;
        });
        this.on("error", (err) => {
          done = true;
          for (const reader of readQueue) {
            reader.reject(err);
          }
          readQueue.length = 0;
        });
        return {
          next: async () => {
            if (!pushQueue.length) {
              if (done) {
                return { value: void 0, done: true };
              }
              return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
            }
            const chunk = pushQueue.shift();
            return { value: chunk, done: false };
          },
          return: async () => {
            this.abort();
            return { value: void 0, done: true };
          }
        };
      }
      toReadableStream() {
        const stream = new streaming_1.Stream(this[Symbol.asyncIterator].bind(this), this.controller);
        return stream.toReadableStream();
      }
    };
    exports.ChatCompletionStream = ChatCompletionStream;
    function finalizeChatCompletion(snapshot, params) {
      const { id, choices, created, model, system_fingerprint, ...rest } = snapshot;
      const completion = {
        ...rest,
        id,
        choices: choices.map(({ message, finish_reason, index, logprobs, ...choiceRest }) => {
          if (!finish_reason) {
            throw new error_1.OpenAIError(`missing finish_reason for choice ${index}`);
          }
          const { content = null, function_call, tool_calls, ...messageRest } = message;
          const role = message.role;
          if (!role) {
            throw new error_1.OpenAIError(`missing role for choice ${index}`);
          }
          if (function_call) {
            const { arguments: args, name } = function_call;
            if (args == null) {
              throw new error_1.OpenAIError(`missing function_call.arguments for choice ${index}`);
            }
            if (!name) {
              throw new error_1.OpenAIError(`missing function_call.name for choice ${index}`);
            }
            return {
              ...choiceRest,
              message: {
                content,
                function_call: { arguments: args, name },
                role,
                refusal: message.refusal ?? null
              },
              finish_reason,
              index,
              logprobs
            };
          }
          if (tool_calls) {
            return {
              ...choiceRest,
              index,
              finish_reason,
              logprobs,
              message: {
                ...messageRest,
                role,
                content,
                refusal: message.refusal ?? null,
                tool_calls: tool_calls.map((tool_call, i) => {
                  const { function: fn, type, id: id2, ...toolRest } = tool_call;
                  const { arguments: args, name, ...fnRest } = fn || {};
                  if (id2 == null) {
                    throw new error_1.OpenAIError(`missing choices[${index}].tool_calls[${i}].id
${str(snapshot)}`);
                  }
                  if (type == null) {
                    throw new error_1.OpenAIError(`missing choices[${index}].tool_calls[${i}].type
${str(snapshot)}`);
                  }
                  if (name == null) {
                    throw new error_1.OpenAIError(`missing choices[${index}].tool_calls[${i}].function.name
${str(snapshot)}`);
                  }
                  if (args == null) {
                    throw new error_1.OpenAIError(`missing choices[${index}].tool_calls[${i}].function.arguments
${str(snapshot)}`);
                  }
                  return { ...toolRest, id: id2, type, function: { ...fnRest, name, arguments: args } };
                })
              }
            };
          }
          return {
            ...choiceRest,
            message: { ...messageRest, content, role, refusal: message.refusal ?? null },
            finish_reason,
            index,
            logprobs
          };
        }),
        created,
        model,
        object: "chat.completion",
        ...system_fingerprint ? { system_fingerprint } : {}
      };
      return (0, parser_2.maybeParseChatCompletion)(completion, params);
    }
    function str(x) {
      return JSON.stringify(x);
    }
    function assertIsEmpty(obj) {
      return;
    }
    function assertNever(_x) {
    }
  }
});

// node_modules/openai/lib/ChatCompletionStreamingRunner.js
var require_ChatCompletionStreamingRunner = __commonJS({
  "node_modules/openai/lib/ChatCompletionStreamingRunner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ChatCompletionStreamingRunner = void 0;
    var ChatCompletionStream_1 = require_ChatCompletionStream();
    var ChatCompletionStreamingRunner = class _ChatCompletionStreamingRunner extends ChatCompletionStream_1.ChatCompletionStream {
      static fromReadableStream(stream) {
        const runner = new _ChatCompletionStreamingRunner(null);
        runner._run(() => runner._fromReadableStream(stream));
        return runner;
      }
      static runTools(client, params, options) {
        const runner = new _ChatCompletionStreamingRunner(
          // @ts-expect-error TODO these types are incompatible
          params
        );
        const opts = {
          ...options,
          headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "runTools" }
        };
        runner._run(() => runner._runTools(client, params, opts));
        return runner;
      }
    };
    exports.ChatCompletionStreamingRunner = ChatCompletionStreamingRunner;
  }
});

// node_modules/openai/resources/chat/completions/completions.js
var require_completions = __commonJS({
  "node_modules/openai/resources/chat/completions/completions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ChatCompletionRunner = exports.ChatCompletionStream = exports.ParsingToolFunction = exports.ChatCompletionStreamingRunner = exports.Completions = void 0;
    var tslib_1 = require_tslib();
    var resource_1 = require_resource();
    var MessagesAPI = tslib_1.__importStar(require_messages());
    var messages_1 = require_messages();
    var pagination_1 = require_pagination();
    var path_1 = require_path();
    var ChatCompletionRunner_1 = require_ChatCompletionRunner();
    var ChatCompletionStreamingRunner_1 = require_ChatCompletionStreamingRunner();
    var ChatCompletionStream_1 = require_ChatCompletionStream();
    var parser_1 = require_parser();
    var Completions = class extends resource_1.APIResource {
      constructor() {
        super(...arguments);
        this.messages = new MessagesAPI.Messages(this._client);
      }
      create(body, options) {
        return this._client.post("/chat/completions", { body, ...options, stream: body.stream ?? false });
      }
      /**
       * Get a stored chat completion. Only Chat Completions that have been created with
       * the `store` parameter set to `true` will be returned.
       *
       * @example
       * ```ts
       * const chatCompletion =
       *   await client.chat.completions.retrieve('completion_id');
       * ```
       */
      retrieve(completionID, options) {
        return this._client.get((0, path_1.path)`/chat/completions/${completionID}`, options);
      }
      /**
       * Modify a stored chat completion. Only Chat Completions that have been created
       * with the `store` parameter set to `true` can be modified. Currently, the only
       * supported modification is to update the `metadata` field.
       *
       * @example
       * ```ts
       * const chatCompletion = await client.chat.completions.update(
       *   'completion_id',
       *   { metadata: { foo: 'string' } },
       * );
       * ```
       */
      update(completionID, body, options) {
        return this._client.post((0, path_1.path)`/chat/completions/${completionID}`, { body, ...options });
      }
      /**
       * List stored Chat Completions. Only Chat Completions that have been stored with
       * the `store` parameter set to `true` will be returned.
       *
       * @example
       * ```ts
       * // Automatically fetches more pages as needed.
       * for await (const chatCompletion of client.chat.completions.list()) {
       *   // ...
       * }
       * ```
       */
      list(query = {}, options) {
        return this._client.getAPIList("/chat/completions", pagination_1.CursorPage, { query, ...options });
      }
      /**
       * Delete a stored chat completion. Only Chat Completions that have been created
       * with the `store` parameter set to `true` can be deleted.
       *
       * @example
       * ```ts
       * const chatCompletionDeleted =
       *   await client.chat.completions.delete('completion_id');
       * ```
       */
      delete(completionID, options) {
        return this._client.delete((0, path_1.path)`/chat/completions/${completionID}`, options);
      }
      parse(body, options) {
        (0, parser_1.validateInputTools)(body.tools);
        return this._client.chat.completions.create(body, {
          ...options,
          headers: {
            ...options == null ? void 0 : options.headers,
            "X-Stainless-Helper-Method": "chat.completions.parse"
          }
        })._thenUnwrap((completion) => (0, parser_1.parseChatCompletion)(completion, body));
      }
      runTools(body, options) {
        if (body.stream) {
          return ChatCompletionStreamingRunner_1.ChatCompletionStreamingRunner.runTools(this._client, body, options);
        }
        return ChatCompletionRunner_1.ChatCompletionRunner.runTools(this._client, body, options);
      }
      /**
       * Creates a chat completion stream
       */
      stream(body, options) {
        return ChatCompletionStream_1.ChatCompletionStream.createChatCompletion(this._client, body, options);
      }
    };
    exports.Completions = Completions;
    var ChatCompletionStreamingRunner_2 = require_ChatCompletionStreamingRunner();
    Object.defineProperty(exports, "ChatCompletionStreamingRunner", { enumerable: true, get: function() {
      return ChatCompletionStreamingRunner_2.ChatCompletionStreamingRunner;
    } });
    var RunnableFunction_1 = require_RunnableFunction();
    Object.defineProperty(exports, "ParsingToolFunction", { enumerable: true, get: function() {
      return RunnableFunction_1.ParsingToolFunction;
    } });
    var ChatCompletionStream_2 = require_ChatCompletionStream();
    Object.defineProperty(exports, "ChatCompletionStream", { enumerable: true, get: function() {
      return ChatCompletionStream_2.ChatCompletionStream;
    } });
    var ChatCompletionRunner_2 = require_ChatCompletionRunner();
    Object.defineProperty(exports, "ChatCompletionRunner", { enumerable: true, get: function() {
      return ChatCompletionRunner_2.ChatCompletionRunner;
    } });
    Completions.Messages = messages_1.Messages;
  }
});

// node_modules/openai/resources/chat/chat.js
var require_chat = __commonJS({
  "node_modules/openai/resources/chat/chat.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Chat = void 0;
    var tslib_1 = require_tslib();
    var resource_1 = require_resource();
    var CompletionsAPI = tslib_1.__importStar(require_completions());
    var completions_1 = require_completions();
    var Chat = class extends resource_1.APIResource {
      constructor() {
        super(...arguments);
        this.completions = new CompletionsAPI.Completions(this._client);
      }
    };
    exports.Chat = Chat;
    Chat.Completions = completions_1.Completions;
  }
});

// node_modules/openai/resources/chat/completions/index.js
var require_completions2 = __commonJS({
  "node_modules/openai/resources/chat/completions/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Messages = exports.Completions = void 0;
    var tslib_1 = require_tslib();
    var completions_1 = require_completions();
    Object.defineProperty(exports, "Completions", { enumerable: true, get: function() {
      return completions_1.Completions;
    } });
    tslib_1.__exportStar(require_completions(), exports);
    var messages_1 = require_messages();
    Object.defineProperty(exports, "Messages", { enumerable: true, get: function() {
      return messages_1.Messages;
    } });
  }
});

// node_modules/openai/resources/chat/index.js
var require_chat2 = __commonJS({
  "node_modules/openai/resources/chat/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Completions = exports.Chat = void 0;
    var chat_1 = require_chat();
    Object.defineProperty(exports, "Chat", { enumerable: true, get: function() {
      return chat_1.Chat;
    } });
    var index_1 = require_completions2();
    Object.defineProperty(exports, "Completions", { enumerable: true, get: function() {
      return index_1.Completions;
    } });
  }
});

// node_modules/openai/resources/shared.js
var require_shared = __commonJS({
  "node_modules/openai/resources/shared.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/openai/internal/headers.js
var require_headers = __commonJS({
  "node_modules/openai/internal/headers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isEmptyHeaders = exports.buildHeaders = void 0;
    var values_1 = require_values();
    var brand_privateNullableHeaders = Symbol("brand.privateNullableHeaders");
    function* iterateHeaders(headers) {
      if (!headers)
        return;
      if (brand_privateNullableHeaders in headers) {
        const { values, nulls } = headers;
        yield* values.entries();
        for (const name of nulls) {
          yield [name, null];
        }
        return;
      }
      let shouldClear = false;
      let iter;
      if (headers instanceof Headers) {
        iter = headers.entries();
      } else if ((0, values_1.isReadonlyArray)(headers)) {
        iter = headers;
      } else {
        shouldClear = true;
        iter = Object.entries(headers ?? {});
      }
      for (let row of iter) {
        const name = row[0];
        if (typeof name !== "string")
          throw new TypeError("expected header name to be a string");
        const values = (0, values_1.isReadonlyArray)(row[1]) ? row[1] : [row[1]];
        let didClear = false;
        for (const value of values) {
          if (value === void 0)
            continue;
          if (shouldClear && !didClear) {
            didClear = true;
            yield [name, null];
          }
          yield [name, value];
        }
      }
    }
    var buildHeaders = (newHeaders) => {
      const targetHeaders = new Headers();
      const nullHeaders = /* @__PURE__ */ new Set();
      for (const headers of newHeaders) {
        const seenHeaders = /* @__PURE__ */ new Set();
        for (const [name, value] of iterateHeaders(headers)) {
          const lowerName = name.toLowerCase();
          if (!seenHeaders.has(lowerName)) {
            targetHeaders.delete(name);
            seenHeaders.add(lowerName);
          }
          if (value === null) {
            targetHeaders.delete(name);
            nullHeaders.add(lowerName);
          } else {
            targetHeaders.append(name, value);
            nullHeaders.delete(lowerName);
          }
        }
      }
      return { [brand_privateNullableHeaders]: true, values: targetHeaders, nulls: nullHeaders };
    };
    exports.buildHeaders = buildHeaders;
    var isEmptyHeaders = (headers) => {
      for (const _ of iterateHeaders(headers))
        return false;
      return true;
    };
    exports.isEmptyHeaders = isEmptyHeaders;
  }
});

// node_modules/openai/resources/audio/speech.js
var require_speech = __commonJS({
  "node_modules/openai/resources/audio/speech.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Speech = void 0;
    var resource_1 = require_resource();
    var headers_1 = require_headers();
    var Speech = class extends resource_1.APIResource {
      /**
       * Generates audio from the input text.
       *
       * @example
       * ```ts
       * const speech = await client.audio.speech.create({
       *   input: 'input',
       *   model: 'string',
       *   voice: 'ash',
       * });
       *
       * const content = await speech.blob();
       * console.log(content);
       * ```
       */
      create(body, options) {
        return this._client.post("/audio/speech", {
          body,
          ...options,
          headers: (0, headers_1.buildHeaders)([{ Accept: "application/octet-stream" }, options == null ? void 0 : options.headers]),
          __binaryResponse: true
        });
      }
    };
    exports.Speech = Speech;
  }
});

// node_modules/openai/resources/audio/transcriptions.js
var require_transcriptions = __commonJS({
  "node_modules/openai/resources/audio/transcriptions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Transcriptions = void 0;
    var resource_1 = require_resource();
    var uploads_1 = require_uploads();
    var Transcriptions = class extends resource_1.APIResource {
      create(body, options) {
        return this._client.post("/audio/transcriptions", (0, uploads_1.multipartFormRequestOptions)({
          body,
          ...options,
          stream: body.stream ?? false,
          __metadata: { model: body.model }
        }, this._client));
      }
    };
    exports.Transcriptions = Transcriptions;
  }
});

// node_modules/openai/resources/audio/translations.js
var require_translations = __commonJS({
  "node_modules/openai/resources/audio/translations.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Translations = void 0;
    var resource_1 = require_resource();
    var uploads_1 = require_uploads();
    var Translations = class extends resource_1.APIResource {
      create(body, options) {
        return this._client.post("/audio/translations", (0, uploads_1.multipartFormRequestOptions)({ body, ...options, __metadata: { model: body.model } }, this._client));
      }
    };
    exports.Translations = Translations;
  }
});

// node_modules/openai/resources/audio/audio.js
var require_audio = __commonJS({
  "node_modules/openai/resources/audio/audio.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Audio = void 0;
    var tslib_1 = require_tslib();
    var resource_1 = require_resource();
    var SpeechAPI = tslib_1.__importStar(require_speech());
    var speech_1 = require_speech();
    var TranscriptionsAPI = tslib_1.__importStar(require_transcriptions());
    var transcriptions_1 = require_transcriptions();
    var TranslationsAPI = tslib_1.__importStar(require_translations());
    var translations_1 = require_translations();
    var Audio = class extends resource_1.APIResource {
      constructor() {
        super(...arguments);
        this.transcriptions = new TranscriptionsAPI.Transcriptions(this._client);
        this.translations = new TranslationsAPI.Translations(this._client);
        this.speech = new SpeechAPI.Speech(this._client);
      }
    };
    exports.Audio = Audio;
    Audio.Transcriptions = transcriptions_1.Transcriptions;
    Audio.Translations = translations_1.Translations;
    Audio.Speech = speech_1.Speech;
  }
});

// node_modules/openai/resources/batches.js
var require_batches = __commonJS({
  "node_modules/openai/resources/batches.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Batches = void 0;
    var resource_1 = require_resource();
    var pagination_1 = require_pagination();
    var path_1 = require_path();
    var Batches = class extends resource_1.APIResource {
      /**
       * Creates and executes a batch from an uploaded file of requests
       */
      create(body, options) {
        return this._client.post("/batches", { body, ...options });
      }
      /**
       * Retrieves a batch.
       */
      retrieve(batchID, options) {
        return this._client.get((0, path_1.path)`/batches/${batchID}`, options);
      }
      /**
       * List your organization's batches.
       */
      list(query = {}, options) {
        return this._client.getAPIList("/batches", pagination_1.CursorPage, { query, ...options });
      }
      /**
       * Cancels an in-progress batch. The batch will be in status `cancelling` for up to
       * 10 minutes, before changing to `cancelled`, where it will have partial results
       * (if any) available in the output file.
       */
      cancel(batchID, options) {
        return this._client.post((0, path_1.path)`/batches/${batchID}/cancel`, options);
      }
    };
    exports.Batches = Batches;
  }
});

// node_modules/openai/resources/beta/assistants.js
var require_assistants = __commonJS({
  "node_modules/openai/resources/beta/assistants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Assistants = void 0;
    var resource_1 = require_resource();
    var pagination_1 = require_pagination();
    var headers_1 = require_headers();
    var path_1 = require_path();
    var Assistants = class extends resource_1.APIResource {
      /**
       * Create an assistant with a model and instructions.
       *
       * @example
       * ```ts
       * const assistant = await client.beta.assistants.create({
       *   model: 'gpt-4o',
       * });
       * ```
       */
      create(body, options) {
        return this._client.post("/assistants", {
          body,
          ...options,
          headers: (0, headers_1.buildHeaders)([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
        });
      }
      /**
       * Retrieves an assistant.
       *
       * @example
       * ```ts
       * const assistant = await client.beta.assistants.retrieve(
       *   'assistant_id',
       * );
       * ```
       */
      retrieve(assistantID, options) {
        return this._client.get((0, path_1.path)`/assistants/${assistantID}`, {
          ...options,
          headers: (0, headers_1.buildHeaders)([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
        });
      }
      /**
       * Modifies an assistant.
       *
       * @example
       * ```ts
       * const assistant = await client.beta.assistants.update(
       *   'assistant_id',
       * );
       * ```
       */
      update(assistantID, body, options) {
        return this._client.post((0, path_1.path)`/assistants/${assistantID}`, {
          body,
          ...options,
          headers: (0, headers_1.buildHeaders)([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
        });
      }
      /**
       * Returns a list of assistants.
       *
       * @example
       * ```ts
       * // Automatically fetches more pages as needed.
       * for await (const assistant of client.beta.assistants.list()) {
       *   // ...
       * }
       * ```
       */
      list(query = {}, options) {
        return this._client.getAPIList("/assistants", pagination_1.CursorPage, {
          query,
          ...options,
          headers: (0, headers_1.buildHeaders)([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
        });
      }
      /**
       * Delete an assistant.
       *
       * @example
       * ```ts
       * const assistantDeleted =
       *   await client.beta.assistants.delete('assistant_id');
       * ```
       */
      delete(assistantID, options) {
        return this._client.delete((0, path_1.path)`/assistants/${assistantID}`, {
          ...options,
          headers: (0, headers_1.buildHeaders)([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
        });
      }
    };
    exports.Assistants = Assistants;
  }
});

// node_modules/openai/resources/beta/realtime/sessions.js
var require_sessions = __commonJS({
  "node_modules/openai/resources/beta/realtime/sessions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Sessions = void 0;
    var resource_1 = require_resource();
    var headers_1 = require_headers();
    var Sessions = class extends resource_1.APIResource {
      /**
       * Create an ephemeral API token for use in client-side applications with the
       * Realtime API. Can be configured with the same session parameters as the
       * `session.update` client event.
       *
       * It responds with a session object, plus a `client_secret` key which contains a
       * usable ephemeral API token that can be used to authenticate browser clients for
       * the Realtime API.
       *
       * @example
       * ```ts
       * const session =
       *   await client.beta.realtime.sessions.create();
       * ```
       */
      create(body, options) {
        return this._client.post("/realtime/sessions", {
          body,
          ...options,
          headers: (0, headers_1.buildHeaders)([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
        });
      }
    };
    exports.Sessions = Sessions;
  }
});

// node_modules/openai/resources/beta/realtime/transcription-sessions.js
var require_transcription_sessions = __commonJS({
  "node_modules/openai/resources/beta/realtime/transcription-sessions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TranscriptionSessions = void 0;
    var resource_1 = require_resource();
    var headers_1 = require_headers();
    var TranscriptionSessions = class extends resource_1.APIResource {
      /**
       * Create an ephemeral API token for use in client-side applications with the
       * Realtime API specifically for realtime transcriptions. Can be configured with
       * the same session parameters as the `transcription_session.update` client event.
       *
       * It responds with a session object, plus a `client_secret` key which contains a
       * usable ephemeral API token that can be used to authenticate browser clients for
       * the Realtime API.
       *
       * @example
       * ```ts
       * const transcriptionSession =
       *   await client.beta.realtime.transcriptionSessions.create();
       * ```
       */
      create(body, options) {
        return this._client.post("/realtime/transcription_sessions", {
          body,
          ...options,
          headers: (0, headers_1.buildHeaders)([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
        });
      }
    };
    exports.TranscriptionSessions = TranscriptionSessions;
  }
});

// node_modules/openai/resources/beta/realtime/realtime.js
var require_realtime = __commonJS({
  "node_modules/openai/resources/beta/realtime/realtime.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Realtime = void 0;
    var tslib_1 = require_tslib();
    var resource_1 = require_resource();
    var SessionsAPI = tslib_1.__importStar(require_sessions());
    var sessions_1 = require_sessions();
    var TranscriptionSessionsAPI = tslib_1.__importStar(require_transcription_sessions());
    var transcription_sessions_1 = require_transcription_sessions();
    var Realtime = class extends resource_1.APIResource {
      constructor() {
        super(...arguments);
        this.sessions = new SessionsAPI.Sessions(this._client);
        this.transcriptionSessions = new TranscriptionSessionsAPI.TranscriptionSessions(this._client);
      }
    };
    exports.Realtime = Realtime;
    Realtime.Sessions = sessions_1.Sessions;
    Realtime.TranscriptionSessions = transcription_sessions_1.TranscriptionSessions;
  }
});

// node_modules/openai/resources/beta/threads/messages.js
var require_messages2 = __commonJS({
  "node_modules/openai/resources/beta/threads/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Messages = void 0;
    var resource_1 = require_resource();
    var pagination_1 = require_pagination();
    var headers_1 = require_headers();
    var path_1 = require_path();
    var Messages = class extends resource_1.APIResource {
      /**
       * Create a message.
       *
       * @deprecated The Assistants API is deprecated in favor of the Responses API
       */
      create(threadID, body, options) {
        return this._client.post((0, path_1.path)`/threads/${threadID}/messages`, {
          body,
          ...options,
          headers: (0, headers_1.buildHeaders)([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
        });
      }
      /**
       * Retrieve a message.
       *
       * @deprecated The Assistants API is deprecated in favor of the Responses API
       */
      retrieve(messageID, params, options) {
        const { thread_id } = params;
        return this._client.get((0, path_1.path)`/threads/${thread_id}/messages/${messageID}`, {
          ...options,
          headers: (0, headers_1.buildHeaders)([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
        });
      }
      /**
       * Modifies a message.
       *
       * @deprecated The Assistants API is deprecated in favor of the Responses API
       */
      update(messageID, params, options) {
        const { thread_id, ...body } = params;
        return this._client.post((0, path_1.path)`/threads/${thread_id}/messages/${messageID}`, {
          body,
          ...options,
          headers: (0, headers_1.buildHeaders)([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
        });
      }
      /**
       * Returns a list of messages for a given thread.
       *
       * @deprecated The Assistants API is deprecated in favor of the Responses API
       */
      list(threadID, query = {}, options) {
        return this._client.getAPIList((0, path_1.path)`/threads/${threadID}/messages`, pagination_1.CursorPage, {
          query,
          ...options,
          headers: (0, headers_1.buildHeaders)([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
        });
      }
      /**
       * Deletes a message.
       *
       * @deprecated The Assistants API is deprecated in favor of the Responses API
       */
      delete(messageID, params, options) {
        const { thread_id } = params;
        return this._client.delete((0, path_1.path)`/threads/${thread_id}/messages/${messageID}`, {
          ...options,
          headers: (0, headers_1.buildHeaders)([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
        });
      }
    };
    exports.Messages = Messages;
  }
});

// node_modules/openai/resources/beta/threads/runs/steps.js
var require_steps = __commonJS({
  "node_modules/openai/resources/beta/threads/runs/steps.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Steps = void 0;
    var resource_1 = require_resource();
    var pagination_1 = require_pagination();
    var headers_1 = require_headers();
    var path_1 = require_path();
    var Steps = class extends resource_1.APIResource {
      /**
       * Retrieves a run step.
       *
       * @deprecated The Assistants API is deprecated in favor of the Responses API
       */
      retrieve(stepID, params, options) {
        const { thread_id, run_id, ...query } = params;
        return this._client.get((0, path_1.path)`/threads/${thread_id}/runs/${run_id}/steps/${stepID}`, {
          query,
          ...options,
          headers: (0, headers_1.buildHeaders)([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
        });
      }
      /**
       * Returns a list of run steps belonging to a run.
       *
       * @deprecated The Assistants API is deprecated in favor of the Responses API
       */
      list(runID, params, options) {
        const { thread_id, ...query } = params;
        return this._client.getAPIList((0, path_1.path)`/threads/${thread_id}/runs/${runID}/steps`, pagination_1.CursorPage, {
          query,
          ...options,
          headers: (0, headers_1.buildHeaders)([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
        });
      }
    };
    exports.Steps = Steps;
  }
});

// node_modules/openai/internal/utils/base64.js
var require_base64 = __commonJS({
  "node_modules/openai/internal/utils/base64.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toFloat32Array = exports.fromBase64 = exports.toBase64 = void 0;
    var error_1 = require_error();
    var bytes_1 = require_bytes();
    var toBase64 = (data) => {
      if (!data)
        return "";
      if (typeof globalThis.Buffer !== "undefined") {
        return globalThis.Buffer.from(data).toString("base64");
      }
      if (typeof data === "string") {
        data = (0, bytes_1.encodeUTF8)(data);
      }
      if (typeof btoa !== "undefined") {
        return btoa(String.fromCharCode.apply(null, data));
      }
      throw new error_1.OpenAIError("Cannot generate base64 string; Expected `Buffer` or `btoa` to be defined");
    };
    exports.toBase64 = toBase64;
    var fromBase64 = (str) => {
      if (typeof globalThis.Buffer !== "undefined") {
        const buf = globalThis.Buffer.from(str, "base64");
        return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
      }
      if (typeof atob !== "undefined") {
        const bstr = atob(str);
        const buf = new Uint8Array(bstr.length);
        for (let i = 0; i < bstr.length; i++) {
          buf[i] = bstr.charCodeAt(i);
        }
        return buf;
      }
      throw new error_1.OpenAIError("Cannot decode base64 string; Expected `Buffer` or `atob` to be defined");
    };
    exports.fromBase64 = fromBase64;
    var toFloat32Array = (base64Str) => {
      if (typeof Buffer !== "undefined") {
        const buf = Buffer.from(base64Str, "base64");
        return Array.from(new Float32Array(buf.buffer, buf.byteOffset, buf.length / Float32Array.BYTES_PER_ELEMENT));
      } else {
        const binaryStr = atob(base64Str);
        const len = binaryStr.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
          bytes[i] = binaryStr.charCodeAt(i);
        }
        return Array.from(new Float32Array(bytes.buffer));
      }
    };
    exports.toFloat32Array = toFloat32Array;
  }
});

// node_modules/openai/internal/utils/env.js
var require_env = __commonJS({
  "node_modules/openai/internal/utils/env.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.readEnv = void 0;
    var readEnv = (env) => {
      var _a, _b, _c, _d, _e;
      if (typeof globalThis.process !== "undefined") {
        return ((_b = (_a = globalThis.process.env) == null ? void 0 : _a[env]) == null ? void 0 : _b.trim()) ?? void 0;
      }
      if (typeof globalThis.Deno !== "undefined") {
        return (_e = (_d = (_c = globalThis.Deno.env) == null ? void 0 : _c.get) == null ? void 0 : _d.call(_c, env)) == null ? void 0 : _e.trim();
      }
      return void 0;
    };
    exports.readEnv = readEnv;
  }
});

// node_modules/openai/internal/utils.js
var require_utils2 = __commonJS({
  "node_modules/openai/internal/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    tslib_1.__exportStar(require_values(), exports);
    tslib_1.__exportStar(require_base64(), exports);
    tslib_1.__exportStar(require_env(), exports);
    tslib_1.__exportStar(require_log(), exports);
    tslib_1.__exportStar(require_uuid(), exports);
    tslib_1.__exportStar(require_sleep(), exports);
  }
});

// node_modules/openai/lib/AssistantStream.js
var require_AssistantStream = __commonJS({
  "node_modules/openai/lib/AssistantStream.js"(exports) {
    "use strict";
    var _AssistantStream_instances;
    var _a;
    var _AssistantStream_events;
    var _AssistantStream_runStepSnapshots;
    var _AssistantStream_messageSnapshots;
    var _AssistantStream_messageSnapshot;
    var _AssistantStream_finalRun;
    var _AssistantStream_currentContentIndex;
    var _AssistantStream_currentContent;
    var _AssistantStream_currentToolCallIndex;
    var _AssistantStream_currentToolCall;
    var _AssistantStream_currentEvent;
    var _AssistantStream_currentRunSnapshot;
    var _AssistantStream_currentRunStepSnapshot;
    var _AssistantStream_addEvent;
    var _AssistantStream_endRequest;
    var _AssistantStream_handleMessage;
    var _AssistantStream_handleRunStep;
    var _AssistantStream_handleEvent;
    var _AssistantStream_accumulateRunStep;
    var _AssistantStream_accumulateMessage;
    var _AssistantStream_accumulateContent;
    var _AssistantStream_handleRun;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AssistantStream = void 0;
    var tslib_1 = require_tslib();
    var streaming_1 = require_streaming2();
    var error_1 = require_error2();
    var EventStream_1 = require_EventStream();
    var utils_1 = require_utils2();
    var AssistantStream = class extends EventStream_1.EventStream {
      constructor() {
        super(...arguments);
        _AssistantStream_instances.add(this);
        _AssistantStream_events.set(this, []);
        _AssistantStream_runStepSnapshots.set(this, {});
        _AssistantStream_messageSnapshots.set(this, {});
        _AssistantStream_messageSnapshot.set(this, void 0);
        _AssistantStream_finalRun.set(this, void 0);
        _AssistantStream_currentContentIndex.set(this, void 0);
        _AssistantStream_currentContent.set(this, void 0);
        _AssistantStream_currentToolCallIndex.set(this, void 0);
        _AssistantStream_currentToolCall.set(this, void 0);
        _AssistantStream_currentEvent.set(this, void 0);
        _AssistantStream_currentRunSnapshot.set(this, void 0);
        _AssistantStream_currentRunStepSnapshot.set(this, void 0);
      }
      [(_AssistantStream_events = /* @__PURE__ */ new WeakMap(), _AssistantStream_runStepSnapshots = /* @__PURE__ */ new WeakMap(), _AssistantStream_messageSnapshots = /* @__PURE__ */ new WeakMap(), _AssistantStream_messageSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_finalRun = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentContentIndex = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentContent = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentToolCallIndex = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentToolCall = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentEvent = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentRunSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentRunStepSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_instances = /* @__PURE__ */ new WeakSet(), Symbol.asyncIterator)]() {
        const pushQueue = [];
        const readQueue = [];
        let done = false;
        this.on("event", (event) => {
          const reader = readQueue.shift();
          if (reader) {
            reader.resolve(event);
          } else {
            pushQueue.push(event);
          }
        });
        this.on("end", () => {
          done = true;
          for (const reader of readQueue) {
            reader.resolve(void 0);
          }
          readQueue.length = 0;
        });
        this.on("abort", (err) => {
          done = true;
          for (const reader of readQueue) {
            reader.reject(err);
          }
          readQueue.length = 0;
        });
        this.on("error", (err) => {
          done = true;
          for (const reader of readQueue) {
            reader.reject(err);
          }
          readQueue.length = 0;
        });
        return {
          next: async () => {
            if (!pushQueue.length) {
              if (done) {
                return { value: void 0, done: true };
              }
              return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
            }
            const chunk = pushQueue.shift();
            return { value: chunk, done: false };
          },
          return: async () => {
            this.abort();
            return { value: void 0, done: true };
          }
        };
      }
      static fromReadableStream(stream) {
        const runner = new _a();
        runner._run(() => runner._fromReadableStream(stream));
        return runner;
      }
      async _fromReadableStream(readableStream, options) {
        var _a2;
        const signal = options == null ? void 0 : options.signal;
        if (signal) {
          if (signal.aborted)
            this.controller.abort();
          signal.addEventListener("abort", () => this.controller.abort());
        }
        this._connected();
        const stream = streaming_1.Stream.fromReadableStream(readableStream, this.controller);
        for await (const event of stream) {
          tslib_1.__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
        }
        if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
          throw new error_1.APIUserAbortError();
        }
        return this._addRun(tslib_1.__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
      }
      toReadableStream() {
        const stream = new streaming_1.Stream(this[Symbol.asyncIterator].bind(this), this.controller);
        return stream.toReadableStream();
      }
      static createToolAssistantStream(runId, runs, params, options) {
        const runner = new _a();
        runner._run(() => runner._runToolAssistantStream(runId, runs, params, {
          ...options,
          headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" }
        }));
        return runner;
      }
      async _createToolAssistantStream(run, runId, params, options) {
        var _a2;
        const signal = options == null ? void 0 : options.signal;
        if (signal) {
          if (signal.aborted)
            this.controller.abort();
          signal.addEventListener("abort", () => this.controller.abort());
        }
        const body = { ...params, stream: true };
        const stream = await run.submitToolOutputs(runId, body, {
          ...options,
          signal: this.controller.signal
        });
        this._connected();
        for await (const event of stream) {
          tslib_1.__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
        }
        if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
          throw new error_1.APIUserAbortError();
        }
        return this._addRun(tslib_1.__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
      }
      static createThreadAssistantStream(params, thread, options) {
        const runner = new _a();
        runner._run(() => runner._threadAssistantStream(params, thread, {
          ...options,
          headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" }
        }));
        return runner;
      }
      static createAssistantStream(threadId, runs, params, options) {
        const runner = new _a();
        runner._run(() => runner._runAssistantStream(threadId, runs, params, {
          ...options,
          headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" }
        }));
        return runner;
      }
      currentEvent() {
        return tslib_1.__classPrivateFieldGet(this, _AssistantStream_currentEvent, "f");
      }
      currentRun() {
        return tslib_1.__classPrivateFieldGet(this, _AssistantStream_currentRunSnapshot, "f");
      }
      currentMessageSnapshot() {
        return tslib_1.__classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f");
      }
      currentRunStepSnapshot() {
        return tslib_1.__classPrivateFieldGet(this, _AssistantStream_currentRunStepSnapshot, "f");
      }
      async finalRunSteps() {
        await this.done();
        return Object.values(tslib_1.__classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f"));
      }
      async finalMessages() {
        await this.done();
        return Object.values(tslib_1.__classPrivateFieldGet(this, _AssistantStream_messageSnapshots, "f"));
      }
      async finalRun() {
        await this.done();
        if (!tslib_1.__classPrivateFieldGet(this, _AssistantStream_finalRun, "f"))
          throw Error("Final run was not received.");
        return tslib_1.__classPrivateFieldGet(this, _AssistantStream_finalRun, "f");
      }
      async _createThreadAssistantStream(thread, params, options) {
        var _a2;
        const signal = options == null ? void 0 : options.signal;
        if (signal) {
          if (signal.aborted)
            this.controller.abort();
          signal.addEventListener("abort", () => this.controller.abort());
        }
        const body = { ...params, stream: true };
        const stream = await thread.createAndRun(body, { ...options, signal: this.controller.signal });
        this._connected();
        for await (const event of stream) {
          tslib_1.__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
        }
        if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
          throw new error_1.APIUserAbortError();
        }
        return this._addRun(tslib_1.__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
      }
      async _createAssistantStream(run, threadId, params, options) {
        var _a2;
        const signal = options == null ? void 0 : options.signal;
        if (signal) {
          if (signal.aborted)
            this.controller.abort();
          signal.addEventListener("abort", () => this.controller.abort());
        }
        const body = { ...params, stream: true };
        const stream = await run.create(threadId, body, { ...options, signal: this.controller.signal });
        this._connected();
        for await (const event of stream) {
          tslib_1.__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
        }
        if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
          throw new error_1.APIUserAbortError();
        }
        return this._addRun(tslib_1.__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
      }
      static accumulateDelta(acc, delta) {
        for (const [key, deltaValue] of Object.entries(delta)) {
          if (!acc.hasOwnProperty(key)) {
            acc[key] = deltaValue;
            continue;
          }
          let accValue = acc[key];
          if (accValue === null || accValue === void 0) {
            acc[key] = deltaValue;
            continue;
          }
          if (key === "index" || key === "type") {
            acc[key] = deltaValue;
            continue;
          }
          if (typeof accValue === "string" && typeof deltaValue === "string") {
            accValue += deltaValue;
          } else if (typeof accValue === "number" && typeof deltaValue === "number") {
            accValue += deltaValue;
          } else if ((0, utils_1.isObj)(accValue) && (0, utils_1.isObj)(deltaValue)) {
            accValue = this.accumulateDelta(accValue, deltaValue);
          } else if (Array.isArray(accValue) && Array.isArray(deltaValue)) {
            if (accValue.every((x) => typeof x === "string" || typeof x === "number")) {
              accValue.push(...deltaValue);
              continue;
            }
            for (const deltaEntry of deltaValue) {
              if (!(0, utils_1.isObj)(deltaEntry)) {
                throw new Error(`Expected array delta entry to be an object but got: ${deltaEntry}`);
              }
              const index = deltaEntry["index"];
              if (index == null) {
                console.error(deltaEntry);
                throw new Error("Expected array delta entry to have an `index` property");
              }
              if (typeof index !== "number") {
                throw new Error(`Expected array delta entry \`index\` property to be a number but got ${index}`);
              }
              const accEntry = accValue[index];
              if (accEntry == null) {
                accValue.push(deltaEntry);
              } else {
                accValue[index] = this.accumulateDelta(accEntry, deltaEntry);
              }
            }
            continue;
          } else {
            throw Error(`Unhandled record type: ${key}, deltaValue: ${deltaValue}, accValue: ${accValue}`);
          }
          acc[key] = accValue;
        }
        return acc;
      }
      _addRun(run) {
        return run;
      }
      async _threadAssistantStream(params, thread, options) {
        return await this._createThreadAssistantStream(thread, params, options);
      }
      async _runAssistantStream(threadId, runs, params, options) {
        return await this._createAssistantStream(runs, threadId, params, options);
      }
      async _runToolAssistantStream(runId, runs, params, options) {
        return await this._createToolAssistantStream(runs, runId, params, options);
      }
    };
    exports.AssistantStream = AssistantStream;
    _a = AssistantStream, _AssistantStream_addEvent = function _AssistantStream_addEvent2(event) {
      if (this.ended)
        return;
      tslib_1.__classPrivateFieldSet(this, _AssistantStream_currentEvent, event, "f");
      tslib_1.__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_handleEvent).call(this, event);
      switch (event.event) {
        case "thread.created":
          break;
        case "thread.run.created":
        case "thread.run.queued":
        case "thread.run.in_progress":
        case "thread.run.requires_action":
        case "thread.run.completed":
        case "thread.run.incomplete":
        case "thread.run.failed":
        case "thread.run.cancelling":
        case "thread.run.cancelled":
        case "thread.run.expired":
          tslib_1.__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_handleRun).call(this, event);
          break;
        case "thread.run.step.created":
        case "thread.run.step.in_progress":
        case "thread.run.step.delta":
        case "thread.run.step.completed":
        case "thread.run.step.failed":
        case "thread.run.step.cancelled":
        case "thread.run.step.expired":
          tslib_1.__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_handleRunStep).call(this, event);
          break;
        case "thread.message.created":
        case "thread.message.in_progress":
        case "thread.message.delta":
        case "thread.message.completed":
        case "thread.message.incomplete":
          tslib_1.__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_handleMessage).call(this, event);
          break;
        case "error":
          throw new Error("Encountered an error event in event processing - errors should be processed earlier");
        default:
          assertNever(event);
      }
    }, _AssistantStream_endRequest = function _AssistantStream_endRequest2() {
      if (this.ended) {
        throw new error_1.OpenAIError(`stream has ended, this shouldn't happen`);
      }
      if (!tslib_1.__classPrivateFieldGet(this, _AssistantStream_finalRun, "f"))
        throw Error("Final run has not been received");
      return tslib_1.__classPrivateFieldGet(this, _AssistantStream_finalRun, "f");
    }, _AssistantStream_handleMessage = function _AssistantStream_handleMessage2(event) {
      const [accumulatedMessage, newContent] = tslib_1.__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_accumulateMessage).call(this, event, tslib_1.__classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
      tslib_1.__classPrivateFieldSet(this, _AssistantStream_messageSnapshot, accumulatedMessage, "f");
      tslib_1.__classPrivateFieldGet(this, _AssistantStream_messageSnapshots, "f")[accumulatedMessage.id] = accumulatedMessage;
      for (const content of newContent) {
        const snapshotContent = accumulatedMessage.content[content.index];
        if ((snapshotContent == null ? void 0 : snapshotContent.type) == "text") {
          this._emit("textCreated", snapshotContent.text);
        }
      }
      switch (event.event) {
        case "thread.message.created":
          this._emit("messageCreated", event.data);
          break;
        case "thread.message.in_progress":
          break;
        case "thread.message.delta":
          this._emit("messageDelta", event.data.delta, accumulatedMessage);
          if (event.data.delta.content) {
            for (const content of event.data.delta.content) {
              if (content.type == "text" && content.text) {
                let textDelta = content.text;
                let snapshot = accumulatedMessage.content[content.index];
                if (snapshot && snapshot.type == "text") {
                  this._emit("textDelta", textDelta, snapshot.text);
                } else {
                  throw Error("The snapshot associated with this text delta is not text or missing");
                }
              }
              if (content.index != tslib_1.__classPrivateFieldGet(this, _AssistantStream_currentContentIndex, "f")) {
                if (tslib_1.__classPrivateFieldGet(this, _AssistantStream_currentContent, "f")) {
                  switch (tslib_1.__classPrivateFieldGet(this, _AssistantStream_currentContent, "f").type) {
                    case "text":
                      this._emit("textDone", tslib_1.__classPrivateFieldGet(this, _AssistantStream_currentContent, "f").text, tslib_1.__classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
                      break;
                    case "image_file":
                      this._emit("imageFileDone", tslib_1.__classPrivateFieldGet(this, _AssistantStream_currentContent, "f").image_file, tslib_1.__classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
                      break;
                  }
                }
                tslib_1.__classPrivateFieldSet(this, _AssistantStream_currentContentIndex, content.index, "f");
              }
              tslib_1.__classPrivateFieldSet(this, _AssistantStream_currentContent, accumulatedMessage.content[content.index], "f");
            }
          }
          break;
        case "thread.message.completed":
        case "thread.message.incomplete":
          if (tslib_1.__classPrivateFieldGet(this, _AssistantStream_currentContentIndex, "f") !== void 0) {
            const currentContent = event.data.content[tslib_1.__classPrivateFieldGet(this, _AssistantStream_currentContentIndex, "f")];
            if (currentContent) {
              switch (currentContent.type) {
                case "image_file":
                  this._emit("imageFileDone", currentContent.image_file, tslib_1.__classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
                  break;
                case "text":
                  this._emit("textDone", currentContent.text, tslib_1.__classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
                  break;
              }
            }
          }
          if (tslib_1.__classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f")) {
            this._emit("messageDone", event.data);
          }
          tslib_1.__classPrivateFieldSet(this, _AssistantStream_messageSnapshot, void 0, "f");
      }
    }, _AssistantStream_handleRunStep = function _AssistantStream_handleRunStep2(event) {
      const accumulatedRunStep = tslib_1.__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_accumulateRunStep).call(this, event);
      tslib_1.__classPrivateFieldSet(this, _AssistantStream_currentRunStepSnapshot, accumulatedRunStep, "f");
      switch (event.event) {
        case "thread.run.step.created":
          this._emit("runStepCreated", event.data);
          break;
        case "thread.run.step.delta":
          const delta = event.data.delta;
          if (delta.step_details && delta.step_details.type == "tool_calls" && delta.step_details.tool_calls && accumulatedRunStep.step_details.type == "tool_calls") {
            for (const toolCall of delta.step_details.tool_calls) {
              if (toolCall.index == tslib_1.__classPrivateFieldGet(this, _AssistantStream_currentToolCallIndex, "f")) {
                this._emit("toolCallDelta", toolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index]);
              } else {
                if (tslib_1.__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f")) {
                  this._emit("toolCallDone", tslib_1.__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"));
                }
                tslib_1.__classPrivateFieldSet(this, _AssistantStream_currentToolCallIndex, toolCall.index, "f");
                tslib_1.__classPrivateFieldSet(this, _AssistantStream_currentToolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index], "f");
                if (tslib_1.__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"))
                  this._emit("toolCallCreated", tslib_1.__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"));
              }
            }
          }
          this._emit("runStepDelta", event.data.delta, accumulatedRunStep);
          break;
        case "thread.run.step.completed":
        case "thread.run.step.failed":
        case "thread.run.step.cancelled":
        case "thread.run.step.expired":
          tslib_1.__classPrivateFieldSet(this, _AssistantStream_currentRunStepSnapshot, void 0, "f");
          const details = event.data.step_details;
          if (details.type == "tool_calls") {
            if (tslib_1.__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f")) {
              this._emit("toolCallDone", tslib_1.__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"));
              tslib_1.__classPrivateFieldSet(this, _AssistantStream_currentToolCall, void 0, "f");
            }
          }
          this._emit("runStepDone", event.data, accumulatedRunStep);
          break;
        case "thread.run.step.in_progress":
          break;
      }
    }, _AssistantStream_handleEvent = function _AssistantStream_handleEvent2(event) {
      tslib_1.__classPrivateFieldGet(this, _AssistantStream_events, "f").push(event);
      this._emit("event", event);
    }, _AssistantStream_accumulateRunStep = function _AssistantStream_accumulateRunStep2(event) {
      switch (event.event) {
        case "thread.run.step.created":
          tslib_1.__classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = event.data;
          return event.data;
        case "thread.run.step.delta":
          let snapshot = tslib_1.__classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
          if (!snapshot) {
            throw Error("Received a RunStepDelta before creation of a snapshot");
          }
          let data = event.data;
          if (data.delta) {
            const accumulated = _a.accumulateDelta(snapshot, data.delta);
            tslib_1.__classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = accumulated;
          }
          return tslib_1.__classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
        case "thread.run.step.completed":
        case "thread.run.step.failed":
        case "thread.run.step.cancelled":
        case "thread.run.step.expired":
        case "thread.run.step.in_progress":
          tslib_1.__classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = event.data;
          break;
      }
      if (tslib_1.__classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id])
        return tslib_1.__classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
      throw new Error("No snapshot available");
    }, _AssistantStream_accumulateMessage = function _AssistantStream_accumulateMessage2(event, snapshot) {
      let newContent = [];
      switch (event.event) {
        case "thread.message.created":
          return [event.data, newContent];
        case "thread.message.delta":
          if (!snapshot) {
            throw Error("Received a delta with no existing snapshot (there should be one from message creation)");
          }
          let data = event.data;
          if (data.delta.content) {
            for (const contentElement of data.delta.content) {
              if (contentElement.index in snapshot.content) {
                let currentContent = snapshot.content[contentElement.index];
                snapshot.content[contentElement.index] = tslib_1.__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_accumulateContent).call(this, contentElement, currentContent);
              } else {
                snapshot.content[contentElement.index] = contentElement;
                newContent.push(contentElement);
              }
            }
          }
          return [snapshot, newContent];
        case "thread.message.in_progress":
        case "thread.message.completed":
        case "thread.message.incomplete":
          if (snapshot) {
            return [snapshot, newContent];
          } else {
            throw Error("Received thread message event with no existing snapshot");
          }
      }
      throw Error("Tried to accumulate a non-message event");
    }, _AssistantStream_accumulateContent = function _AssistantStream_accumulateContent2(contentElement, currentContent) {
      return _a.accumulateDelta(currentContent, contentElement);
    }, _AssistantStream_handleRun = function _AssistantStream_handleRun2(event) {
      tslib_1.__classPrivateFieldSet(this, _AssistantStream_currentRunSnapshot, event.data, "f");
      switch (event.event) {
        case "thread.run.created":
          break;
        case "thread.run.queued":
          break;
        case "thread.run.in_progress":
          break;
        case "thread.run.requires_action":
        case "thread.run.cancelled":
        case "thread.run.failed":
        case "thread.run.completed":
        case "thread.run.expired":
        case "thread.run.incomplete":
          tslib_1.__classPrivateFieldSet(this, _AssistantStream_finalRun, event.data, "f");
          if (tslib_1.__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f")) {
            this._emit("toolCallDone", tslib_1.__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"));
            tslib_1.__classPrivateFieldSet(this, _AssistantStream_currentToolCall, void 0, "f");
          }
          break;
        case "thread.run.cancelling":
          break;
      }
    };
    function assertNever(_x) {
    }
  }
});

// node_modules/openai/resources/beta/threads/runs/runs.js
var require_runs = __commonJS({
  "node_modules/openai/resources/beta/threads/runs/runs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Runs = void 0;
    var tslib_1 = require_tslib();
    var resource_1 = require_resource();
    var StepsAPI = tslib_1.__importStar(require_steps());
    var steps_1 = require_steps();
    var pagination_1 = require_pagination();
    var headers_1 = require_headers();
    var AssistantStream_1 = require_AssistantStream();
    var sleep_1 = require_sleep();
    var path_1 = require_path();
    var Runs = class extends resource_1.APIResource {
      constructor() {
        super(...arguments);
        this.steps = new StepsAPI.Steps(this._client);
      }
      create(threadID, params, options) {
        const { include, ...body } = params;
        return this._client.post((0, path_1.path)`/threads/${threadID}/runs`, {
          query: { include },
          body,
          ...options,
          headers: (0, headers_1.buildHeaders)([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers]),
          stream: params.stream ?? false
        });
      }
      /**
       * Retrieves a run.
       *
       * @deprecated The Assistants API is deprecated in favor of the Responses API
       */
      retrieve(runID, params, options) {
        const { thread_id } = params;
        return this._client.get((0, path_1.path)`/threads/${thread_id}/runs/${runID}`, {
          ...options,
          headers: (0, headers_1.buildHeaders)([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
        });
      }
      /**
       * Modifies a run.
       *
       * @deprecated The Assistants API is deprecated in favor of the Responses API
       */
      update(runID, params, options) {
        const { thread_id, ...body } = params;
        return this._client.post((0, path_1.path)`/threads/${thread_id}/runs/${runID}`, {
          body,
          ...options,
          headers: (0, headers_1.buildHeaders)([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
        });
      }
      /**
       * Returns a list of runs belonging to a thread.
       *
       * @deprecated The Assistants API is deprecated in favor of the Responses API
       */
      list(threadID, query = {}, options) {
        return this._client.getAPIList((0, path_1.path)`/threads/${threadID}/runs`, pagination_1.CursorPage, {
          query,
          ...options,
          headers: (0, headers_1.buildHeaders)([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
        });
      }
      /**
       * Cancels a run that is `in_progress`.
       *
       * @deprecated The Assistants API is deprecated in favor of the Responses API
       */
      cancel(runID, params, options) {
        const { thread_id } = params;
        return this._client.post((0, path_1.path)`/threads/${thread_id}/runs/${runID}/cancel`, {
          ...options,
          headers: (0, headers_1.buildHeaders)([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
        });
      }
      /**
       * A helper to create a run an poll for a terminal state. More information on Run
       * lifecycles can be found here:
       * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
       */
      async createAndPoll(threadId, body, options) {
        const run = await this.create(threadId, body, options);
        return await this.poll(run.id, { thread_id: threadId }, options);
      }
      /**
       * Create a Run stream
       *
       * @deprecated use `stream` instead
       */
      createAndStream(threadId, body, options) {
        return AssistantStream_1.AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);
      }
      /**
       * A helper to poll a run status until it reaches a terminal state. More
       * information on Run lifecycles can be found here:
       * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
       */
      async poll(runId, params, options) {
        var _a;
        const headers = (0, headers_1.buildHeaders)([
          options == null ? void 0 : options.headers,
          {
            "X-Stainless-Poll-Helper": "true",
            "X-Stainless-Custom-Poll-Interval": ((_a = options == null ? void 0 : options.pollIntervalMs) == null ? void 0 : _a.toString()) ?? void 0
          }
        ]);
        while (true) {
          const { data: run, response } = await this.retrieve(runId, params, {
            ...options,
            headers: { ...options == null ? void 0 : options.headers, ...headers }
          }).withResponse();
          switch (run.status) {
            //If we are in any sort of intermediate state we poll
            case "queued":
            case "in_progress":
            case "cancelling":
              let sleepInterval = 5e3;
              if (options == null ? void 0 : options.pollIntervalMs) {
                sleepInterval = options.pollIntervalMs;
              } else {
                const headerInterval = response.headers.get("openai-poll-after-ms");
                if (headerInterval) {
                  const headerIntervalMs = parseInt(headerInterval);
                  if (!isNaN(headerIntervalMs)) {
                    sleepInterval = headerIntervalMs;
                  }
                }
              }
              await (0, sleep_1.sleep)(sleepInterval);
              break;
            //We return the run in any terminal state.
            case "requires_action":
            case "incomplete":
            case "cancelled":
            case "completed":
            case "failed":
            case "expired":
              return run;
          }
        }
      }
      /**
       * Create a Run stream
       */
      stream(threadId, body, options) {
        return AssistantStream_1.AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);
      }
      submitToolOutputs(runID, params, options) {
        const { thread_id, ...body } = params;
        return this._client.post((0, path_1.path)`/threads/${thread_id}/runs/${runID}/submit_tool_outputs`, {
          body,
          ...options,
          headers: (0, headers_1.buildHeaders)([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers]),
          stream: params.stream ?? false
        });
      }
      /**
       * A helper to submit a tool output to a run and poll for a terminal run state.
       * More information on Run lifecycles can be found here:
       * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
       */
      async submitToolOutputsAndPoll(runId, params, options) {
        const run = await this.submitToolOutputs(runId, params, options);
        return await this.poll(run.id, params, options);
      }
      /**
       * Submit the tool outputs from a previous run and stream the run to a terminal
       * state. More information on Run lifecycles can be found here:
       * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
       */
      submitToolOutputsStream(runId, params, options) {
        return AssistantStream_1.AssistantStream.createToolAssistantStream(runId, this._client.beta.threads.runs, params, options);
      }
    };
    exports.Runs = Runs;
    Runs.Steps = steps_1.Steps;
  }
});

// node_modules/openai/resources/beta/threads/threads.js
var require_threads = __commonJS({
  "node_modules/openai/resources/beta/threads/threads.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Threads = void 0;
    var tslib_1 = require_tslib();
    var resource_1 = require_resource();
    var MessagesAPI = tslib_1.__importStar(require_messages2());
    var messages_1 = require_messages2();
    var RunsAPI = tslib_1.__importStar(require_runs());
    var runs_1 = require_runs();
    var headers_1 = require_headers();
    var AssistantStream_1 = require_AssistantStream();
    var path_1 = require_path();
    var Threads = class extends resource_1.APIResource {
      constructor() {
        super(...arguments);
        this.runs = new RunsAPI.Runs(this._client);
        this.messages = new MessagesAPI.Messages(this._client);
      }
      /**
       * Create a thread.
       *
       * @deprecated The Assistants API is deprecated in favor of the Responses API
       */
      create(body = {}, options) {
        return this._client.post("/threads", {
          body,
          ...options,
          headers: (0, headers_1.buildHeaders)([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
        });
      }
      /**
       * Retrieves a thread.
       *
       * @deprecated The Assistants API is deprecated in favor of the Responses API
       */
      retrieve(threadID, options) {
        return this._client.get((0, path_1.path)`/threads/${threadID}`, {
          ...options,
          headers: (0, headers_1.buildHeaders)([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
        });
      }
      /**
       * Modifies a thread.
       *
       * @deprecated The Assistants API is deprecated in favor of the Responses API
       */
      update(threadID, body, options) {
        return this._client.post((0, path_1.path)`/threads/${threadID}`, {
          body,
          ...options,
          headers: (0, headers_1.buildHeaders)([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
        });
      }
      /**
       * Delete a thread.
       *
       * @deprecated The Assistants API is deprecated in favor of the Responses API
       */
      delete(threadID, options) {
        return this._client.delete((0, path_1.path)`/threads/${threadID}`, {
          ...options,
          headers: (0, headers_1.buildHeaders)([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
        });
      }
      createAndRun(body, options) {
        return this._client.post("/threads/runs", {
          body,
          ...options,
          headers: (0, headers_1.buildHeaders)([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers]),
          stream: body.stream ?? false
        });
      }
      /**
       * A helper to create a thread, start a run and then poll for a terminal state.
       * More information on Run lifecycles can be found here:
       * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
       */
      async createAndRunPoll(body, options) {
        const run = await this.createAndRun(body, options);
        return await this.runs.poll(run.id, { thread_id: run.thread_id }, options);
      }
      /**
       * Create a thread and stream the run back
       */
      createAndRunStream(body, options) {
        return AssistantStream_1.AssistantStream.createThreadAssistantStream(body, this._client.beta.threads, options);
      }
    };
    exports.Threads = Threads;
    Threads.Runs = runs_1.Runs;
    Threads.Messages = messages_1.Messages;
  }
});

// node_modules/openai/resources/beta/beta.js
var require_beta = __commonJS({
  "node_modules/openai/resources/beta/beta.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Beta = void 0;
    var tslib_1 = require_tslib();
    var resource_1 = require_resource();
    var AssistantsAPI = tslib_1.__importStar(require_assistants());
    var assistants_1 = require_assistants();
    var RealtimeAPI = tslib_1.__importStar(require_realtime());
    var realtime_1 = require_realtime();
    var ThreadsAPI = tslib_1.__importStar(require_threads());
    var threads_1 = require_threads();
    var Beta = class extends resource_1.APIResource {
      constructor() {
        super(...arguments);
        this.realtime = new RealtimeAPI.Realtime(this._client);
        this.assistants = new AssistantsAPI.Assistants(this._client);
        this.threads = new ThreadsAPI.Threads(this._client);
      }
    };
    exports.Beta = Beta;
    Beta.Realtime = realtime_1.Realtime;
    Beta.Assistants = assistants_1.Assistants;
    Beta.Threads = threads_1.Threads;
  }
});

// node_modules/openai/resources/completions.js
var require_completions3 = __commonJS({
  "node_modules/openai/resources/completions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Completions = void 0;
    var resource_1 = require_resource();
    var Completions = class extends resource_1.APIResource {
      create(body, options) {
        return this._client.post("/completions", { body, ...options, stream: body.stream ?? false });
      }
    };
    exports.Completions = Completions;
  }
});

// node_modules/openai/resources/containers/files/content.js
var require_content = __commonJS({
  "node_modules/openai/resources/containers/files/content.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Content = void 0;
    var resource_1 = require_resource();
    var headers_1 = require_headers();
    var path_1 = require_path();
    var Content = class extends resource_1.APIResource {
      /**
       * Retrieve Container File Content
       */
      retrieve(fileID, params, options) {
        const { container_id } = params;
        return this._client.get((0, path_1.path)`/containers/${container_id}/files/${fileID}/content`, {
          ...options,
          headers: (0, headers_1.buildHeaders)([{ Accept: "application/binary" }, options == null ? void 0 : options.headers]),
          __binaryResponse: true
        });
      }
    };
    exports.Content = Content;
  }
});

// node_modules/openai/resources/containers/files/files.js
var require_files = __commonJS({
  "node_modules/openai/resources/containers/files/files.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Files = void 0;
    var tslib_1 = require_tslib();
    var resource_1 = require_resource();
    var ContentAPI = tslib_1.__importStar(require_content());
    var content_1 = require_content();
    var pagination_1 = require_pagination();
    var headers_1 = require_headers();
    var uploads_1 = require_uploads();
    var path_1 = require_path();
    var Files = class extends resource_1.APIResource {
      constructor() {
        super(...arguments);
        this.content = new ContentAPI.Content(this._client);
      }
      /**
       * Create a Container File
       *
       * You can send either a multipart/form-data request with the raw file content, or
       * a JSON request with a file ID.
       */
      create(containerID, body, options) {
        return this._client.post((0, path_1.path)`/containers/${containerID}/files`, (0, uploads_1.multipartFormRequestOptions)({ body, ...options }, this._client));
      }
      /**
       * Retrieve Container File
       */
      retrieve(fileID, params, options) {
        const { container_id } = params;
        return this._client.get((0, path_1.path)`/containers/${container_id}/files/${fileID}`, options);
      }
      /**
       * List Container files
       */
      list(containerID, query = {}, options) {
        return this._client.getAPIList((0, path_1.path)`/containers/${containerID}/files`, pagination_1.CursorPage, {
          query,
          ...options
        });
      }
      /**
       * Delete Container File
       */
      delete(fileID, params, options) {
        const { container_id } = params;
        return this._client.delete((0, path_1.path)`/containers/${container_id}/files/${fileID}`, {
          ...options,
          headers: (0, headers_1.buildHeaders)([{ Accept: "*/*" }, options == null ? void 0 : options.headers])
        });
      }
    };
    exports.Files = Files;
    Files.Content = content_1.Content;
  }
});

// node_modules/openai/resources/containers/containers.js
var require_containers = __commonJS({
  "node_modules/openai/resources/containers/containers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Containers = void 0;
    var tslib_1 = require_tslib();
    var resource_1 = require_resource();
    var FilesAPI = tslib_1.__importStar(require_files());
    var files_1 = require_files();
    var pagination_1 = require_pagination();
    var headers_1 = require_headers();
    var path_1 = require_path();
    var Containers = class extends resource_1.APIResource {
      constructor() {
        super(...arguments);
        this.files = new FilesAPI.Files(this._client);
      }
      /**
       * Create Container
       */
      create(body, options) {
        return this._client.post("/containers", { body, ...options });
      }
      /**
       * Retrieve Container
       */
      retrieve(containerID, options) {
        return this._client.get((0, path_1.path)`/containers/${containerID}`, options);
      }
      /**
       * List Containers
       */
      list(query = {}, options) {
        return this._client.getAPIList("/containers", pagination_1.CursorPage, { query, ...options });
      }
      /**
       * Delete Container
       */
      delete(containerID, options) {
        return this._client.delete((0, path_1.path)`/containers/${containerID}`, {
          ...options,
          headers: (0, headers_1.buildHeaders)([{ Accept: "*/*" }, options == null ? void 0 : options.headers])
        });
      }
    };
    exports.Containers = Containers;
    Containers.Files = files_1.Files;
  }
});

// node_modules/openai/resources/conversations/items.js
var require_items = __commonJS({
  "node_modules/openai/resources/conversations/items.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Items = void 0;
    var resource_1 = require_resource();
    var pagination_1 = require_pagination();
    var path_1 = require_path();
    var Items = class extends resource_1.APIResource {
      /**
       * Create items in a conversation with the given ID.
       */
      create(conversationID, params, options) {
        const { include, ...body } = params;
        return this._client.post((0, path_1.path)`/conversations/${conversationID}/items`, {
          query: { include },
          body,
          ...options
        });
      }
      /**
       * Get a single item from a conversation with the given IDs.
       */
      retrieve(itemID, params, options) {
        const { conversation_id, ...query } = params;
        return this._client.get((0, path_1.path)`/conversations/${conversation_id}/items/${itemID}`, { query, ...options });
      }
      /**
       * List all items for a conversation with the given ID.
       */
      list(conversationID, query = {}, options) {
        return this._client.getAPIList((0, path_1.path)`/conversations/${conversationID}/items`, pagination_1.ConversationCursorPage, { query, ...options });
      }
      /**
       * Delete an item from a conversation with the given IDs.
       */
      delete(itemID, params, options) {
        const { conversation_id } = params;
        return this._client.delete((0, path_1.path)`/conversations/${conversation_id}/items/${itemID}`, options);
      }
    };
    exports.Items = Items;
  }
});

// node_modules/openai/resources/conversations/conversations.js
var require_conversations = __commonJS({
  "node_modules/openai/resources/conversations/conversations.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Conversations = void 0;
    var tslib_1 = require_tslib();
    var resource_1 = require_resource();
    var ItemsAPI = tslib_1.__importStar(require_items());
    var items_1 = require_items();
    var path_1 = require_path();
    var Conversations = class extends resource_1.APIResource {
      constructor() {
        super(...arguments);
        this.items = new ItemsAPI.Items(this._client);
      }
      /**
       * Create a conversation.
       */
      create(body, options) {
        return this._client.post("/conversations", { body, ...options });
      }
      /**
       * Get a conversation with the given ID.
       */
      retrieve(conversationID, options) {
        return this._client.get((0, path_1.path)`/conversations/${conversationID}`, options);
      }
      /**
       * Update a conversation's metadata with the given ID.
       */
      update(conversationID, body, options) {
        return this._client.post((0, path_1.path)`/conversations/${conversationID}`, { body, ...options });
      }
      /**
       * Delete a conversation with the given ID.
       */
      delete(conversationID, options) {
        return this._client.delete((0, path_1.path)`/conversations/${conversationID}`, options);
      }
    };
    exports.Conversations = Conversations;
    Conversations.Items = items_1.Items;
  }
});

// node_modules/openai/resources/embeddings.js
var require_embeddings = __commonJS({
  "node_modules/openai/resources/embeddings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Embeddings = void 0;
    var resource_1 = require_resource();
    var utils_1 = require_utils2();
    var Embeddings = class extends resource_1.APIResource {
      /**
       * Creates an embedding vector representing the input text.
       *
       * @example
       * ```ts
       * const createEmbeddingResponse =
       *   await client.embeddings.create({
       *     input: 'The quick brown fox jumped over the lazy dog',
       *     model: 'text-embedding-3-small',
       *   });
       * ```
       */
      create(body, options) {
        const hasUserProvidedEncodingFormat = !!body.encoding_format;
        let encoding_format = hasUserProvidedEncodingFormat ? body.encoding_format : "base64";
        if (hasUserProvidedEncodingFormat) {
          (0, utils_1.loggerFor)(this._client).debug("embeddings/user defined encoding_format:", body.encoding_format);
        }
        const response = this._client.post("/embeddings", {
          body: {
            ...body,
            encoding_format
          },
          ...options
        });
        if (hasUserProvidedEncodingFormat) {
          return response;
        }
        (0, utils_1.loggerFor)(this._client).debug("embeddings/decoding base64 embeddings from base64");
        return response._thenUnwrap((response2) => {
          if (response2 && response2.data) {
            response2.data.forEach((embeddingBase64Obj) => {
              const embeddingBase64Str = embeddingBase64Obj.embedding;
              embeddingBase64Obj.embedding = (0, utils_1.toFloat32Array)(embeddingBase64Str);
            });
          }
          return response2;
        });
      }
    };
    exports.Embeddings = Embeddings;
  }
});

// node_modules/openai/resources/evals/runs/output-items.js
var require_output_items = __commonJS({
  "node_modules/openai/resources/evals/runs/output-items.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OutputItems = void 0;
    var resource_1 = require_resource();
    var pagination_1 = require_pagination();
    var path_1 = require_path();
    var OutputItems = class extends resource_1.APIResource {
      /**
       * Get an evaluation run output item by ID.
       */
      retrieve(outputItemID, params, options) {
        const { eval_id, run_id } = params;
        return this._client.get((0, path_1.path)`/evals/${eval_id}/runs/${run_id}/output_items/${outputItemID}`, options);
      }
      /**
       * Get a list of output items for an evaluation run.
       */
      list(runID, params, options) {
        const { eval_id, ...query } = params;
        return this._client.getAPIList((0, path_1.path)`/evals/${eval_id}/runs/${runID}/output_items`, pagination_1.CursorPage, { query, ...options });
      }
    };
    exports.OutputItems = OutputItems;
  }
});

// node_modules/openai/resources/evals/runs/runs.js
var require_runs2 = __commonJS({
  "node_modules/openai/resources/evals/runs/runs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Runs = void 0;
    var tslib_1 = require_tslib();
    var resource_1 = require_resource();
    var OutputItemsAPI = tslib_1.__importStar(require_output_items());
    var output_items_1 = require_output_items();
    var pagination_1 = require_pagination();
    var path_1 = require_path();
    var Runs = class extends resource_1.APIResource {
      constructor() {
        super(...arguments);
        this.outputItems = new OutputItemsAPI.OutputItems(this._client);
      }
      /**
       * Kicks off a new run for a given evaluation, specifying the data source, and what
       * model configuration to use to test. The datasource will be validated against the
       * schema specified in the config of the evaluation.
       */
      create(evalID, body, options) {
        return this._client.post((0, path_1.path)`/evals/${evalID}/runs`, { body, ...options });
      }
      /**
       * Get an evaluation run by ID.
       */
      retrieve(runID, params, options) {
        const { eval_id } = params;
        return this._client.get((0, path_1.path)`/evals/${eval_id}/runs/${runID}`, options);
      }
      /**
       * Get a list of runs for an evaluation.
       */
      list(evalID, query = {}, options) {
        return this._client.getAPIList((0, path_1.path)`/evals/${evalID}/runs`, pagination_1.CursorPage, {
          query,
          ...options
        });
      }
      /**
       * Delete an eval run.
       */
      delete(runID, params, options) {
        const { eval_id } = params;
        return this._client.delete((0, path_1.path)`/evals/${eval_id}/runs/${runID}`, options);
      }
      /**
       * Cancel an ongoing evaluation run.
       */
      cancel(runID, params, options) {
        const { eval_id } = params;
        return this._client.post((0, path_1.path)`/evals/${eval_id}/runs/${runID}`, options);
      }
    };
    exports.Runs = Runs;
    Runs.OutputItems = output_items_1.OutputItems;
  }
});

// node_modules/openai/resources/evals/evals.js
var require_evals = __commonJS({
  "node_modules/openai/resources/evals/evals.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Evals = void 0;
    var tslib_1 = require_tslib();
    var resource_1 = require_resource();
    var RunsAPI = tslib_1.__importStar(require_runs2());
    var runs_1 = require_runs2();
    var pagination_1 = require_pagination();
    var path_1 = require_path();
    var Evals = class extends resource_1.APIResource {
      constructor() {
        super(...arguments);
        this.runs = new RunsAPI.Runs(this._client);
      }
      /**
       * Create the structure of an evaluation that can be used to test a model's
       * performance. An evaluation is a set of testing criteria and the config for a
       * data source, which dictates the schema of the data used in the evaluation. After
       * creating an evaluation, you can run it on different models and model parameters.
       * We support several types of graders and datasources. For more information, see
       * the [Evals guide](https://platform.openai.com/docs/guides/evals).
       */
      create(body, options) {
        return this._client.post("/evals", { body, ...options });
      }
      /**
       * Get an evaluation by ID.
       */
      retrieve(evalID, options) {
        return this._client.get((0, path_1.path)`/evals/${evalID}`, options);
      }
      /**
       * Update certain properties of an evaluation.
       */
      update(evalID, body, options) {
        return this._client.post((0, path_1.path)`/evals/${evalID}`, { body, ...options });
      }
      /**
       * List evaluations for a project.
       */
      list(query = {}, options) {
        return this._client.getAPIList("/evals", pagination_1.CursorPage, { query, ...options });
      }
      /**
       * Delete an evaluation.
       */
      delete(evalID, options) {
        return this._client.delete((0, path_1.path)`/evals/${evalID}`, options);
      }
    };
    exports.Evals = Evals;
    Evals.Runs = runs_1.Runs;
  }
});

// node_modules/openai/resources/files.js
var require_files2 = __commonJS({
  "node_modules/openai/resources/files.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Files = void 0;
    var resource_1 = require_resource();
    var pagination_1 = require_pagination();
    var headers_1 = require_headers();
    var sleep_1 = require_sleep();
    var error_1 = require_error2();
    var uploads_1 = require_uploads();
    var path_1 = require_path();
    var Files = class extends resource_1.APIResource {
      /**
       * Upload a file that can be used across various endpoints. Individual files can be
       * up to 512 MB, and the size of all files uploaded by one organization can be up
       * to 1 TB.
       *
       * The Assistants API supports files up to 2 million tokens and of specific file
       * types. See the
       * [Assistants Tools guide](https://platform.openai.com/docs/assistants/tools) for
       * details.
       *
       * The Fine-tuning API only supports `.jsonl` files. The input also has certain
       * required formats for fine-tuning
       * [chat](https://platform.openai.com/docs/api-reference/fine-tuning/chat-input) or
       * [completions](https://platform.openai.com/docs/api-reference/fine-tuning/completions-input)
       * models.
       *
       * The Batch API only supports `.jsonl` files up to 200 MB in size. The input also
       * has a specific required
       * [format](https://platform.openai.com/docs/api-reference/batch/request-input).
       *
       * Please [contact us](https://help.openai.com/) if you need to increase these
       * storage limits.
       */
      create(body, options) {
        return this._client.post("/files", (0, uploads_1.multipartFormRequestOptions)({ body, ...options }, this._client));
      }
      /**
       * Returns information about a specific file.
       */
      retrieve(fileID, options) {
        return this._client.get((0, path_1.path)`/files/${fileID}`, options);
      }
      /**
       * Returns a list of files.
       */
      list(query = {}, options) {
        return this._client.getAPIList("/files", pagination_1.CursorPage, { query, ...options });
      }
      /**
       * Delete a file.
       */
      delete(fileID, options) {
        return this._client.delete((0, path_1.path)`/files/${fileID}`, options);
      }
      /**
       * Returns the contents of the specified file.
       */
      content(fileID, options) {
        return this._client.get((0, path_1.path)`/files/${fileID}/content`, {
          ...options,
          headers: (0, headers_1.buildHeaders)([{ Accept: "application/binary" }, options == null ? void 0 : options.headers]),
          __binaryResponse: true
        });
      }
      /**
       * Waits for the given file to be processed, default timeout is 30 mins.
       */
      async waitForProcessing(id, { pollInterval = 5e3, maxWait = 30 * 60 * 1e3 } = {}) {
        const TERMINAL_STATES = /* @__PURE__ */ new Set(["processed", "error", "deleted"]);
        const start = Date.now();
        let file = await this.retrieve(id);
        while (!file.status || !TERMINAL_STATES.has(file.status)) {
          await (0, sleep_1.sleep)(pollInterval);
          file = await this.retrieve(id);
          if (Date.now() - start > maxWait) {
            throw new error_1.APIConnectionTimeoutError({
              message: `Giving up on waiting for file ${id} to finish processing after ${maxWait} milliseconds.`
            });
          }
        }
        return file;
      }
    };
    exports.Files = Files;
  }
});

// node_modules/openai/resources/fine-tuning/methods.js
var require_methods = __commonJS({
  "node_modules/openai/resources/fine-tuning/methods.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Methods = void 0;
    var resource_1 = require_resource();
    var Methods = class extends resource_1.APIResource {
    };
    exports.Methods = Methods;
  }
});

// node_modules/openai/resources/fine-tuning/alpha/graders.js
var require_graders = __commonJS({
  "node_modules/openai/resources/fine-tuning/alpha/graders.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Graders = void 0;
    var resource_1 = require_resource();
    var Graders = class extends resource_1.APIResource {
      /**
       * Run a grader.
       *
       * @example
       * ```ts
       * const response = await client.fineTuning.alpha.graders.run({
       *   grader: {
       *     input: 'input',
       *     name: 'name',
       *     operation: 'eq',
       *     reference: 'reference',
       *     type: 'string_check',
       *   },
       *   model_sample: 'model_sample',
       * });
       * ```
       */
      run(body, options) {
        return this._client.post("/fine_tuning/alpha/graders/run", { body, ...options });
      }
      /**
       * Validate a grader.
       *
       * @example
       * ```ts
       * const response =
       *   await client.fineTuning.alpha.graders.validate({
       *     grader: {
       *       input: 'input',
       *       name: 'name',
       *       operation: 'eq',
       *       reference: 'reference',
       *       type: 'string_check',
       *     },
       *   });
       * ```
       */
      validate(body, options) {
        return this._client.post("/fine_tuning/alpha/graders/validate", { body, ...options });
      }
    };
    exports.Graders = Graders;
  }
});

// node_modules/openai/resources/fine-tuning/alpha/alpha.js
var require_alpha = __commonJS({
  "node_modules/openai/resources/fine-tuning/alpha/alpha.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Alpha = void 0;
    var tslib_1 = require_tslib();
    var resource_1 = require_resource();
    var GradersAPI = tslib_1.__importStar(require_graders());
    var graders_1 = require_graders();
    var Alpha = class extends resource_1.APIResource {
      constructor() {
        super(...arguments);
        this.graders = new GradersAPI.Graders(this._client);
      }
    };
    exports.Alpha = Alpha;
    Alpha.Graders = graders_1.Graders;
  }
});

// node_modules/openai/resources/fine-tuning/checkpoints/permissions.js
var require_permissions = __commonJS({
  "node_modules/openai/resources/fine-tuning/checkpoints/permissions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Permissions = void 0;
    var resource_1 = require_resource();
    var pagination_1 = require_pagination();
    var path_1 = require_path();
    var Permissions = class extends resource_1.APIResource {
      /**
       * **NOTE:** Calling this endpoint requires an [admin API key](../admin-api-keys).
       *
       * This enables organization owners to share fine-tuned models with other projects
       * in their organization.
       *
       * @example
       * ```ts
       * // Automatically fetches more pages as needed.
       * for await (const permissionCreateResponse of client.fineTuning.checkpoints.permissions.create(
       *   'ft:gpt-4o-mini-2024-07-18:org:weather:B7R9VjQd',
       *   { project_ids: ['string'] },
       * )) {
       *   // ...
       * }
       * ```
       */
      create(fineTunedModelCheckpoint, body, options) {
        return this._client.getAPIList((0, path_1.path)`/fine_tuning/checkpoints/${fineTunedModelCheckpoint}/permissions`, pagination_1.Page, { body, method: "post", ...options });
      }
      /**
       * **NOTE:** This endpoint requires an [admin API key](../admin-api-keys).
       *
       * Organization owners can use this endpoint to view all permissions for a
       * fine-tuned model checkpoint.
       *
       * @example
       * ```ts
       * const permission =
       *   await client.fineTuning.checkpoints.permissions.retrieve(
       *     'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
       *   );
       * ```
       */
      retrieve(fineTunedModelCheckpoint, query = {}, options) {
        return this._client.get((0, path_1.path)`/fine_tuning/checkpoints/${fineTunedModelCheckpoint}/permissions`, {
          query,
          ...options
        });
      }
      /**
       * **NOTE:** This endpoint requires an [admin API key](../admin-api-keys).
       *
       * Organization owners can use this endpoint to delete a permission for a
       * fine-tuned model checkpoint.
       *
       * @example
       * ```ts
       * const permission =
       *   await client.fineTuning.checkpoints.permissions.delete(
       *     'cp_zc4Q7MP6XxulcVzj4MZdwsAB',
       *     {
       *       fine_tuned_model_checkpoint:
       *         'ft:gpt-4o-mini-2024-07-18:org:weather:B7R9VjQd',
       *     },
       *   );
       * ```
       */
      delete(permissionID, params, options) {
        const { fine_tuned_model_checkpoint } = params;
        return this._client.delete((0, path_1.path)`/fine_tuning/checkpoints/${fine_tuned_model_checkpoint}/permissions/${permissionID}`, options);
      }
    };
    exports.Permissions = Permissions;
  }
});

// node_modules/openai/resources/fine-tuning/checkpoints/checkpoints.js
var require_checkpoints = __commonJS({
  "node_modules/openai/resources/fine-tuning/checkpoints/checkpoints.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Checkpoints = void 0;
    var tslib_1 = require_tslib();
    var resource_1 = require_resource();
    var PermissionsAPI = tslib_1.__importStar(require_permissions());
    var permissions_1 = require_permissions();
    var Checkpoints = class extends resource_1.APIResource {
      constructor() {
        super(...arguments);
        this.permissions = new PermissionsAPI.Permissions(this._client);
      }
    };
    exports.Checkpoints = Checkpoints;
    Checkpoints.Permissions = permissions_1.Permissions;
  }
});

// node_modules/openai/resources/fine-tuning/jobs/checkpoints.js
var require_checkpoints2 = __commonJS({
  "node_modules/openai/resources/fine-tuning/jobs/checkpoints.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Checkpoints = void 0;
    var resource_1 = require_resource();
    var pagination_1 = require_pagination();
    var path_1 = require_path();
    var Checkpoints = class extends resource_1.APIResource {
      /**
       * List checkpoints for a fine-tuning job.
       *
       * @example
       * ```ts
       * // Automatically fetches more pages as needed.
       * for await (const fineTuningJobCheckpoint of client.fineTuning.jobs.checkpoints.list(
       *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
       * )) {
       *   // ...
       * }
       * ```
       */
      list(fineTuningJobID, query = {}, options) {
        return this._client.getAPIList((0, path_1.path)`/fine_tuning/jobs/${fineTuningJobID}/checkpoints`, pagination_1.CursorPage, { query, ...options });
      }
    };
    exports.Checkpoints = Checkpoints;
  }
});

// node_modules/openai/resources/fine-tuning/jobs/jobs.js
var require_jobs = __commonJS({
  "node_modules/openai/resources/fine-tuning/jobs/jobs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Jobs = void 0;
    var tslib_1 = require_tslib();
    var resource_1 = require_resource();
    var CheckpointsAPI = tslib_1.__importStar(require_checkpoints2());
    var checkpoints_1 = require_checkpoints2();
    var pagination_1 = require_pagination();
    var path_1 = require_path();
    var Jobs = class extends resource_1.APIResource {
      constructor() {
        super(...arguments);
        this.checkpoints = new CheckpointsAPI.Checkpoints(this._client);
      }
      /**
       * Creates a fine-tuning job which begins the process of creating a new model from
       * a given dataset.
       *
       * Response includes details of the enqueued job including job status and the name
       * of the fine-tuned models once complete.
       *
       * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/model-optimization)
       *
       * @example
       * ```ts
       * const fineTuningJob = await client.fineTuning.jobs.create({
       *   model: 'gpt-4o-mini',
       *   training_file: 'file-abc123',
       * });
       * ```
       */
      create(body, options) {
        return this._client.post("/fine_tuning/jobs", { body, ...options });
      }
      /**
       * Get info about a fine-tuning job.
       *
       * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/model-optimization)
       *
       * @example
       * ```ts
       * const fineTuningJob = await client.fineTuning.jobs.retrieve(
       *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
       * );
       * ```
       */
      retrieve(fineTuningJobID, options) {
        return this._client.get((0, path_1.path)`/fine_tuning/jobs/${fineTuningJobID}`, options);
      }
      /**
       * List your organization's fine-tuning jobs
       *
       * @example
       * ```ts
       * // Automatically fetches more pages as needed.
       * for await (const fineTuningJob of client.fineTuning.jobs.list()) {
       *   // ...
       * }
       * ```
       */
      list(query = {}, options) {
        return this._client.getAPIList("/fine_tuning/jobs", pagination_1.CursorPage, { query, ...options });
      }
      /**
       * Immediately cancel a fine-tune job.
       *
       * @example
       * ```ts
       * const fineTuningJob = await client.fineTuning.jobs.cancel(
       *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
       * );
       * ```
       */
      cancel(fineTuningJobID, options) {
        return this._client.post((0, path_1.path)`/fine_tuning/jobs/${fineTuningJobID}/cancel`, options);
      }
      /**
       * Get status updates for a fine-tuning job.
       *
       * @example
       * ```ts
       * // Automatically fetches more pages as needed.
       * for await (const fineTuningJobEvent of client.fineTuning.jobs.listEvents(
       *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
       * )) {
       *   // ...
       * }
       * ```
       */
      listEvents(fineTuningJobID, query = {}, options) {
        return this._client.getAPIList((0, path_1.path)`/fine_tuning/jobs/${fineTuningJobID}/events`, pagination_1.CursorPage, { query, ...options });
      }
      /**
       * Pause a fine-tune job.
       *
       * @example
       * ```ts
       * const fineTuningJob = await client.fineTuning.jobs.pause(
       *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
       * );
       * ```
       */
      pause(fineTuningJobID, options) {
        return this._client.post((0, path_1.path)`/fine_tuning/jobs/${fineTuningJobID}/pause`, options);
      }
      /**
       * Resume a fine-tune job.
       *
       * @example
       * ```ts
       * const fineTuningJob = await client.fineTuning.jobs.resume(
       *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
       * );
       * ```
       */
      resume(fineTuningJobID, options) {
        return this._client.post((0, path_1.path)`/fine_tuning/jobs/${fineTuningJobID}/resume`, options);
      }
    };
    exports.Jobs = Jobs;
    Jobs.Checkpoints = checkpoints_1.Checkpoints;
  }
});

// node_modules/openai/resources/fine-tuning/fine-tuning.js
var require_fine_tuning = __commonJS({
  "node_modules/openai/resources/fine-tuning/fine-tuning.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FineTuning = void 0;
    var tslib_1 = require_tslib();
    var resource_1 = require_resource();
    var MethodsAPI = tslib_1.__importStar(require_methods());
    var methods_1 = require_methods();
    var AlphaAPI = tslib_1.__importStar(require_alpha());
    var alpha_1 = require_alpha();
    var CheckpointsAPI = tslib_1.__importStar(require_checkpoints());
    var checkpoints_1 = require_checkpoints();
    var JobsAPI = tslib_1.__importStar(require_jobs());
    var jobs_1 = require_jobs();
    var FineTuning = class extends resource_1.APIResource {
      constructor() {
        super(...arguments);
        this.methods = new MethodsAPI.Methods(this._client);
        this.jobs = new JobsAPI.Jobs(this._client);
        this.checkpoints = new CheckpointsAPI.Checkpoints(this._client);
        this.alpha = new AlphaAPI.Alpha(this._client);
      }
    };
    exports.FineTuning = FineTuning;
    FineTuning.Methods = methods_1.Methods;
    FineTuning.Jobs = jobs_1.Jobs;
    FineTuning.Checkpoints = checkpoints_1.Checkpoints;
    FineTuning.Alpha = alpha_1.Alpha;
  }
});

// node_modules/openai/resources/graders/grader-models.js
var require_grader_models = __commonJS({
  "node_modules/openai/resources/graders/grader-models.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GraderModels = void 0;
    var resource_1 = require_resource();
    var GraderModels = class extends resource_1.APIResource {
    };
    exports.GraderModels = GraderModels;
  }
});

// node_modules/openai/resources/graders/graders.js
var require_graders2 = __commonJS({
  "node_modules/openai/resources/graders/graders.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Graders = void 0;
    var tslib_1 = require_tslib();
    var resource_1 = require_resource();
    var GraderModelsAPI = tslib_1.__importStar(require_grader_models());
    var grader_models_1 = require_grader_models();
    var Graders = class extends resource_1.APIResource {
      constructor() {
        super(...arguments);
        this.graderModels = new GraderModelsAPI.GraderModels(this._client);
      }
    };
    exports.Graders = Graders;
    Graders.GraderModels = grader_models_1.GraderModels;
  }
});

// node_modules/openai/resources/images.js
var require_images = __commonJS({
  "node_modules/openai/resources/images.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Images = void 0;
    var resource_1 = require_resource();
    var uploads_1 = require_uploads();
    var Images = class extends resource_1.APIResource {
      /**
       * Creates a variation of a given image. This endpoint only supports `dall-e-2`.
       *
       * @example
       * ```ts
       * const imagesResponse = await client.images.createVariation({
       *   image: fs.createReadStream('otter.png'),
       * });
       * ```
       */
      createVariation(body, options) {
        return this._client.post("/images/variations", (0, uploads_1.multipartFormRequestOptions)({ body, ...options }, this._client));
      }
      edit(body, options) {
        return this._client.post("/images/edits", (0, uploads_1.multipartFormRequestOptions)({ body, ...options, stream: body.stream ?? false }, this._client));
      }
      generate(body, options) {
        return this._client.post("/images/generations", { body, ...options, stream: body.stream ?? false });
      }
    };
    exports.Images = Images;
  }
});

// node_modules/openai/resources/models.js
var require_models = __commonJS({
  "node_modules/openai/resources/models.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Models = void 0;
    var resource_1 = require_resource();
    var pagination_1 = require_pagination();
    var path_1 = require_path();
    var Models = class extends resource_1.APIResource {
      /**
       * Retrieves a model instance, providing basic information about the model such as
       * the owner and permissioning.
       */
      retrieve(model, options) {
        return this._client.get((0, path_1.path)`/models/${model}`, options);
      }
      /**
       * Lists the currently available models, and provides basic information about each
       * one such as the owner and availability.
       */
      list(options) {
        return this._client.getAPIList("/models", pagination_1.Page, options);
      }
      /**
       * Delete a fine-tuned model. You must have the Owner role in your organization to
       * delete a model.
       */
      delete(model, options) {
        return this._client.delete((0, path_1.path)`/models/${model}`, options);
      }
    };
    exports.Models = Models;
  }
});

// node_modules/openai/resources/moderations.js
var require_moderations = __commonJS({
  "node_modules/openai/resources/moderations.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Moderations = void 0;
    var resource_1 = require_resource();
    var Moderations = class extends resource_1.APIResource {
      /**
       * Classifies if text and/or image inputs are potentially harmful. Learn more in
       * the [moderation guide](https://platform.openai.com/docs/guides/moderation).
       */
      create(body, options) {
        return this._client.post("/moderations", { body, ...options });
      }
    };
    exports.Moderations = Moderations;
  }
});

// node_modules/openai/resources/realtime/client-secrets.js
var require_client_secrets = __commonJS({
  "node_modules/openai/resources/realtime/client-secrets.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClientSecrets = void 0;
    var resource_1 = require_resource();
    var ClientSecrets = class extends resource_1.APIResource {
      /**
       * Create a Realtime session and client secret for either realtime or
       * transcription.
       */
      create(body, options) {
        return this._client.post("/realtime/client_secrets", { body, ...options });
      }
    };
    exports.ClientSecrets = ClientSecrets;
  }
});

// node_modules/openai/resources/realtime/realtime.js
var require_realtime2 = __commonJS({
  "node_modules/openai/resources/realtime/realtime.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Realtime = void 0;
    var tslib_1 = require_tslib();
    var resource_1 = require_resource();
    var ClientSecretsAPI = tslib_1.__importStar(require_client_secrets());
    var client_secrets_1 = require_client_secrets();
    var Realtime = class extends resource_1.APIResource {
      constructor() {
        super(...arguments);
        this.clientSecrets = new ClientSecretsAPI.ClientSecrets(this._client);
      }
    };
    exports.Realtime = Realtime;
    Realtime.ClientSecrets = client_secrets_1.ClientSecrets;
  }
});

// node_modules/openai/lib/ResponsesParser.js
var require_ResponsesParser = __commonJS({
  "node_modules/openai/lib/ResponsesParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.maybeParseResponse = maybeParseResponse;
    exports.parseResponse = parseResponse;
    exports.hasAutoParseableInput = hasAutoParseableInput;
    exports.makeParseableResponseTool = makeParseableResponseTool;
    exports.isAutoParsableTool = isAutoParsableTool;
    exports.shouldParseToolCall = shouldParseToolCall;
    exports.validateInputTools = validateInputTools;
    exports.addOutputText = addOutputText;
    var error_1 = require_error2();
    var parser_1 = require_parser();
    function maybeParseResponse(response, params) {
      if (!params || !hasAutoParseableInput(params)) {
        return {
          ...response,
          output_parsed: null,
          output: response.output.map((item) => {
            if (item.type === "function_call") {
              return {
                ...item,
                parsed_arguments: null
              };
            }
            if (item.type === "message") {
              return {
                ...item,
                content: item.content.map((content) => ({
                  ...content,
                  parsed: null
                }))
              };
            } else {
              return item;
            }
          })
        };
      }
      return parseResponse(response, params);
    }
    function parseResponse(response, params) {
      const output = response.output.map((item) => {
        if (item.type === "function_call") {
          return {
            ...item,
            parsed_arguments: parseToolCall(params, item)
          };
        }
        if (item.type === "message") {
          const content = item.content.map((content2) => {
            if (content2.type === "output_text") {
              return {
                ...content2,
                parsed: parseTextFormat(params, content2.text)
              };
            }
            return content2;
          });
          return {
            ...item,
            content
          };
        }
        return item;
      });
      const parsed = Object.assign({}, response, { output });
      if (!Object.getOwnPropertyDescriptor(response, "output_text")) {
        addOutputText(parsed);
      }
      Object.defineProperty(parsed, "output_parsed", {
        enumerable: true,
        get() {
          for (const output2 of parsed.output) {
            if (output2.type !== "message") {
              continue;
            }
            for (const content of output2.content) {
              if (content.type === "output_text" && content.parsed !== null) {
                return content.parsed;
              }
            }
          }
          return null;
        }
      });
      return parsed;
    }
    function parseTextFormat(params, content) {
      var _a, _b, _c, _d;
      if (((_b = (_a = params.text) == null ? void 0 : _a.format) == null ? void 0 : _b.type) !== "json_schema") {
        return null;
      }
      if ("$parseRaw" in ((_c = params.text) == null ? void 0 : _c.format)) {
        const text_format = (_d = params.text) == null ? void 0 : _d.format;
        return text_format.$parseRaw(content);
      }
      return JSON.parse(content);
    }
    function hasAutoParseableInput(params) {
      var _a;
      if ((0, parser_1.isAutoParsableResponseFormat)((_a = params.text) == null ? void 0 : _a.format)) {
        return true;
      }
      return false;
    }
    function makeParseableResponseTool(tool, { parser, callback }) {
      const obj = { ...tool };
      Object.defineProperties(obj, {
        $brand: {
          value: "auto-parseable-tool",
          enumerable: false
        },
        $parseRaw: {
          value: parser,
          enumerable: false
        },
        $callback: {
          value: callback,
          enumerable: false
        }
      });
      return obj;
    }
    function isAutoParsableTool(tool) {
      return (tool == null ? void 0 : tool["$brand"]) === "auto-parseable-tool";
    }
    function getInputToolByName(input_tools, name) {
      return input_tools.find((tool) => tool.type === "function" && tool.name === name);
    }
    function parseToolCall(params, toolCall) {
      const inputTool = getInputToolByName(params.tools ?? [], toolCall.name);
      return {
        ...toolCall,
        ...toolCall,
        parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCall.arguments) : (inputTool == null ? void 0 : inputTool.strict) ? JSON.parse(toolCall.arguments) : null
      };
    }
    function shouldParseToolCall(params, toolCall) {
      if (!params) {
        return false;
      }
      const inputTool = getInputToolByName(params.tools ?? [], toolCall.name);
      return isAutoParsableTool(inputTool) || (inputTool == null ? void 0 : inputTool.strict) || false;
    }
    function validateInputTools(tools) {
      for (const tool of tools ?? []) {
        if (tool.type !== "function") {
          throw new error_1.OpenAIError(`Currently only \`function\` tool types support auto-parsing; Received \`${tool.type}\``);
        }
        if (tool.function.strict !== true) {
          throw new error_1.OpenAIError(`The \`${tool.function.name}\` tool is not marked with \`strict: true\`. Only strict function tools can be auto-parsed`);
        }
      }
    }
    function addOutputText(rsp) {
      const texts = [];
      for (const output of rsp.output) {
        if (output.type !== "message") {
          continue;
        }
        for (const content of output.content) {
          if (content.type === "output_text") {
            texts.push(content.text);
          }
        }
      }
      rsp.output_text = texts.join("");
    }
  }
});

// node_modules/openai/lib/responses/ResponseStream.js
var require_ResponseStream = __commonJS({
  "node_modules/openai/lib/responses/ResponseStream.js"(exports) {
    "use strict";
    var _ResponseStream_instances;
    var _ResponseStream_params;
    var _ResponseStream_currentResponseSnapshot;
    var _ResponseStream_finalResponse;
    var _ResponseStream_beginRequest;
    var _ResponseStream_addEvent;
    var _ResponseStream_endRequest;
    var _ResponseStream_accumulateResponse;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ResponseStream = void 0;
    var tslib_1 = require_tslib();
    var error_1 = require_error2();
    var EventStream_1 = require_EventStream();
    var ResponsesParser_1 = require_ResponsesParser();
    var ResponseStream = class _ResponseStream extends EventStream_1.EventStream {
      constructor(params) {
        super();
        _ResponseStream_instances.add(this);
        _ResponseStream_params.set(this, void 0);
        _ResponseStream_currentResponseSnapshot.set(this, void 0);
        _ResponseStream_finalResponse.set(this, void 0);
        tslib_1.__classPrivateFieldSet(this, _ResponseStream_params, params, "f");
      }
      static createResponse(client, params, options) {
        const runner = new _ResponseStream(params);
        runner._run(() => runner._createOrRetrieveResponse(client, params, {
          ...options,
          headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" }
        }));
        return runner;
      }
      async _createOrRetrieveResponse(client, params, options) {
        var _a;
        const signal = options == null ? void 0 : options.signal;
        if (signal) {
          if (signal.aborted)
            this.controller.abort();
          signal.addEventListener("abort", () => this.controller.abort());
        }
        tslib_1.__classPrivateFieldGet(this, _ResponseStream_instances, "m", _ResponseStream_beginRequest).call(this);
        let stream;
        let starting_after = null;
        if ("response_id" in params) {
          stream = await client.responses.retrieve(params.response_id, { stream: true }, { ...options, signal: this.controller.signal, stream: true });
          starting_after = params.starting_after ?? null;
        } else {
          stream = await client.responses.create({ ...params, stream: true }, { ...options, signal: this.controller.signal });
        }
        this._connected();
        for await (const event of stream) {
          tslib_1.__classPrivateFieldGet(this, _ResponseStream_instances, "m", _ResponseStream_addEvent).call(this, event, starting_after);
        }
        if ((_a = stream.controller.signal) == null ? void 0 : _a.aborted) {
          throw new error_1.APIUserAbortError();
        }
        return tslib_1.__classPrivateFieldGet(this, _ResponseStream_instances, "m", _ResponseStream_endRequest).call(this);
      }
      [(_ResponseStream_params = /* @__PURE__ */ new WeakMap(), _ResponseStream_currentResponseSnapshot = /* @__PURE__ */ new WeakMap(), _ResponseStream_finalResponse = /* @__PURE__ */ new WeakMap(), _ResponseStream_instances = /* @__PURE__ */ new WeakSet(), _ResponseStream_beginRequest = function _ResponseStream_beginRequest2() {
        if (this.ended)
          return;
        tslib_1.__classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, void 0, "f");
      }, _ResponseStream_addEvent = function _ResponseStream_addEvent2(event, starting_after) {
        if (this.ended)
          return;
        const maybeEmit = (name, event2) => {
          if (starting_after == null || event2.sequence_number > starting_after) {
            this._emit(name, event2);
          }
        };
        const response = tslib_1.__classPrivateFieldGet(this, _ResponseStream_instances, "m", _ResponseStream_accumulateResponse).call(this, event);
        maybeEmit("event", event);
        switch (event.type) {
          case "response.output_text.delta": {
            const output = response.output[event.output_index];
            if (!output) {
              throw new error_1.OpenAIError(`missing output at index ${event.output_index}`);
            }
            if (output.type === "message") {
              const content = output.content[event.content_index];
              if (!content) {
                throw new error_1.OpenAIError(`missing content at index ${event.content_index}`);
              }
              if (content.type !== "output_text") {
                throw new error_1.OpenAIError(`expected content to be 'output_text', got ${content.type}`);
              }
              maybeEmit("response.output_text.delta", {
                ...event,
                snapshot: content.text
              });
            }
            break;
          }
          case "response.function_call_arguments.delta": {
            const output = response.output[event.output_index];
            if (!output) {
              throw new error_1.OpenAIError(`missing output at index ${event.output_index}`);
            }
            if (output.type === "function_call") {
              maybeEmit("response.function_call_arguments.delta", {
                ...event,
                snapshot: output.arguments
              });
            }
            break;
          }
          default:
            maybeEmit(event.type, event);
            break;
        }
      }, _ResponseStream_endRequest = function _ResponseStream_endRequest2() {
        if (this.ended) {
          throw new error_1.OpenAIError(`stream has ended, this shouldn't happen`);
        }
        const snapshot = tslib_1.__classPrivateFieldGet(this, _ResponseStream_currentResponseSnapshot, "f");
        if (!snapshot) {
          throw new error_1.OpenAIError(`request ended without sending any events`);
        }
        tslib_1.__classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, void 0, "f");
        const parsedResponse = finalizeResponse(snapshot, tslib_1.__classPrivateFieldGet(this, _ResponseStream_params, "f"));
        tslib_1.__classPrivateFieldSet(this, _ResponseStream_finalResponse, parsedResponse, "f");
        return parsedResponse;
      }, _ResponseStream_accumulateResponse = function _ResponseStream_accumulateResponse2(event) {
        let snapshot = tslib_1.__classPrivateFieldGet(this, _ResponseStream_currentResponseSnapshot, "f");
        if (!snapshot) {
          if (event.type !== "response.created") {
            throw new error_1.OpenAIError(`When snapshot hasn't been set yet, expected 'response.created' event, got ${event.type}`);
          }
          snapshot = tslib_1.__classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, event.response, "f");
          return snapshot;
        }
        switch (event.type) {
          case "response.output_item.added": {
            snapshot.output.push(event.item);
            break;
          }
          case "response.content_part.added": {
            const output = snapshot.output[event.output_index];
            if (!output) {
              throw new error_1.OpenAIError(`missing output at index ${event.output_index}`);
            }
            if (output.type === "message") {
              output.content.push(event.part);
            }
            break;
          }
          case "response.output_text.delta": {
            const output = snapshot.output[event.output_index];
            if (!output) {
              throw new error_1.OpenAIError(`missing output at index ${event.output_index}`);
            }
            if (output.type === "message") {
              const content = output.content[event.content_index];
              if (!content) {
                throw new error_1.OpenAIError(`missing content at index ${event.content_index}`);
              }
              if (content.type !== "output_text") {
                throw new error_1.OpenAIError(`expected content to be 'output_text', got ${content.type}`);
              }
              content.text += event.delta;
            }
            break;
          }
          case "response.function_call_arguments.delta": {
            const output = snapshot.output[event.output_index];
            if (!output) {
              throw new error_1.OpenAIError(`missing output at index ${event.output_index}`);
            }
            if (output.type === "function_call") {
              output.arguments += event.delta;
            }
            break;
          }
          case "response.completed": {
            tslib_1.__classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, event.response, "f");
            break;
          }
        }
        return snapshot;
      }, Symbol.asyncIterator)]() {
        const pushQueue = [];
        const readQueue = [];
        let done = false;
        this.on("event", (event) => {
          const reader = readQueue.shift();
          if (reader) {
            reader.resolve(event);
          } else {
            pushQueue.push(event);
          }
        });
        this.on("end", () => {
          done = true;
          for (const reader of readQueue) {
            reader.resolve(void 0);
          }
          readQueue.length = 0;
        });
        this.on("abort", (err) => {
          done = true;
          for (const reader of readQueue) {
            reader.reject(err);
          }
          readQueue.length = 0;
        });
        this.on("error", (err) => {
          done = true;
          for (const reader of readQueue) {
            reader.reject(err);
          }
          readQueue.length = 0;
        });
        return {
          next: async () => {
            if (!pushQueue.length) {
              if (done) {
                return { value: void 0, done: true };
              }
              return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((event2) => event2 ? { value: event2, done: false } : { value: void 0, done: true });
            }
            const event = pushQueue.shift();
            return { value: event, done: false };
          },
          return: async () => {
            this.abort();
            return { value: void 0, done: true };
          }
        };
      }
      /**
       * @returns a promise that resolves with the final Response, or rejects
       * if an error occurred or the stream ended prematurely without producing a REsponse.
       */
      async finalResponse() {
        await this.done();
        const response = tslib_1.__classPrivateFieldGet(this, _ResponseStream_finalResponse, "f");
        if (!response)
          throw new error_1.OpenAIError("stream ended without producing a ChatCompletion");
        return response;
      }
    };
    exports.ResponseStream = ResponseStream;
    function finalizeResponse(snapshot, params) {
      return (0, ResponsesParser_1.maybeParseResponse)(snapshot, params);
    }
  }
});

// node_modules/openai/resources/responses/input-items.js
var require_input_items = __commonJS({
  "node_modules/openai/resources/responses/input-items.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InputItems = void 0;
    var resource_1 = require_resource();
    var pagination_1 = require_pagination();
    var path_1 = require_path();
    var InputItems = class extends resource_1.APIResource {
      /**
       * Returns a list of input items for a given response.
       *
       * @example
       * ```ts
       * // Automatically fetches more pages as needed.
       * for await (const responseItem of client.responses.inputItems.list(
       *   'response_id',
       * )) {
       *   // ...
       * }
       * ```
       */
      list(responseID, query = {}, options) {
        return this._client.getAPIList((0, path_1.path)`/responses/${responseID}/input_items`, pagination_1.CursorPage, { query, ...options });
      }
    };
    exports.InputItems = InputItems;
  }
});

// node_modules/openai/resources/responses/responses.js
var require_responses = __commonJS({
  "node_modules/openai/resources/responses/responses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Responses = void 0;
    var tslib_1 = require_tslib();
    var ResponsesParser_1 = require_ResponsesParser();
    var ResponseStream_1 = require_ResponseStream();
    var resource_1 = require_resource();
    var InputItemsAPI = tslib_1.__importStar(require_input_items());
    var input_items_1 = require_input_items();
    var headers_1 = require_headers();
    var path_1 = require_path();
    var Responses = class extends resource_1.APIResource {
      constructor() {
        super(...arguments);
        this.inputItems = new InputItemsAPI.InputItems(this._client);
      }
      create(body, options) {
        return this._client.post("/responses", { body, ...options, stream: body.stream ?? false })._thenUnwrap((rsp) => {
          if ("object" in rsp && rsp.object === "response") {
            (0, ResponsesParser_1.addOutputText)(rsp);
          }
          return rsp;
        });
      }
      retrieve(responseID, query = {}, options) {
        return this._client.get((0, path_1.path)`/responses/${responseID}`, {
          query,
          ...options,
          stream: (query == null ? void 0 : query.stream) ?? false
        })._thenUnwrap((rsp) => {
          if ("object" in rsp && rsp.object === "response") {
            (0, ResponsesParser_1.addOutputText)(rsp);
          }
          return rsp;
        });
      }
      /**
       * Deletes a model response with the given ID.
       *
       * @example
       * ```ts
       * await client.responses.delete(
       *   'resp_677efb5139a88190b512bc3fef8e535d',
       * );
       * ```
       */
      delete(responseID, options) {
        return this._client.delete((0, path_1.path)`/responses/${responseID}`, {
          ...options,
          headers: (0, headers_1.buildHeaders)([{ Accept: "*/*" }, options == null ? void 0 : options.headers])
        });
      }
      parse(body, options) {
        return this._client.responses.create(body, options)._thenUnwrap((response) => (0, ResponsesParser_1.parseResponse)(response, body));
      }
      /**
       * Creates a model response stream
       */
      stream(body, options) {
        return ResponseStream_1.ResponseStream.createResponse(this._client, body, options);
      }
      /**
       * Cancels a model response with the given ID. Only responses created with the
       * `background` parameter set to `true` can be cancelled.
       * [Learn more](https://platform.openai.com/docs/guides/background).
       *
       * @example
       * ```ts
       * const response = await client.responses.cancel(
       *   'resp_677efb5139a88190b512bc3fef8e535d',
       * );
       * ```
       */
      cancel(responseID, options) {
        return this._client.post((0, path_1.path)`/responses/${responseID}/cancel`, options);
      }
    };
    exports.Responses = Responses;
    Responses.InputItems = input_items_1.InputItems;
  }
});

// node_modules/openai/resources/uploads/parts.js
var require_parts = __commonJS({
  "node_modules/openai/resources/uploads/parts.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Parts = void 0;
    var resource_1 = require_resource();
    var uploads_1 = require_uploads();
    var path_1 = require_path();
    var Parts = class extends resource_1.APIResource {
      /**
       * Adds a
       * [Part](https://platform.openai.com/docs/api-reference/uploads/part-object) to an
       * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object.
       * A Part represents a chunk of bytes from the file you are trying to upload.
       *
       * Each Part can be at most 64 MB, and you can add Parts until you hit the Upload
       * maximum of 8 GB.
       *
       * It is possible to add multiple Parts in parallel. You can decide the intended
       * order of the Parts when you
       * [complete the Upload](https://platform.openai.com/docs/api-reference/uploads/complete).
       */
      create(uploadID, body, options) {
        return this._client.post((0, path_1.path)`/uploads/${uploadID}/parts`, (0, uploads_1.multipartFormRequestOptions)({ body, ...options }, this._client));
      }
    };
    exports.Parts = Parts;
  }
});

// node_modules/openai/resources/uploads/uploads.js
var require_uploads3 = __commonJS({
  "node_modules/openai/resources/uploads/uploads.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Uploads = void 0;
    var tslib_1 = require_tslib();
    var resource_1 = require_resource();
    var PartsAPI = tslib_1.__importStar(require_parts());
    var parts_1 = require_parts();
    var path_1 = require_path();
    var Uploads = class extends resource_1.APIResource {
      constructor() {
        super(...arguments);
        this.parts = new PartsAPI.Parts(this._client);
      }
      /**
       * Creates an intermediate
       * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object
       * that you can add
       * [Parts](https://platform.openai.com/docs/api-reference/uploads/part-object) to.
       * Currently, an Upload can accept at most 8 GB in total and expires after an hour
       * after you create it.
       *
       * Once you complete the Upload, we will create a
       * [File](https://platform.openai.com/docs/api-reference/files/object) object that
       * contains all the parts you uploaded. This File is usable in the rest of our
       * platform as a regular File object.
       *
       * For certain `purpose` values, the correct `mime_type` must be specified. Please
       * refer to documentation for the
       * [supported MIME types for your use case](https://platform.openai.com/docs/assistants/tools/file-search#supported-files).
       *
       * For guidance on the proper filename extensions for each purpose, please follow
       * the documentation on
       * [creating a File](https://platform.openai.com/docs/api-reference/files/create).
       */
      create(body, options) {
        return this._client.post("/uploads", { body, ...options });
      }
      /**
       * Cancels the Upload. No Parts may be added after an Upload is cancelled.
       */
      cancel(uploadID, options) {
        return this._client.post((0, path_1.path)`/uploads/${uploadID}/cancel`, options);
      }
      /**
       * Completes the
       * [Upload](https://platform.openai.com/docs/api-reference/uploads/object).
       *
       * Within the returned Upload object, there is a nested
       * [File](https://platform.openai.com/docs/api-reference/files/object) object that
       * is ready to use in the rest of the platform.
       *
       * You can specify the order of the Parts by passing in an ordered list of the Part
       * IDs.
       *
       * The number of bytes uploaded upon completion must match the number of bytes
       * initially specified when creating the Upload object. No Parts may be added after
       * an Upload is completed.
       */
      complete(uploadID, body, options) {
        return this._client.post((0, path_1.path)`/uploads/${uploadID}/complete`, { body, ...options });
      }
    };
    exports.Uploads = Uploads;
    Uploads.Parts = parts_1.Parts;
  }
});

// node_modules/openai/lib/Util.js
var require_Util = __commonJS({
  "node_modules/openai/lib/Util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.allSettledWithThrow = void 0;
    var allSettledWithThrow = async (promises) => {
      const results = await Promise.allSettled(promises);
      const rejected = results.filter((result) => result.status === "rejected");
      if (rejected.length) {
        for (const result of rejected) {
          console.error(result.reason);
        }
        throw new Error(`${rejected.length} promise(s) failed - see the above errors`);
      }
      const values = [];
      for (const result of results) {
        if (result.status === "fulfilled") {
          values.push(result.value);
        }
      }
      return values;
    };
    exports.allSettledWithThrow = allSettledWithThrow;
  }
});

// node_modules/openai/resources/vector-stores/file-batches.js
var require_file_batches = __commonJS({
  "node_modules/openai/resources/vector-stores/file-batches.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FileBatches = void 0;
    var resource_1 = require_resource();
    var pagination_1 = require_pagination();
    var headers_1 = require_headers();
    var sleep_1 = require_sleep();
    var Util_1 = require_Util();
    var path_1 = require_path();
    var FileBatches = class extends resource_1.APIResource {
      /**
       * Create a vector store file batch.
       */
      create(vectorStoreID, body, options) {
        return this._client.post((0, path_1.path)`/vector_stores/${vectorStoreID}/file_batches`, {
          body,
          ...options,
          headers: (0, headers_1.buildHeaders)([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
        });
      }
      /**
       * Retrieves a vector store file batch.
       */
      retrieve(batchID, params, options) {
        const { vector_store_id } = params;
        return this._client.get((0, path_1.path)`/vector_stores/${vector_store_id}/file_batches/${batchID}`, {
          ...options,
          headers: (0, headers_1.buildHeaders)([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
        });
      }
      /**
       * Cancel a vector store file batch. This attempts to cancel the processing of
       * files in this batch as soon as possible.
       */
      cancel(batchID, params, options) {
        const { vector_store_id } = params;
        return this._client.post((0, path_1.path)`/vector_stores/${vector_store_id}/file_batches/${batchID}/cancel`, {
          ...options,
          headers: (0, headers_1.buildHeaders)([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
        });
      }
      /**
       * Create a vector store batch and poll until all files have been processed.
       */
      async createAndPoll(vectorStoreId, body, options) {
        const batch = await this.create(vectorStoreId, body);
        return await this.poll(vectorStoreId, batch.id, options);
      }
      /**
       * Returns a list of vector store files in a batch.
       */
      listFiles(batchID, params, options) {
        const { vector_store_id, ...query } = params;
        return this._client.getAPIList((0, path_1.path)`/vector_stores/${vector_store_id}/file_batches/${batchID}/files`, pagination_1.CursorPage, { query, ...options, headers: (0, headers_1.buildHeaders)([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers]) });
      }
      /**
       * Wait for the given file batch to be processed.
       *
       * Note: this will return even if one of the files failed to process, you need to
       * check batch.file_counts.failed_count to handle this case.
       */
      async poll(vectorStoreID, batchID, options) {
        var _a;
        const headers = (0, headers_1.buildHeaders)([
          options == null ? void 0 : options.headers,
          {
            "X-Stainless-Poll-Helper": "true",
            "X-Stainless-Custom-Poll-Interval": ((_a = options == null ? void 0 : options.pollIntervalMs) == null ? void 0 : _a.toString()) ?? void 0
          }
        ]);
        while (true) {
          const { data: batch, response } = await this.retrieve(batchID, { vector_store_id: vectorStoreID }, {
            ...options,
            headers
          }).withResponse();
          switch (batch.status) {
            case "in_progress":
              let sleepInterval = 5e3;
              if (options == null ? void 0 : options.pollIntervalMs) {
                sleepInterval = options.pollIntervalMs;
              } else {
                const headerInterval = response.headers.get("openai-poll-after-ms");
                if (headerInterval) {
                  const headerIntervalMs = parseInt(headerInterval);
                  if (!isNaN(headerIntervalMs)) {
                    sleepInterval = headerIntervalMs;
                  }
                }
              }
              await (0, sleep_1.sleep)(sleepInterval);
              break;
            case "failed":
            case "cancelled":
            case "completed":
              return batch;
          }
        }
      }
      /**
       * Uploads the given files concurrently and then creates a vector store file batch.
       *
       * The concurrency limit is configurable using the `maxConcurrency` parameter.
       */
      async uploadAndPoll(vectorStoreId, { files, fileIds = [] }, options) {
        if (files == null || files.length == 0) {
          throw new Error(`No \`files\` provided to process. If you've already uploaded files you should use \`.createAndPoll()\` instead`);
        }
        const configuredConcurrency = (options == null ? void 0 : options.maxConcurrency) ?? 5;
        const concurrencyLimit = Math.min(configuredConcurrency, files.length);
        const client = this._client;
        const fileIterator = files.values();
        const allFileIds = [...fileIds];
        async function processFiles(iterator) {
          for (let item of iterator) {
            const fileObj = await client.files.create({ file: item, purpose: "assistants" }, options);
            allFileIds.push(fileObj.id);
          }
        }
        const workers = Array(concurrencyLimit).fill(fileIterator).map(processFiles);
        await (0, Util_1.allSettledWithThrow)(workers);
        return await this.createAndPoll(vectorStoreId, {
          file_ids: allFileIds
        });
      }
    };
    exports.FileBatches = FileBatches;
  }
});

// node_modules/openai/resources/vector-stores/files.js
var require_files3 = __commonJS({
  "node_modules/openai/resources/vector-stores/files.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Files = void 0;
    var resource_1 = require_resource();
    var pagination_1 = require_pagination();
    var headers_1 = require_headers();
    var utils_1 = require_utils2();
    var path_1 = require_path();
    var Files = class extends resource_1.APIResource {
      /**
       * Create a vector store file by attaching a
       * [File](https://platform.openai.com/docs/api-reference/files) to a
       * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object).
       */
      create(vectorStoreID, body, options) {
        return this._client.post((0, path_1.path)`/vector_stores/${vectorStoreID}/files`, {
          body,
          ...options,
          headers: (0, headers_1.buildHeaders)([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
        });
      }
      /**
       * Retrieves a vector store file.
       */
      retrieve(fileID, params, options) {
        const { vector_store_id } = params;
        return this._client.get((0, path_1.path)`/vector_stores/${vector_store_id}/files/${fileID}`, {
          ...options,
          headers: (0, headers_1.buildHeaders)([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
        });
      }
      /**
       * Update attributes on a vector store file.
       */
      update(fileID, params, options) {
        const { vector_store_id, ...body } = params;
        return this._client.post((0, path_1.path)`/vector_stores/${vector_store_id}/files/${fileID}`, {
          body,
          ...options,
          headers: (0, headers_1.buildHeaders)([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
        });
      }
      /**
       * Returns a list of vector store files.
       */
      list(vectorStoreID, query = {}, options) {
        return this._client.getAPIList((0, path_1.path)`/vector_stores/${vectorStoreID}/files`, pagination_1.CursorPage, {
          query,
          ...options,
          headers: (0, headers_1.buildHeaders)([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
        });
      }
      /**
       * Delete a vector store file. This will remove the file from the vector store but
       * the file itself will not be deleted. To delete the file, use the
       * [delete file](https://platform.openai.com/docs/api-reference/files/delete)
       * endpoint.
       */
      delete(fileID, params, options) {
        const { vector_store_id } = params;
        return this._client.delete((0, path_1.path)`/vector_stores/${vector_store_id}/files/${fileID}`, {
          ...options,
          headers: (0, headers_1.buildHeaders)([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
        });
      }
      /**
       * Attach a file to the given vector store and wait for it to be processed.
       */
      async createAndPoll(vectorStoreId, body, options) {
        const file = await this.create(vectorStoreId, body, options);
        return await this.poll(vectorStoreId, file.id, options);
      }
      /**
       * Wait for the vector store file to finish processing.
       *
       * Note: this will return even if the file failed to process, you need to check
       * file.last_error and file.status to handle these cases
       */
      async poll(vectorStoreID, fileID, options) {
        var _a;
        const headers = (0, headers_1.buildHeaders)([
          options == null ? void 0 : options.headers,
          {
            "X-Stainless-Poll-Helper": "true",
            "X-Stainless-Custom-Poll-Interval": ((_a = options == null ? void 0 : options.pollIntervalMs) == null ? void 0 : _a.toString()) ?? void 0
          }
        ]);
        while (true) {
          const fileResponse = await this.retrieve(fileID, {
            vector_store_id: vectorStoreID
          }, { ...options, headers }).withResponse();
          const file = fileResponse.data;
          switch (file.status) {
            case "in_progress":
              let sleepInterval = 5e3;
              if (options == null ? void 0 : options.pollIntervalMs) {
                sleepInterval = options.pollIntervalMs;
              } else {
                const headerInterval = fileResponse.response.headers.get("openai-poll-after-ms");
                if (headerInterval) {
                  const headerIntervalMs = parseInt(headerInterval);
                  if (!isNaN(headerIntervalMs)) {
                    sleepInterval = headerIntervalMs;
                  }
                }
              }
              await (0, utils_1.sleep)(sleepInterval);
              break;
            case "failed":
            case "completed":
              return file;
          }
        }
      }
      /**
       * Upload a file to the `files` API and then attach it to the given vector store.
       *
       * Note the file will be asynchronously processed (you can use the alternative
       * polling helper method to wait for processing to complete).
       */
      async upload(vectorStoreId, file, options) {
        const fileInfo = await this._client.files.create({ file, purpose: "assistants" }, options);
        return this.create(vectorStoreId, { file_id: fileInfo.id }, options);
      }
      /**
       * Add a file to a vector store and poll until processing is complete.
       */
      async uploadAndPoll(vectorStoreId, file, options) {
        const fileInfo = await this.upload(vectorStoreId, file, options);
        return await this.poll(vectorStoreId, fileInfo.id, options);
      }
      /**
       * Retrieve the parsed contents of a vector store file.
       */
      content(fileID, params, options) {
        const { vector_store_id } = params;
        return this._client.getAPIList((0, path_1.path)`/vector_stores/${vector_store_id}/files/${fileID}/content`, pagination_1.Page, { ...options, headers: (0, headers_1.buildHeaders)([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers]) });
      }
    };
    exports.Files = Files;
  }
});

// node_modules/openai/resources/vector-stores/vector-stores.js
var require_vector_stores = __commonJS({
  "node_modules/openai/resources/vector-stores/vector-stores.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VectorStores = void 0;
    var tslib_1 = require_tslib();
    var resource_1 = require_resource();
    var FileBatchesAPI = tslib_1.__importStar(require_file_batches());
    var file_batches_1 = require_file_batches();
    var FilesAPI = tslib_1.__importStar(require_files3());
    var files_1 = require_files3();
    var pagination_1 = require_pagination();
    var headers_1 = require_headers();
    var path_1 = require_path();
    var VectorStores = class extends resource_1.APIResource {
      constructor() {
        super(...arguments);
        this.files = new FilesAPI.Files(this._client);
        this.fileBatches = new FileBatchesAPI.FileBatches(this._client);
      }
      /**
       * Create a vector store.
       */
      create(body, options) {
        return this._client.post("/vector_stores", {
          body,
          ...options,
          headers: (0, headers_1.buildHeaders)([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
        });
      }
      /**
       * Retrieves a vector store.
       */
      retrieve(vectorStoreID, options) {
        return this._client.get((0, path_1.path)`/vector_stores/${vectorStoreID}`, {
          ...options,
          headers: (0, headers_1.buildHeaders)([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
        });
      }
      /**
       * Modifies a vector store.
       */
      update(vectorStoreID, body, options) {
        return this._client.post((0, path_1.path)`/vector_stores/${vectorStoreID}`, {
          body,
          ...options,
          headers: (0, headers_1.buildHeaders)([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
        });
      }
      /**
       * Returns a list of vector stores.
       */
      list(query = {}, options) {
        return this._client.getAPIList("/vector_stores", pagination_1.CursorPage, {
          query,
          ...options,
          headers: (0, headers_1.buildHeaders)([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
        });
      }
      /**
       * Delete a vector store.
       */
      delete(vectorStoreID, options) {
        return this._client.delete((0, path_1.path)`/vector_stores/${vectorStoreID}`, {
          ...options,
          headers: (0, headers_1.buildHeaders)([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
        });
      }
      /**
       * Search a vector store for relevant chunks based on a query and file attributes
       * filter.
       */
      search(vectorStoreID, body, options) {
        return this._client.getAPIList((0, path_1.path)`/vector_stores/${vectorStoreID}/search`, pagination_1.Page, {
          body,
          method: "post",
          ...options,
          headers: (0, headers_1.buildHeaders)([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
        });
      }
    };
    exports.VectorStores = VectorStores;
    VectorStores.Files = files_1.Files;
    VectorStores.FileBatches = file_batches_1.FileBatches;
  }
});

// node_modules/openai/resources/webhooks.js
var require_webhooks = __commonJS({
  "node_modules/openai/resources/webhooks.js"(exports) {
    "use strict";
    var _Webhooks_instances;
    var _Webhooks_validateSecret;
    var _Webhooks_getRequiredHeader;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Webhooks = void 0;
    var tslib_1 = require_tslib();
    var error_1 = require_error2();
    var resource_1 = require_resource();
    var headers_1 = require_headers();
    var Webhooks = class extends resource_1.APIResource {
      constructor() {
        super(...arguments);
        _Webhooks_instances.add(this);
      }
      /**
       * Validates that the given payload was sent by OpenAI and parses the payload.
       */
      async unwrap(payload, headers, secret = this._client.webhookSecret, tolerance = 300) {
        await this.verifySignature(payload, headers, secret, tolerance);
        return JSON.parse(payload);
      }
      /**
       * Validates whether or not the webhook payload was sent by OpenAI.
       *
       * An error will be raised if the webhook payload was not sent by OpenAI.
       *
       * @param payload - The webhook payload
       * @param headers - The webhook headers
       * @param secret - The webhook secret (optional, will use client secret if not provided)
       * @param tolerance - Maximum age of the webhook in seconds (default: 300 = 5 minutes)
       */
      async verifySignature(payload, headers, secret = this._client.webhookSecret, tolerance = 300) {
        if (typeof crypto === "undefined" || typeof crypto.subtle.importKey !== "function" || typeof crypto.subtle.verify !== "function") {
          throw new Error("Webhook signature verification is only supported when the `crypto` global is defined");
        }
        tslib_1.__classPrivateFieldGet(this, _Webhooks_instances, "m", _Webhooks_validateSecret).call(this, secret);
        const headersObj = (0, headers_1.buildHeaders)([headers]).values;
        const signatureHeader = tslib_1.__classPrivateFieldGet(this, _Webhooks_instances, "m", _Webhooks_getRequiredHeader).call(this, headersObj, "webhook-signature");
        const timestamp = tslib_1.__classPrivateFieldGet(this, _Webhooks_instances, "m", _Webhooks_getRequiredHeader).call(this, headersObj, "webhook-timestamp");
        const webhookId = tslib_1.__classPrivateFieldGet(this, _Webhooks_instances, "m", _Webhooks_getRequiredHeader).call(this, headersObj, "webhook-id");
        const timestampSeconds = parseInt(timestamp, 10);
        if (isNaN(timestampSeconds)) {
          throw new error_1.InvalidWebhookSignatureError("Invalid webhook timestamp format");
        }
        const nowSeconds = Math.floor(Date.now() / 1e3);
        if (nowSeconds - timestampSeconds > tolerance) {
          throw new error_1.InvalidWebhookSignatureError("Webhook timestamp is too old");
        }
        if (timestampSeconds > nowSeconds + tolerance) {
          throw new error_1.InvalidWebhookSignatureError("Webhook timestamp is too new");
        }
        const signatures = signatureHeader.split(" ").map((part) => part.startsWith("v1,") ? part.substring(3) : part);
        const decodedSecret = secret.startsWith("whsec_") ? Buffer.from(secret.replace("whsec_", ""), "base64") : Buffer.from(secret, "utf-8");
        const signedPayload = webhookId ? `${webhookId}.${timestamp}.${payload}` : `${timestamp}.${payload}`;
        const key = await crypto.subtle.importKey("raw", decodedSecret, { name: "HMAC", hash: "SHA-256" }, false, ["verify"]);
        for (const signature of signatures) {
          try {
            const signatureBytes = Buffer.from(signature, "base64");
            const isValid = await crypto.subtle.verify("HMAC", key, signatureBytes, new TextEncoder().encode(signedPayload));
            if (isValid) {
              return;
            }
          } catch {
            continue;
          }
        }
        throw new error_1.InvalidWebhookSignatureError("The given webhook signature does not match the expected signature");
      }
    };
    exports.Webhooks = Webhooks;
    _Webhooks_instances = /* @__PURE__ */ new WeakSet(), _Webhooks_validateSecret = function _Webhooks_validateSecret2(secret) {
      if (typeof secret !== "string" || secret.length === 0) {
        throw new Error(`The webhook secret must either be set using the env var, OPENAI_WEBHOOK_SECRET, on the client class, OpenAI({ webhookSecret: '123' }), or passed to this function`);
      }
    }, _Webhooks_getRequiredHeader = function _Webhooks_getRequiredHeader2(headers, name) {
      if (!headers) {
        throw new Error(`Headers are required`);
      }
      const value = headers.get(name);
      if (value === null || value === void 0) {
        throw new Error(`Missing required header: ${name}`);
      }
      return value;
    };
  }
});

// node_modules/openai/resources/index.js
var require_resources = __commonJS({
  "node_modules/openai/resources/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Webhooks = exports.VectorStores = exports.Uploads = exports.Responses = exports.Realtime = exports.Moderations = exports.Models = exports.Images = exports.Graders = exports.FineTuning = exports.Files = exports.Evals = exports.Embeddings = exports.Conversations = exports.Containers = exports.Completions = exports.Beta = exports.Batches = exports.Audio = void 0;
    var tslib_1 = require_tslib();
    tslib_1.__exportStar(require_chat2(), exports);
    tslib_1.__exportStar(require_shared(), exports);
    var audio_1 = require_audio();
    Object.defineProperty(exports, "Audio", { enumerable: true, get: function() {
      return audio_1.Audio;
    } });
    var batches_1 = require_batches();
    Object.defineProperty(exports, "Batches", { enumerable: true, get: function() {
      return batches_1.Batches;
    } });
    var beta_1 = require_beta();
    Object.defineProperty(exports, "Beta", { enumerable: true, get: function() {
      return beta_1.Beta;
    } });
    var completions_1 = require_completions3();
    Object.defineProperty(exports, "Completions", { enumerable: true, get: function() {
      return completions_1.Completions;
    } });
    var containers_1 = require_containers();
    Object.defineProperty(exports, "Containers", { enumerable: true, get: function() {
      return containers_1.Containers;
    } });
    var conversations_1 = require_conversations();
    Object.defineProperty(exports, "Conversations", { enumerable: true, get: function() {
      return conversations_1.Conversations;
    } });
    var embeddings_1 = require_embeddings();
    Object.defineProperty(exports, "Embeddings", { enumerable: true, get: function() {
      return embeddings_1.Embeddings;
    } });
    var evals_1 = require_evals();
    Object.defineProperty(exports, "Evals", { enumerable: true, get: function() {
      return evals_1.Evals;
    } });
    var files_1 = require_files2();
    Object.defineProperty(exports, "Files", { enumerable: true, get: function() {
      return files_1.Files;
    } });
    var fine_tuning_1 = require_fine_tuning();
    Object.defineProperty(exports, "FineTuning", { enumerable: true, get: function() {
      return fine_tuning_1.FineTuning;
    } });
    var graders_1 = require_graders2();
    Object.defineProperty(exports, "Graders", { enumerable: true, get: function() {
      return graders_1.Graders;
    } });
    var images_1 = require_images();
    Object.defineProperty(exports, "Images", { enumerable: true, get: function() {
      return images_1.Images;
    } });
    var models_1 = require_models();
    Object.defineProperty(exports, "Models", { enumerable: true, get: function() {
      return models_1.Models;
    } });
    var moderations_1 = require_moderations();
    Object.defineProperty(exports, "Moderations", { enumerable: true, get: function() {
      return moderations_1.Moderations;
    } });
    var realtime_1 = require_realtime2();
    Object.defineProperty(exports, "Realtime", { enumerable: true, get: function() {
      return realtime_1.Realtime;
    } });
    var responses_1 = require_responses();
    Object.defineProperty(exports, "Responses", { enumerable: true, get: function() {
      return responses_1.Responses;
    } });
    var uploads_1 = require_uploads3();
    Object.defineProperty(exports, "Uploads", { enumerable: true, get: function() {
      return uploads_1.Uploads;
    } });
    var vector_stores_1 = require_vector_stores();
    Object.defineProperty(exports, "VectorStores", { enumerable: true, get: function() {
      return vector_stores_1.VectorStores;
    } });
    var webhooks_1 = require_webhooks();
    Object.defineProperty(exports, "Webhooks", { enumerable: true, get: function() {
      return webhooks_1.Webhooks;
    } });
  }
});

// node_modules/openai/client.js
var require_client = __commonJS({
  "node_modules/openai/client.js"(exports) {
    "use strict";
    var _OpenAI_instances;
    var _a;
    var _OpenAI_encoder;
    var _OpenAI_baseURLOverridden;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OpenAI = void 0;
    var tslib_1 = require_tslib();
    var uuid_1 = require_uuid();
    var values_1 = require_values();
    var sleep_1 = require_sleep();
    var errors_1 = require_errors();
    var detect_platform_1 = require_detect_platform();
    var Shims = tslib_1.__importStar(require_shims());
    var Opts = tslib_1.__importStar(require_request_options());
    var qs = tslib_1.__importStar(require_qs());
    var version_1 = require_version();
    var Errors = tslib_1.__importStar(require_error());
    var Pagination = tslib_1.__importStar(require_pagination());
    var Uploads = tslib_1.__importStar(require_uploads2());
    var API = tslib_1.__importStar(require_resources());
    var api_promise_1 = require_api_promise();
    var batches_1 = require_batches();
    var completions_1 = require_completions3();
    var embeddings_1 = require_embeddings();
    var files_1 = require_files2();
    var images_1 = require_images();
    var models_1 = require_models();
    var moderations_1 = require_moderations();
    var webhooks_1 = require_webhooks();
    var audio_1 = require_audio();
    var beta_1 = require_beta();
    var chat_1 = require_chat();
    var containers_1 = require_containers();
    var conversations_1 = require_conversations();
    var evals_1 = require_evals();
    var fine_tuning_1 = require_fine_tuning();
    var graders_1 = require_graders2();
    var realtime_1 = require_realtime2();
    var responses_1 = require_responses();
    var uploads_1 = require_uploads3();
    var vector_stores_1 = require_vector_stores();
    var detect_platform_2 = require_detect_platform();
    var headers_1 = require_headers();
    var env_1 = require_env();
    var log_1 = require_log();
    var values_2 = require_values();
    var OpenAI = class {
      /**
       * API Client for interfacing with the OpenAI API.
       *
       * @param {string | undefined} [opts.apiKey=process.env['OPENAI_API_KEY'] ?? undefined]
       * @param {string | null | undefined} [opts.organization=process.env['OPENAI_ORG_ID'] ?? null]
       * @param {string | null | undefined} [opts.project=process.env['OPENAI_PROJECT_ID'] ?? null]
       * @param {string | null | undefined} [opts.webhookSecret=process.env['OPENAI_WEBHOOK_SECRET'] ?? null]
       * @param {string} [opts.baseURL=process.env['OPENAI_BASE_URL'] ?? https://api.openai.com/v1] - Override the default base URL for the API.
       * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
       * @param {MergedRequestInit} [opts.fetchOptions] - Additional `RequestInit` options to be passed to `fetch` calls.
       * @param {Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
       * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
       * @param {HeadersLike} opts.defaultHeaders - Default headers to include with every request to the API.
       * @param {Record<string, string | undefined>} opts.defaultQuery - Default query parameters to include with every request to the API.
       * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
       */
      constructor({ baseURL = (0, env_1.readEnv)("OPENAI_BASE_URL"), apiKey = (0, env_1.readEnv)("OPENAI_API_KEY"), organization = (0, env_1.readEnv)("OPENAI_ORG_ID") ?? null, project = (0, env_1.readEnv)("OPENAI_PROJECT_ID") ?? null, webhookSecret = (0, env_1.readEnv)("OPENAI_WEBHOOK_SECRET") ?? null, ...opts } = {}) {
        _OpenAI_instances.add(this);
        _OpenAI_encoder.set(this, void 0);
        this.completions = new API.Completions(this);
        this.chat = new API.Chat(this);
        this.embeddings = new API.Embeddings(this);
        this.files = new API.Files(this);
        this.images = new API.Images(this);
        this.audio = new API.Audio(this);
        this.moderations = new API.Moderations(this);
        this.models = new API.Models(this);
        this.fineTuning = new API.FineTuning(this);
        this.graders = new API.Graders(this);
        this.vectorStores = new API.VectorStores(this);
        this.webhooks = new API.Webhooks(this);
        this.beta = new API.Beta(this);
        this.batches = new API.Batches(this);
        this.uploads = new API.Uploads(this);
        this.responses = new API.Responses(this);
        this.realtime = new API.Realtime(this);
        this.conversations = new API.Conversations(this);
        this.evals = new API.Evals(this);
        this.containers = new API.Containers(this);
        if (apiKey === void 0) {
          throw new Errors.OpenAIError("Missing credentials. Please pass an `apiKey`, or set the `OPENAI_API_KEY` environment variable.");
        }
        const options = {
          apiKey,
          organization,
          project,
          webhookSecret,
          ...opts,
          baseURL: baseURL || `https://api.openai.com/v1`
        };
        if (!options.dangerouslyAllowBrowser && (0, detect_platform_2.isRunningInBrowser)()) {
          throw new Errors.OpenAIError("It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew OpenAI({ apiKey, dangerouslyAllowBrowser: true });\n\nhttps://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety\n");
        }
        this.baseURL = options.baseURL;
        this.timeout = options.timeout ?? _a.DEFAULT_TIMEOUT;
        this.logger = options.logger ?? console;
        const defaultLogLevel = "warn";
        this.logLevel = defaultLogLevel;
        this.logLevel = (0, log_1.parseLogLevel)(options.logLevel, "ClientOptions.logLevel", this) ?? (0, log_1.parseLogLevel)((0, env_1.readEnv)("OPENAI_LOG"), "process.env['OPENAI_LOG']", this) ?? defaultLogLevel;
        this.fetchOptions = options.fetchOptions;
        this.maxRetries = options.maxRetries ?? 2;
        this.fetch = options.fetch ?? Shims.getDefaultFetch();
        tslib_1.__classPrivateFieldSet(this, _OpenAI_encoder, Opts.FallbackEncoder, "f");
        this._options = options;
        this.apiKey = typeof apiKey === "string" ? apiKey : "Missing Key";
        this.organization = organization;
        this.project = project;
        this.webhookSecret = webhookSecret;
      }
      /**
       * Create a new client instance re-using the same options given to the current client with optional overriding.
       */
      withOptions(options) {
        const client = new this.constructor({
          ...this._options,
          baseURL: this.baseURL,
          maxRetries: this.maxRetries,
          timeout: this.timeout,
          logger: this.logger,
          logLevel: this.logLevel,
          fetch: this.fetch,
          fetchOptions: this.fetchOptions,
          apiKey: this.apiKey,
          organization: this.organization,
          project: this.project,
          webhookSecret: this.webhookSecret,
          ...options
        });
        return client;
      }
      defaultQuery() {
        return this._options.defaultQuery;
      }
      validateHeaders({ values, nulls }) {
        return;
      }
      async authHeaders(opts) {
        return (0, headers_1.buildHeaders)([{ Authorization: `Bearer ${this.apiKey}` }]);
      }
      stringifyQuery(query) {
        return qs.stringify(query, { arrayFormat: "brackets" });
      }
      getUserAgent() {
        return `${this.constructor.name}/JS ${version_1.VERSION}`;
      }
      defaultIdempotencyKey() {
        return `stainless-node-retry-${(0, uuid_1.uuid4)()}`;
      }
      makeStatusError(status, error, message, headers) {
        return Errors.APIError.generate(status, error, message, headers);
      }
      async _callApiKey() {
        const apiKey = this._options.apiKey;
        if (typeof apiKey !== "function")
          return false;
        let token;
        try {
          token = await apiKey();
        } catch (err) {
          if (err instanceof Errors.OpenAIError)
            throw err;
          throw new Errors.OpenAIError(
            `Failed to get token from 'apiKey' function: ${err.message}`,
            // @ts-ignore
            { cause: err }
          );
        }
        if (typeof token !== "string" || !token) {
          throw new Errors.OpenAIError(`Expected 'apiKey' function argument to return a string but it returned ${token}`);
        }
        this.apiKey = token;
        return true;
      }
      buildURL(path, query, defaultBaseURL) {
        const baseURL = !tslib_1.__classPrivateFieldGet(this, _OpenAI_instances, "m", _OpenAI_baseURLOverridden).call(this) && defaultBaseURL || this.baseURL;
        const url = (0, values_1.isAbsoluteURL)(path) ? new URL(path) : new URL(baseURL + (baseURL.endsWith("/") && path.startsWith("/") ? path.slice(1) : path));
        const defaultQuery = this.defaultQuery();
        if (!(0, values_2.isEmptyObj)(defaultQuery)) {
          query = { ...defaultQuery, ...query };
        }
        if (typeof query === "object" && query && !Array.isArray(query)) {
          url.search = this.stringifyQuery(query);
        }
        return url.toString();
      }
      /**
       * Used as a callback for mutating the given `FinalRequestOptions` object.
       */
      async prepareOptions(options) {
        await this._callApiKey();
      }
      /**
       * Used as a callback for mutating the given `RequestInit` object.
       *
       * This is useful for cases where you want to add certain headers based off of
       * the request properties, e.g. `method` or `url`.
       */
      async prepareRequest(request, { url, options }) {
      }
      get(path, opts) {
        return this.methodRequest("get", path, opts);
      }
      post(path, opts) {
        return this.methodRequest("post", path, opts);
      }
      patch(path, opts) {
        return this.methodRequest("patch", path, opts);
      }
      put(path, opts) {
        return this.methodRequest("put", path, opts);
      }
      delete(path, opts) {
        return this.methodRequest("delete", path, opts);
      }
      methodRequest(method, path, opts) {
        return this.request(Promise.resolve(opts).then((opts2) => {
          return { method, path, ...opts2 };
        }));
      }
      request(options, remainingRetries = null) {
        return new api_promise_1.APIPromise(this, this.makeRequest(options, remainingRetries, void 0));
      }
      async makeRequest(optionsInput, retriesRemaining, retryOfRequestLogID) {
        var _a2, _b;
        const options = await optionsInput;
        const maxRetries = options.maxRetries ?? this.maxRetries;
        if (retriesRemaining == null) {
          retriesRemaining = maxRetries;
        }
        await this.prepareOptions(options);
        const { req, url, timeout } = await this.buildRequest(options, {
          retryCount: maxRetries - retriesRemaining
        });
        await this.prepareRequest(req, { url, options });
        const requestLogID = "log_" + (Math.random() * (1 << 24) | 0).toString(16).padStart(6, "0");
        const retryLogStr = retryOfRequestLogID === void 0 ? "" : `, retryOf: ${retryOfRequestLogID}`;
        const startTime = Date.now();
        (0, log_1.loggerFor)(this).debug(`[${requestLogID}] sending request`, (0, log_1.formatRequestDetails)({
          retryOfRequestLogID,
          method: options.method,
          url,
          options,
          headers: req.headers
        }));
        if ((_a2 = options.signal) == null ? void 0 : _a2.aborted) {
          throw new Errors.APIUserAbortError();
        }
        const controller = new AbortController();
        const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(errors_1.castToError);
        const headersTime = Date.now();
        if (response instanceof globalThis.Error) {
          const retryMessage = `retrying, ${retriesRemaining} attempts remaining`;
          if ((_b = options.signal) == null ? void 0 : _b.aborted) {
            throw new Errors.APIUserAbortError();
          }
          const isTimeout = (0, errors_1.isAbortError)(response) || /timed? ?out/i.test(String(response) + ("cause" in response ? String(response.cause) : ""));
          if (retriesRemaining) {
            (0, log_1.loggerFor)(this).info(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} - ${retryMessage}`);
            (0, log_1.loggerFor)(this).debug(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} (${retryMessage})`, (0, log_1.formatRequestDetails)({
              retryOfRequestLogID,
              url,
              durationMs: headersTime - startTime,
              message: response.message
            }));
            return this.retryRequest(options, retriesRemaining, retryOfRequestLogID ?? requestLogID);
          }
          (0, log_1.loggerFor)(this).info(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} - error; no more retries left`);
          (0, log_1.loggerFor)(this).debug(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} (error; no more retries left)`, (0, log_1.formatRequestDetails)({
            retryOfRequestLogID,
            url,
            durationMs: headersTime - startTime,
            message: response.message
          }));
          if (isTimeout) {
            throw new Errors.APIConnectionTimeoutError();
          }
          throw new Errors.APIConnectionError({ cause: response });
        }
        const specialHeaders = [...response.headers.entries()].filter(([name]) => name === "x-request-id").map(([name, value]) => ", " + name + ": " + JSON.stringify(value)).join("");
        const responseInfo = `[${requestLogID}${retryLogStr}${specialHeaders}] ${req.method} ${url} ${response.ok ? "succeeded" : "failed"} with status ${response.status} in ${headersTime - startTime}ms`;
        if (!response.ok) {
          const shouldRetry = await this.shouldRetry(response);
          if (retriesRemaining && shouldRetry) {
            const retryMessage2 = `retrying, ${retriesRemaining} attempts remaining`;
            await Shims.CancelReadableStream(response.body);
            (0, log_1.loggerFor)(this).info(`${responseInfo} - ${retryMessage2}`);
            (0, log_1.loggerFor)(this).debug(`[${requestLogID}] response error (${retryMessage2})`, (0, log_1.formatRequestDetails)({
              retryOfRequestLogID,
              url: response.url,
              status: response.status,
              headers: response.headers,
              durationMs: headersTime - startTime
            }));
            return this.retryRequest(options, retriesRemaining, retryOfRequestLogID ?? requestLogID, response.headers);
          }
          const retryMessage = shouldRetry ? `error; no more retries left` : `error; not retryable`;
          (0, log_1.loggerFor)(this).info(`${responseInfo} - ${retryMessage}`);
          const errText = await response.text().catch((err2) => (0, errors_1.castToError)(err2).message);
          const errJSON = (0, values_1.safeJSON)(errText);
          const errMessage = errJSON ? void 0 : errText;
          (0, log_1.loggerFor)(this).debug(`[${requestLogID}] response error (${retryMessage})`, (0, log_1.formatRequestDetails)({
            retryOfRequestLogID,
            url: response.url,
            status: response.status,
            headers: response.headers,
            message: errMessage,
            durationMs: Date.now() - startTime
          }));
          const err = this.makeStatusError(response.status, errJSON, errMessage, response.headers);
          throw err;
        }
        (0, log_1.loggerFor)(this).info(responseInfo);
        (0, log_1.loggerFor)(this).debug(`[${requestLogID}] response start`, (0, log_1.formatRequestDetails)({
          retryOfRequestLogID,
          url: response.url,
          status: response.status,
          headers: response.headers,
          durationMs: headersTime - startTime
        }));
        return { response, options, controller, requestLogID, retryOfRequestLogID, startTime };
      }
      getAPIList(path, Page, opts) {
        return this.requestAPIList(Page, { method: "get", path, ...opts });
      }
      requestAPIList(Page, options) {
        const request = this.makeRequest(options, null, void 0);
        return new Pagination.PagePromise(this, request, Page);
      }
      async fetchWithTimeout(url, init, ms, controller) {
        const { signal, method, ...options } = init || {};
        if (signal)
          signal.addEventListener("abort", () => controller.abort());
        const timeout = setTimeout(() => controller.abort(), ms);
        const isReadableBody = globalThis.ReadableStream && options.body instanceof globalThis.ReadableStream || typeof options.body === "object" && options.body !== null && Symbol.asyncIterator in options.body;
        const fetchOptions = {
          signal: controller.signal,
          ...isReadableBody ? { duplex: "half" } : {},
          method: "GET",
          ...options
        };
        if (method) {
          fetchOptions.method = method.toUpperCase();
        }
        try {
          return await this.fetch.call(void 0, url, fetchOptions);
        } finally {
          clearTimeout(timeout);
        }
      }
      async shouldRetry(response) {
        const shouldRetryHeader = response.headers.get("x-should-retry");
        if (shouldRetryHeader === "true")
          return true;
        if (shouldRetryHeader === "false")
          return false;
        if (response.status === 408)
          return true;
        if (response.status === 409)
          return true;
        if (response.status === 429)
          return true;
        if (response.status >= 500)
          return true;
        return false;
      }
      async retryRequest(options, retriesRemaining, requestLogID, responseHeaders) {
        let timeoutMillis;
        const retryAfterMillisHeader = responseHeaders == null ? void 0 : responseHeaders.get("retry-after-ms");
        if (retryAfterMillisHeader) {
          const timeoutMs = parseFloat(retryAfterMillisHeader);
          if (!Number.isNaN(timeoutMs)) {
            timeoutMillis = timeoutMs;
          }
        }
        const retryAfterHeader = responseHeaders == null ? void 0 : responseHeaders.get("retry-after");
        if (retryAfterHeader && !timeoutMillis) {
          const timeoutSeconds = parseFloat(retryAfterHeader);
          if (!Number.isNaN(timeoutSeconds)) {
            timeoutMillis = timeoutSeconds * 1e3;
          } else {
            timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
          }
        }
        if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1e3)) {
          const maxRetries = options.maxRetries ?? this.maxRetries;
          timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
        }
        await (0, sleep_1.sleep)(timeoutMillis);
        return this.makeRequest(options, retriesRemaining - 1, requestLogID);
      }
      calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
        const initialRetryDelay = 0.5;
        const maxRetryDelay = 8;
        const numRetries = maxRetries - retriesRemaining;
        const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
        const jitter = 1 - Math.random() * 0.25;
        return sleepSeconds * jitter * 1e3;
      }
      async buildRequest(inputOptions, { retryCount = 0 } = {}) {
        const options = { ...inputOptions };
        const { method, path, query, defaultBaseURL } = options;
        const url = this.buildURL(path, query, defaultBaseURL);
        if ("timeout" in options)
          (0, values_1.validatePositiveInteger)("timeout", options.timeout);
        options.timeout = options.timeout ?? this.timeout;
        const { bodyHeaders, body } = this.buildBody({ options });
        const reqHeaders = await this.buildHeaders({ options: inputOptions, method, bodyHeaders, retryCount });
        const req = {
          method,
          headers: reqHeaders,
          ...options.signal && { signal: options.signal },
          ...globalThis.ReadableStream && body instanceof globalThis.ReadableStream && { duplex: "half" },
          ...body && { body },
          ...this.fetchOptions ?? {},
          ...options.fetchOptions ?? {}
        };
        return { req, url, timeout: options.timeout };
      }
      async buildHeaders({ options, method, bodyHeaders, retryCount }) {
        let idempotencyHeaders = {};
        if (this.idempotencyHeader && method !== "get") {
          if (!options.idempotencyKey)
            options.idempotencyKey = this.defaultIdempotencyKey();
          idempotencyHeaders[this.idempotencyHeader] = options.idempotencyKey;
        }
        const headers = (0, headers_1.buildHeaders)([
          idempotencyHeaders,
          {
            Accept: "application/json",
            "User-Agent": this.getUserAgent(),
            "X-Stainless-Retry-Count": String(retryCount),
            ...options.timeout ? { "X-Stainless-Timeout": String(Math.trunc(options.timeout / 1e3)) } : {},
            ...(0, detect_platform_1.getPlatformHeaders)(),
            "OpenAI-Organization": this.organization,
            "OpenAI-Project": this.project
          },
          await this.authHeaders(options),
          this._options.defaultHeaders,
          bodyHeaders,
          options.headers
        ]);
        this.validateHeaders(headers);
        return headers.values;
      }
      buildBody({ options: { body, headers: rawHeaders } }) {
        if (!body) {
          return { bodyHeaders: void 0, body: void 0 };
        }
        const headers = (0, headers_1.buildHeaders)([rawHeaders]);
        if (
          // Pass raw type verbatim
          ArrayBuffer.isView(body) || body instanceof ArrayBuffer || body instanceof DataView || typeof body === "string" && // Preserve legacy string encoding behavior for now
          headers.values.has("content-type") || // `Blob` is superset of `File`
          globalThis.Blob && body instanceof globalThis.Blob || // `FormData` -> `multipart/form-data`
          body instanceof FormData || // `URLSearchParams` -> `application/x-www-form-urlencoded`
          body instanceof URLSearchParams || // Send chunked stream (each chunk has own `length`)
          globalThis.ReadableStream && body instanceof globalThis.ReadableStream
        ) {
          return { bodyHeaders: void 0, body };
        } else if (typeof body === "object" && (Symbol.asyncIterator in body || Symbol.iterator in body && "next" in body && typeof body.next === "function")) {
          return { bodyHeaders: void 0, body: Shims.ReadableStreamFrom(body) };
        } else {
          return tslib_1.__classPrivateFieldGet(this, _OpenAI_encoder, "f").call(this, { body, headers });
        }
      }
    };
    exports.OpenAI = OpenAI;
    _a = OpenAI, _OpenAI_encoder = /* @__PURE__ */ new WeakMap(), _OpenAI_instances = /* @__PURE__ */ new WeakSet(), _OpenAI_baseURLOverridden = function _OpenAI_baseURLOverridden2() {
      return this.baseURL !== "https://api.openai.com/v1";
    };
    OpenAI.OpenAI = _a;
    OpenAI.DEFAULT_TIMEOUT = 6e5;
    OpenAI.OpenAIError = Errors.OpenAIError;
    OpenAI.APIError = Errors.APIError;
    OpenAI.APIConnectionError = Errors.APIConnectionError;
    OpenAI.APIConnectionTimeoutError = Errors.APIConnectionTimeoutError;
    OpenAI.APIUserAbortError = Errors.APIUserAbortError;
    OpenAI.NotFoundError = Errors.NotFoundError;
    OpenAI.ConflictError = Errors.ConflictError;
    OpenAI.RateLimitError = Errors.RateLimitError;
    OpenAI.BadRequestError = Errors.BadRequestError;
    OpenAI.AuthenticationError = Errors.AuthenticationError;
    OpenAI.InternalServerError = Errors.InternalServerError;
    OpenAI.PermissionDeniedError = Errors.PermissionDeniedError;
    OpenAI.UnprocessableEntityError = Errors.UnprocessableEntityError;
    OpenAI.InvalidWebhookSignatureError = Errors.InvalidWebhookSignatureError;
    OpenAI.toFile = Uploads.toFile;
    OpenAI.Completions = completions_1.Completions;
    OpenAI.Chat = chat_1.Chat;
    OpenAI.Embeddings = embeddings_1.Embeddings;
    OpenAI.Files = files_1.Files;
    OpenAI.Images = images_1.Images;
    OpenAI.Audio = audio_1.Audio;
    OpenAI.Moderations = moderations_1.Moderations;
    OpenAI.Models = models_1.Models;
    OpenAI.FineTuning = fine_tuning_1.FineTuning;
    OpenAI.Graders = graders_1.Graders;
    OpenAI.VectorStores = vector_stores_1.VectorStores;
    OpenAI.Webhooks = webhooks_1.Webhooks;
    OpenAI.Beta = beta_1.Beta;
    OpenAI.Batches = batches_1.Batches;
    OpenAI.Uploads = uploads_1.Uploads;
    OpenAI.Responses = responses_1.Responses;
    OpenAI.Realtime = realtime_1.Realtime;
    OpenAI.Conversations = conversations_1.Conversations;
    OpenAI.Evals = evals_1.Evals;
    OpenAI.Containers = containers_1.Containers;
  }
});

// node_modules/openai/azure.js
var require_azure = __commonJS({
  "node_modules/openai/azure.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AzureOpenAI = void 0;
    var tslib_1 = require_tslib();
    var headers_1 = require_headers();
    var Errors = tslib_1.__importStar(require_error2());
    var utils_1 = require_utils2();
    var client_1 = require_client();
    var AzureOpenAI = class extends client_1.OpenAI {
      /**
       * API Client for interfacing with the Azure OpenAI API.
       *
       * @param {string | undefined} [opts.apiVersion=process.env['OPENAI_API_VERSION'] ?? undefined]
       * @param {string | undefined} [opts.endpoint=process.env['AZURE_OPENAI_ENDPOINT'] ?? undefined] - Your Azure endpoint, including the resource, e.g. `https://example-resource.azure.openai.com/`
       * @param {string | undefined} [opts.apiKey=process.env['AZURE_OPENAI_API_KEY'] ?? undefined]
       * @param {string | undefined} opts.deployment - A model deployment, if given, sets the base client URL to include `/deployments/{deployment}`.
       * @param {string | null | undefined} [opts.organization=process.env['OPENAI_ORG_ID'] ?? null]
       * @param {string} [opts.baseURL=process.env['OPENAI_BASE_URL']] - Sets the base URL for the API, e.g. `https://example-resource.azure.openai.com/openai/`.
       * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
       * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.
       * @param {Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
       * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
       * @param {Headers} opts.defaultHeaders - Default headers to include with every request to the API.
       * @param {DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.
       * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
       */
      constructor({ baseURL = (0, utils_1.readEnv)("OPENAI_BASE_URL"), apiKey = (0, utils_1.readEnv)("AZURE_OPENAI_API_KEY"), apiVersion = (0, utils_1.readEnv)("OPENAI_API_VERSION"), endpoint, deployment, azureADTokenProvider, dangerouslyAllowBrowser, ...opts } = {}) {
        if (!apiVersion) {
          throw new Errors.OpenAIError("The OPENAI_API_VERSION environment variable is missing or empty; either provide it, or instantiate the AzureOpenAI client with an apiVersion option, like new AzureOpenAI({ apiVersion: 'My API Version' }).");
        }
        if (typeof azureADTokenProvider === "function") {
          dangerouslyAllowBrowser = true;
        }
        if (!azureADTokenProvider && !apiKey) {
          throw new Errors.OpenAIError("Missing credentials. Please pass one of `apiKey` and `azureADTokenProvider`, or set the `AZURE_OPENAI_API_KEY` environment variable.");
        }
        if (azureADTokenProvider && apiKey) {
          throw new Errors.OpenAIError("The `apiKey` and `azureADTokenProvider` arguments are mutually exclusive; only one can be passed at a time.");
        }
        opts.defaultQuery = { ...opts.defaultQuery, "api-version": apiVersion };
        if (!baseURL) {
          if (!endpoint) {
            endpoint = process.env["AZURE_OPENAI_ENDPOINT"];
          }
          if (!endpoint) {
            throw new Errors.OpenAIError("Must provide one of the `baseURL` or `endpoint` arguments, or the `AZURE_OPENAI_ENDPOINT` environment variable");
          }
          baseURL = `${endpoint}/openai`;
        } else {
          if (endpoint) {
            throw new Errors.OpenAIError("baseURL and endpoint are mutually exclusive");
          }
        }
        super({
          apiKey: azureADTokenProvider ?? apiKey,
          baseURL,
          ...opts,
          ...dangerouslyAllowBrowser !== void 0 ? { dangerouslyAllowBrowser } : {}
        });
        this.apiVersion = "";
        this.apiVersion = apiVersion;
        this.deploymentName = deployment;
      }
      async buildRequest(options, props = {}) {
        var _a;
        if (_deployments_endpoints.has(options.path) && options.method === "post" && options.body !== void 0) {
          if (!(0, utils_1.isObj)(options.body)) {
            throw new Error("Expected request body to be an object");
          }
          const model = this.deploymentName || options.body["model"] || ((_a = options.__metadata) == null ? void 0 : _a["model"]);
          if (model !== void 0 && !this.baseURL.includes("/deployments")) {
            options.path = `/deployments/${model}${options.path}`;
          }
        }
        return super.buildRequest(options, props);
      }
      async authHeaders(opts) {
        if (typeof this._options.apiKey === "string") {
          return (0, headers_1.buildHeaders)([{ "api-key": this.apiKey }]);
        }
        return super.authHeaders(opts);
      }
    };
    exports.AzureOpenAI = AzureOpenAI;
    var _deployments_endpoints = /* @__PURE__ */ new Set([
      "/completions",
      "/chat/completions",
      "/embeddings",
      "/audio/transcriptions",
      "/audio/translations",
      "/audio/speech",
      "/images/generations",
      "/batches",
      "/images/edits"
    ]);
  }
});

// node_modules/openai/index.js
var require_openai = __commonJS({
  "node_modules/openai/index.js"(exports, module) {
    "use strict";
    exports = module.exports = function(...args) {
      return new exports.default(...args);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AzureOpenAI = exports.InvalidWebhookSignatureError = exports.UnprocessableEntityError = exports.PermissionDeniedError = exports.InternalServerError = exports.AuthenticationError = exports.BadRequestError = exports.RateLimitError = exports.ConflictError = exports.NotFoundError = exports.APIUserAbortError = exports.APIConnectionTimeoutError = exports.APIConnectionError = exports.APIError = exports.OpenAIError = exports.PagePromise = exports.OpenAI = exports.APIPromise = exports.toFile = exports.default = void 0;
    var client_1 = require_client();
    Object.defineProperty(exports, "default", { enumerable: true, get: function() {
      return client_1.OpenAI;
    } });
    var uploads_1 = require_uploads2();
    Object.defineProperty(exports, "toFile", { enumerable: true, get: function() {
      return uploads_1.toFile;
    } });
    var api_promise_1 = require_api_promise();
    Object.defineProperty(exports, "APIPromise", { enumerable: true, get: function() {
      return api_promise_1.APIPromise;
    } });
    var client_2 = require_client();
    Object.defineProperty(exports, "OpenAI", { enumerable: true, get: function() {
      return client_2.OpenAI;
    } });
    var pagination_1 = require_pagination();
    Object.defineProperty(exports, "PagePromise", { enumerable: true, get: function() {
      return pagination_1.PagePromise;
    } });
    var error_1 = require_error();
    Object.defineProperty(exports, "OpenAIError", { enumerable: true, get: function() {
      return error_1.OpenAIError;
    } });
    Object.defineProperty(exports, "APIError", { enumerable: true, get: function() {
      return error_1.APIError;
    } });
    Object.defineProperty(exports, "APIConnectionError", { enumerable: true, get: function() {
      return error_1.APIConnectionError;
    } });
    Object.defineProperty(exports, "APIConnectionTimeoutError", { enumerable: true, get: function() {
      return error_1.APIConnectionTimeoutError;
    } });
    Object.defineProperty(exports, "APIUserAbortError", { enumerable: true, get: function() {
      return error_1.APIUserAbortError;
    } });
    Object.defineProperty(exports, "NotFoundError", { enumerable: true, get: function() {
      return error_1.NotFoundError;
    } });
    Object.defineProperty(exports, "ConflictError", { enumerable: true, get: function() {
      return error_1.ConflictError;
    } });
    Object.defineProperty(exports, "RateLimitError", { enumerable: true, get: function() {
      return error_1.RateLimitError;
    } });
    Object.defineProperty(exports, "BadRequestError", { enumerable: true, get: function() {
      return error_1.BadRequestError;
    } });
    Object.defineProperty(exports, "AuthenticationError", { enumerable: true, get: function() {
      return error_1.AuthenticationError;
    } });
    Object.defineProperty(exports, "InternalServerError", { enumerable: true, get: function() {
      return error_1.InternalServerError;
    } });
    Object.defineProperty(exports, "PermissionDeniedError", { enumerable: true, get: function() {
      return error_1.PermissionDeniedError;
    } });
    Object.defineProperty(exports, "UnprocessableEntityError", { enumerable: true, get: function() {
      return error_1.UnprocessableEntityError;
    } });
    Object.defineProperty(exports, "InvalidWebhookSignatureError", { enumerable: true, get: function() {
      return error_1.InvalidWebhookSignatureError;
    } });
    var azure_1 = require_azure();
    Object.defineProperty(exports, "AzureOpenAI", { enumerable: true, get: function() {
      return azure_1.AzureOpenAI;
    } });
  }
});

// node_modules/@devvai/devv-code-backend/dist/ai.js
var require_ai = __commonJS({
  "node_modules/@devvai/devv-code-backend/dist/ai.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DevvAI = void 0;
    var openai_1 = __importDefault(require_openai());
    var device_1 = require_device();
    var session_1 = require_session();
    var constants_1 = require_constants();
    var DevvAI = class extends openai_1.default {
      constructor() {
        const sid = (0, session_1.getSid)();
        const deviceId = (0, device_1.getEncryptedDeviceId)();
        super({
          apiKey: sid || "",
          // OpenAI SDK requires an API key, but we use session-based auth
          baseURL: `${constants_1.BASE_URL}openai/v1`,
          dangerouslyAllowBrowser: true,
          defaultHeaders: {
            "Device-Id": deviceId,
            "sid": sid
          }
        });
      }
    };
    exports.DevvAI = DevvAI;
  }
});

// node_modules/@devvai/devv-code-backend/dist/openrouter.js
var require_openrouter = __commonJS({
  "node_modules/@devvai/devv-code-backend/dist/openrouter.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OpenRouterAI = void 0;
    var openai_1 = __importDefault(require_openai());
    var device_1 = require_device();
    var session_1 = require_session();
    var constants_1 = require_constants();
    var OpenRouterAI = class extends openai_1.default {
      constructor() {
        const sid = (0, session_1.getSid)();
        const deviceId = (0, device_1.getEncryptedDeviceId)();
        super({
          apiKey: sid || "",
          // OpenAI SDK requires an API key, but we use session-based auth
          baseURL: `${constants_1.BASE_URL}openrouter/v1`,
          dangerouslyAllowBrowser: true,
          defaultHeaders: {
            "Device-Id": deviceId,
            "sid": sid
          }
        });
      }
    };
    exports.OpenRouterAI = OpenRouterAI;
  }
});

// node_modules/@devvai/devv-code-backend/dist/imageGen.js
var require_imageGen = __commonJS({
  "node_modules/@devvai/devv-code-backend/dist/imageGen.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DevvImageGen = void 0;
    var device_1 = require_device();
    var session_1 = require_session();
    var constants_1 = require_constants();
    var DevvImageGen = class {
      async textToImage(options) {
        if (!options.prompt) {
          throw new Error("Prompt is required for text-to-image generation");
        }
        const requestBody = {
          prompt: options.prompt,
          ...options.model && { model: options.model },
          ...options.image_url && { image_url: options.image_url },
          ...options.image_urls && { image_urls: options.image_urls },
          ...options.num_outputs !== void 0 && { num_outputs: options.num_outputs },
          ...options.aspect_ratio && { aspect_ratio: options.aspect_ratio },
          ...options.output_format && { output_format: options.output_format }
        };
        if (!options.model && requestBody.num_outputs !== void 0) {
          if (requestBody.num_outputs < 1 || requestBody.num_outputs > 4) {
            throw new Error("num_outputs must be between 1 and 4");
          }
        }
        if (!options.model && requestBody.num_outputs === void 0) {
          requestBody.num_outputs = 1;
        }
        const deviceId = (0, device_1.getEncryptedDeviceId)();
        const sid = (0, session_1.getSid)();
        const headers = {
          "Content-Type": "application/json",
          "Device-Id": deviceId
        };
        if (sid) {
          headers["sid"] = sid;
        }
        const response = await fetch(`${constants_1.BASE_URL}api/v1/text-to-image`, {
          method: "POST",
          headers,
          body: JSON.stringify(requestBody)
        });
        if (!response.ok) {
          const error = await response.json().catch(() => ({ error: "Text-to-image generation failed" }));
          throw new Error(error.error || `Failed to generate image (Status: ${response.status})`);
        }
        return await response.json();
      }
    };
    exports.DevvImageGen = DevvImageGen;
  }
});

// node_modules/@devvai/devv-code-backend/dist/webSearch.js
var require_webSearch = __commonJS({
  "node_modules/@devvai/devv-code-backend/dist/webSearch.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DevvWebSearch = void 0;
    var device_1 = require_device();
    var session_1 = require_session();
    var constants_1 = require_constants();
    var DevvWebSearch = class {
      async search(options) {
        if (!options.query) {
          throw new Error("Query is required for web search");
        }
        const query = this.formatQuery(options.query);
        const deviceId = (0, device_1.getEncryptedDeviceId)();
        const sid = (0, session_1.getSid)();
        const headers = {
          "Accept": "application/json",
          "X-Respond-With": "no-content",
          "Device-Id": deviceId
        };
        if (sid) {
          headers["sid"] = sid;
        }
        const response = await fetch(`${constants_1.BASE_URL}api/v1/jina-serp?q=${query}`, {
          method: "POST",
          headers
        });
        if (!response.ok) {
          const error = await response.json().catch(() => ({ error: "Web search failed" }));
          throw new Error(error.error || `Failed to search (Status: ${response.status})`);
        }
        const result = await response.json();
        if (result.code !== 200 || result.status !== 2e4) {
          throw new Error(`Search failed with code ${result.code}`);
        }
        return result;
      }
      formatQuery(query) {
        if (Array.isArray(query)) {
          return encodeURIComponent(query.join(" "));
        }
        return encodeURIComponent(query);
      }
    };
    exports.DevvWebSearch = DevvWebSearch;
  }
});

// node_modules/@devvai/devv-code-backend/dist/webReader.js
var require_webReader = __commonJS({
  "node_modules/@devvai/devv-code-backend/dist/webReader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DevvWebReader = void 0;
    var device_1 = require_device();
    var session_1 = require_session();
    var constants_1 = require_constants();
    var DevvWebReader = class {
      async read(options) {
        if (!options.url) {
          throw new Error("URL is required for web reader");
        }
        const encodedUrl = encodeURIComponent(options.url);
        const deviceId = (0, device_1.getEncryptedDeviceId)();
        const sid = (0, session_1.getSid)();
        const headers = {
          "Accept": "application/json",
          "Device-Id": deviceId
        };
        if (sid) {
          headers["sid"] = sid;
        }
        const response = await fetch(`${constants_1.BASE_URL}api/v1/jina-reader/${encodedUrl}`, {
          method: "POST",
          headers
        });
        if (!response.ok) {
          const error = await response.json().catch(() => ({ error: "Web reader failed" }));
          throw new Error(error.error || `Failed to read URL (Status: ${response.status})`);
        }
        const result = await response.json();
        if (result.code !== 200 || result.status !== 2e4) {
          throw new Error(`Read failed with code ${result.code}`);
        }
        return result;
      }
    };
    exports.DevvWebReader = DevvWebReader;
  }
});

// node_modules/@devvai/devv-code-backend/dist/tts.js
var require_tts = __commonJS({
  "node_modules/@devvai/devv-code-backend/dist/tts.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DevvTTS = void 0;
    var device_1 = require_device();
    var session_1 = require_session();
    var constants_1 = require_constants();
    var DevvTTS = class {
      async convert(options) {
        if (!options.text) {
          throw new Error("Text is required for text-to-speech conversion");
        }
        const deviceId = (0, device_1.getEncryptedDeviceId)();
        const sid = (0, session_1.getSid)();
        const headers = {
          "Content-Type": "application/json",
          "Device-Id": deviceId
        };
        if (sid) {
          headers["sid"] = sid;
        }
        const response = await fetch(`${constants_1.BASE_URL}api/v1/text-to-speech`, {
          method: "POST",
          headers,
          body: JSON.stringify(options)
        });
        if (!response.ok) {
          const error = await response.json().catch(() => ({ error: "Text-to-speech conversion failed" }));
          if (response.status === 401 || response.status === 403) {
            throw new Error("ElevenLabs API key error. Please ensure you have configured your ElevenLabs API key in the external API keys configuration.");
          }
          throw new Error(error.error || `Failed to convert text to speech (Status: ${response.status})`);
        }
        return await response.json();
      }
    };
    exports.DevvTTS = DevvTTS;
  }
});

// node_modules/@devvai/devv-code-backend/dist/replicate.js
var require_replicate = __commonJS({
  "node_modules/@devvai/devv-code-backend/dist/replicate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DevvReplicate = void 0;
    var device_1 = require_device();
    var session_1 = require_session();
    var constants_1 = require_constants();
    var DevvReplicate = class _DevvReplicate {
      async textToImage(options) {
        if (!options.prompt) {
          throw new Error("Prompt is required for text-to-image generation");
        }
        if (!options.model) {
          throw new Error("Model is required for Replicate image generation");
        }
        if (!_DevvReplicate.ALLOWED_MODELS.includes(options.model)) {
          throw new Error(`Invalid model: ${options.model}. Allowed models are: ${_DevvReplicate.ALLOWED_MODELS.join(", ")}`);
        }
        const requestBody = {
          prompt: options.prompt,
          model: options.model,
          num_outputs: options.num_outputs ?? 1,
          ...options.width && { width: options.width },
          ...options.height && { height: options.height },
          ...options.aspect_ratio && { aspect_ratio: options.aspect_ratio },
          ...options.output_format && { output_format: options.output_format },
          ...options.negative_prompt && { negative_prompt: options.negative_prompt },
          ...options.guidance_scale && { guidance_scale: options.guidance_scale },
          ...options.num_inference_steps && { num_inference_steps: options.num_inference_steps },
          ...options.seed && { seed: options.seed }
        };
        if (requestBody.num_outputs < 1 || requestBody.num_outputs > 4) {
          throw new Error("num_outputs must be between 1 and 4");
        }
        const deviceId = (0, device_1.getEncryptedDeviceId)();
        const sid = (0, session_1.getSid)();
        const headers = {
          "Content-Type": "application/json",
          "Device-Id": deviceId
        };
        if (sid) {
          headers["sid"] = sid;
        }
        const response = await fetch(`${constants_1.BASE_URL}api/v1/replicate/text-to-image`, {
          method: "POST",
          headers,
          body: JSON.stringify(requestBody)
        });
        if (!response.ok) {
          const error = await response.json().catch(() => ({
            error: "Replicate image generation failed"
          }));
          throw new Error(error.error || `Failed to generate image with Replicate (Status: ${response.status})`);
        }
        return await response.json();
      }
    };
    exports.DevvReplicate = DevvReplicate;
    DevvReplicate.ALLOWED_MODELS = [
      "ideogram-ai/ideogram-v3-turbo",
      "black-forest-labs/flux-schnell",
      "google/imagen-4-fast",
      "black-forest-labs/flux-kontext-pro",
      "prunaai/hidream-l1-fast",
      "luma/photon-flash"
    ];
  }
});

// node_modules/@devvai/devv-code-backend/dist/elevenlabs.js
var require_elevenlabs = __commonJS({
  "node_modules/@devvai/devv-code-backend/dist/elevenlabs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DevvElevenLabs = void 0;
    var device_1 = require_device();
    var session_1 = require_session();
    var constants_1 = require_constants();
    var DevvElevenLabs = class {
      /**
       * Convert text to speech using ElevenLabs
       * @param options Text-to-speech configuration options
       * @returns Audio file URL and metadata
       */
      async textToSpeech(options) {
        if (!options.text) {
          throw new Error("Text is required for text-to-speech conversion");
        }
        const deviceId = (0, device_1.getEncryptedDeviceId)();
        const sid = (0, session_1.getSid)();
        const headers = {
          "Content-Type": "application/json",
          "Device-Id": deviceId
        };
        if (sid) {
          headers["sid"] = sid;
        }
        const response = await fetch(`${constants_1.BASE_URL}api/v1/text-to-speech`, {
          method: "POST",
          headers,
          body: JSON.stringify(options)
        });
        if (!response.ok) {
          const error = await response.json().catch(() => ({ error: "Text-to-speech conversion failed" }));
          if (response.status === 401 || response.status === 403) {
            throw new Error("Authentication error. Please ensure you are logged in.");
          }
          throw new Error(error.error || `Failed to convert text to speech (Status: ${response.status})`);
        }
        return await response.json();
      }
      /**
       * Transcribe audio to text using ElevenLabs
       * @param options Speech-to-text configuration options
       * @returns Transcription with word-level timing information
       */
      async speechToText(options) {
        if (!options.audio_url) {
          throw new Error("Audio URL is required for speech-to-text conversion");
        }
        const deviceId = (0, device_1.getEncryptedDeviceId)();
        const sid = (0, session_1.getSid)();
        const headers = {
          "Content-Type": "application/json",
          "Device-Id": deviceId
        };
        if (sid) {
          headers["sid"] = sid;
        }
        const response = await fetch(`${constants_1.BASE_URL}api/v1/speech-to-text`, {
          method: "POST",
          headers,
          body: JSON.stringify(options)
        });
        if (!response.ok) {
          const error = await response.json().catch(() => ({ error: "Speech-to-text conversion failed" }));
          if (response.status === 401 || response.status === 403) {
            throw new Error("Authentication error. Please ensure you are logged in.");
          }
          throw new Error(error.error || `Failed to convert speech to text (Status: ${response.status})`);
        }
        return await response.json();
      }
    };
    exports.DevvElevenLabs = DevvElevenLabs;
  }
});

// node_modules/@devvai/devv-code-backend/dist/index.js
var require_dist = __commonJS({
  "node_modules/@devvai/devv-code-backend/dist/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.elevenlabs = exports.replicate = exports.tts = exports.webReader = exports.webSearch = exports.imageGen = exports.email = exports.upload = exports.table = exports.auth = exports.DevvElevenLabs = exports.DevvReplicate = exports.DevvTTS = exports.DevvWebReader = exports.DevvWebSearch = exports.DevvImageGen = exports.OpenRouterAI = exports.DevvAI = exports.DevvEmail = exports.FileUpload = exports.ProjectTable = exports.DevvAuth = void 0;
    var auth_1 = require_auth();
    Object.defineProperty(exports, "DevvAuth", { enumerable: true, get: function() {
      return auth_1.DevvAuth;
    } });
    var table_1 = require_table();
    Object.defineProperty(exports, "ProjectTable", { enumerable: true, get: function() {
      return table_1.ProjectTable;
    } });
    var upload_1 = require_upload();
    Object.defineProperty(exports, "FileUpload", { enumerable: true, get: function() {
      return upload_1.FileUpload;
    } });
    var email_1 = require_email();
    Object.defineProperty(exports, "DevvEmail", { enumerable: true, get: function() {
      return email_1.DevvEmail;
    } });
    var ai_1 = require_ai();
    Object.defineProperty(exports, "DevvAI", { enumerable: true, get: function() {
      return ai_1.DevvAI;
    } });
    var openrouter_1 = require_openrouter();
    Object.defineProperty(exports, "OpenRouterAI", { enumerable: true, get: function() {
      return openrouter_1.OpenRouterAI;
    } });
    var imageGen_1 = require_imageGen();
    Object.defineProperty(exports, "DevvImageGen", { enumerable: true, get: function() {
      return imageGen_1.DevvImageGen;
    } });
    var webSearch_1 = require_webSearch();
    Object.defineProperty(exports, "DevvWebSearch", { enumerable: true, get: function() {
      return webSearch_1.DevvWebSearch;
    } });
    var webReader_1 = require_webReader();
    Object.defineProperty(exports, "DevvWebReader", { enumerable: true, get: function() {
      return webReader_1.DevvWebReader;
    } });
    var tts_1 = require_tts();
    Object.defineProperty(exports, "DevvTTS", { enumerable: true, get: function() {
      return tts_1.DevvTTS;
    } });
    var replicate_1 = require_replicate();
    Object.defineProperty(exports, "DevvReplicate", { enumerable: true, get: function() {
      return replicate_1.DevvReplicate;
    } });
    var elevenlabs_1 = require_elevenlabs();
    Object.defineProperty(exports, "DevvElevenLabs", { enumerable: true, get: function() {
      return elevenlabs_1.DevvElevenLabs;
    } });
    var auth_2 = require_auth();
    var table_2 = require_table();
    var upload_2 = require_upload();
    var email_2 = require_email();
    var imageGen_2 = require_imageGen();
    var webSearch_2 = require_webSearch();
    var webReader_2 = require_webReader();
    var tts_2 = require_tts();
    var replicate_2 = require_replicate();
    var elevenlabs_2 = require_elevenlabs();
    var device_1 = require_device();
    var package_json_1 = require_package();
    (0, device_1.initializeDeviceId)();
    if (package_json_1.version.includes("dev")) {
      console.log(" Devv Code Backend SDK - ");
      console.log(" ");
    }
    exports.auth = new auth_2.DevvAuth();
    exports.table = new table_2.ProjectTable();
    exports.upload = new upload_2.FileUpload();
    exports.email = new email_2.DevvEmail();
    exports.imageGen = new imageGen_2.DevvImageGen();
    exports.webSearch = new webSearch_2.DevvWebSearch();
    exports.webReader = new webReader_2.DevvWebReader();
    exports.tts = new tts_2.DevvTTS();
    exports.replicate = new replicate_2.DevvReplicate();
    exports.elevenlabs = new elevenlabs_2.DevvElevenLabs();
  }
});
export default require_dist();
/*! Bundled license information:

js-sha256/src/sha256.js:
  (**
   * [js-sha256]{@link https://github.com/emn178/js-sha256}
   *
   * @version 0.11.1
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2014-2025
   * @license MIT
   *)
*/
//# sourceMappingURL=@devvai_devv-code-backend.js.map
